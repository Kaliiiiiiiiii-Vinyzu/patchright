# NOTE: This patch file is generated automatically and is not used, it is only for documentation. The driver is actually patched using [patchright_driver_patch](https://github.com/Kaliiiiiiiiii-Vinyzu/patchright/blob/main/patchright_driver_patch.js), see [the workflow](https://github.com/Kaliiiiiiiiii-Vinyzu/patchright/blob/main/.github/workflows/patchright_workflow.yml)
diff -ruN playwright/node_modules/playwright-core/src/protocol/validator.ts patchright/node_modules/playwright-core/src/protocol/validator.ts
--- playwright/node_modules/playwright-core/src/protocol/validator.ts	2025-03-19 15:32:27.004465571 +0000
+++ patchright/node_modules/playwright-core/src/protocol/validator.ts	2025-03-19 15:32:33.831521861 +0000
@@ -1551,6 +1551,7 @@
   expression: tString,
   isFunction: tOptional(tBoolean),
   arg: tType('SerializedArgument'),
+  isolatedContext: tBoolean
 });
 scheme.FrameEvaluateExpressionResult = tObject({
   value: tType('SerializedValue'),
@@ -1836,6 +1837,7 @@
   expression: tString,
   isFunction: tOptional(tBoolean),
   arg: tType('SerializedArgument'),
+  isolatedContext: tBoolean
 });
 scheme.WorkerEvaluateExpressionResult = tObject({
   value: tType('SerializedValue'),
@@ -1863,6 +1865,7 @@
   expression: tString,
   isFunction: tOptional(tBoolean),
   arg: tType('SerializedArgument'),
+  isolatedContext: tBoolean
 });
 scheme.ElementHandleEvaluateExpressionParams = tType('JSHandleEvaluateExpressionParams');
 scheme.JSHandleEvaluateExpressionResult = tObject({
diff -ruN playwright/node_modules/playwright-core/src/server/bidi/bidiPage.ts patchright/node_modules/playwright-core/src/server/bidi/bidiPage.ts
--- playwright/node_modules/playwright-core/src/server/bidi/bidiPage.ts	2025-03-19 15:32:27.006465589 +0000
+++ patchright/node_modules/playwright-core/src/server/bidi/bidiPage.ts	2025-03-19 15:32:33.832521869 +0000
@@ -376,7 +376,7 @@
       this._initScriptIds.push(script);
   }
 
-  async removeNonInternalInitScripts() {
+  async removeInitScripts() {
     const promises = this._initScriptIds.map(script => this._session.send('script.removePreloadScript', { script }));
     this._initScriptIds = [];
     await Promise.all(promises);
diff -ruN playwright/node_modules/playwright-core/src/server/browserContext.ts patchright/node_modules/playwright-core/src/server/browserContext.ts
--- playwright/node_modules/playwright-core/src/server/browserContext.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/node_modules/playwright-core/src/server/browserContext.ts	2025-03-19 15:32:33.831521861 +0000
@@ -149,7 +149,7 @@
     if (debugMode() === 'console')
       await this.extendInjectedScript(consoleApiSource.source);
     if (this._options.serviceWorkers === 'block')
-      await this.addInitScript(`\nif (navigator.serviceWorker) navigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };\n`);
+      await this.addInitScript(`navigator.serviceWorker.register = async () => { };`);
 
     if (this._options.permissions)
       await this.grantPermissions(this._options.permissions);
@@ -332,16 +332,15 @@
     }
     const binding = new PageBinding(name, playwrightBinding, needsHandle);
     this._pageBindings.set(name, binding);
-    await this.doAddInitScript(binding.initScript);
-    const frames = this.pages().map(page => page.frames()).flat();
-    await Promise.all(frames.map(frame => frame.evaluateExpression(binding.initScript.source).catch(e => {})));
+    await this.doExposeBinding(binding);
   }
 
   async _removeExposedBindings() {
-    for (const [key, binding] of this._pageBindings) {
-      if (!binding.internal)
+    for (const key of this._pageBindings.keys()) {
+      if (!key.startsWith('__pw'))
         this._pageBindings.delete(key);
     }
+    await this.doRemoveExposedBindings();
   }
 
   async grantPermissions(permissions: string[], origin?: string) {
@@ -430,8 +429,8 @@
   }
 
   async _removeInitScripts(): Promise<void> {
-    this.initScripts = this.initScripts.filter(script => script.internal);
-    await this.doRemoveNonInternalInitScripts();
+    this.initScripts.splice(0, this.initScripts.length);
+    await this.doRemoveInitScripts();
   }
 
   async setRequestInterceptor(handler: network.RouteHandler | undefined): Promise<void> {
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/chromiumSwitches.ts patchright/node_modules/playwright-core/src/server/chromium/chromiumSwitches.ts
--- playwright/node_modules/playwright-core/src/server/chromium/chromiumSwitches.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/node_modules/playwright-core/src/server/chromium/chromiumSwitches.ts	2025-03-19 15:32:33.833521877 +0000
@@ -58,27 +58,16 @@
   '--disable-field-trial-config', // https://source.chromium.org/chromium/chromium/src/+/main:testing/variations/README.md
   '--disable-background-networking',
   '--disable-background-timer-throttling',
-  '--disable-backgrounding-occluded-windows',
-  '--disable-back-forward-cache', // Avoids surprises like main request not being intercepted during page.goBack().
-  '--disable-breakpad',
-  '--disable-client-side-phishing-detection',
-  '--disable-component-extensions-with-background-pages',
-  '--disable-component-update', // Avoids unneeded network activity after startup.
+  '--disable-backgrounding-occluded-windows', // Avoids surprises like main request not being intercepted during page.goBack().
+  '--disable-breakpad', // Avoids unneeded network activity after startup.
   '--no-default-browser-check',
-  '--disable-default-apps',
   '--disable-dev-shm-usage',
-  '--disable-extensions',
   '--disable-features=' + disabledFeatures.join(','),
-  '--allow-pre-commit-input',
   '--disable-hang-monitor',
-  '--disable-ipc-flooding-protection',
-  '--disable-popup-blocking',
   '--disable-prompt-on-repost',
   '--disable-renderer-backgrounding',
   '--force-color-profile=srgb',
-  '--metrics-recording-only',
   '--no-first-run',
-  '--enable-automation',
   '--password-store=basic',
   '--use-mock-keychain',
   // See https://chromium-review.googlesource.com/c/chromium/src/+/2436773
@@ -86,6 +75,5 @@
   '--export-tagged-pdf',
   // https://chromium-review.googlesource.com/c/chromium/src/+/4853540
   '--disable-search-engine-choice-screen',
-  // https://issues.chromium.org/41491762
-  '--unsafely-disable-devtools-self-xss-warnings',
+  '--disable-blink-features=AutomationControlled'
 ];
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/crBrowser.ts patchright/node_modules/playwright-core/src/server/chromium/crBrowser.ts
--- playwright/node_modules/playwright-core/src/server/chromium/crBrowser.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/node_modules/playwright-core/src/server/chromium/crBrowser.ts	2025-03-19 15:32:33.833521877 +0000
@@ -474,11 +474,6 @@
       await (page._delegate as CRPage).addInitScript(initScript);
   }
 
-  async doRemoveNonInternalInitScripts() {
-    for (const page of this.pages())
-      await (page._delegate as CRPage).removeNonInternalInitScripts();
-  }
-
   async doUpdateRequestInterception(): Promise<void> {
     for (const page of this.pages())
       await (page._delegate as CRPage).updateRequestInterception();
@@ -578,4 +573,16 @@
     const rootSession = await this._browser._clientRootSession();
     return rootSession.attachToTarget(targetId);
   }
+
+  async doRemoveInitScripts() {
+    for (const page of this.pages()) await (page._delegate as CRPage).removeInitScripts();
+  }
+
+  async doExposeBinding(binding: PageBinding) {
+    for (const page of this.pages()) await (page._delegate as CRPage).exposeBinding(binding);
+  }
+
+  async doRemoveExposedBindings() {
+    for (const page of this.pages()) await (page._delegate as CRPage).removeExposedBindings();
+  }
 }
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/crDevTools.ts patchright/node_modules/playwright-core/src/server/chromium/crDevTools.ts
--- playwright/node_modules/playwright-core/src/server/chromium/crDevTools.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/node_modules/playwright-core/src/server/chromium/crDevTools.ts	2025-03-19 15:32:33.833521877 +0000
@@ -67,7 +67,6 @@
       }).catch(e => null);
     });
     Promise.all([
-      session.send('Runtime.enable'),
       session.send('Runtime.addBinding', { name: kBindingName }),
       session.send('Page.enable'),
       session.send('Page.addScriptToEvaluateOnNewDocument', { source: `
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/crNetworkManager.ts patchright/node_modules/playwright-core/src/server/chromium/crNetworkManager.ts
--- playwright/node_modules/playwright-core/src/server/chromium/crNetworkManager.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/node_modules/playwright-core/src/server/chromium/crNetworkManager.ts	2025-03-19 15:32:33.833521877 +0000
@@ -1,3 +1,5 @@
+// undetected-undetected_playwright-patch - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -156,7 +158,7 @@
     const enabled = this._protocolRequestInterceptionEnabled;
     if (initial && !enabled)
       return;
-    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: enabled });
+    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: false });
     let fetchPromise = Promise.resolve<any>(undefined);
     if (!info.workerFrame) {
       if (enabled)
@@ -342,7 +344,7 @@
         headersOverride = redirectedFrom?._originalRequestRoute?._alreadyContinuedParams?.headers;
         requestPausedSessionInfo!.session._sendMayFail('Fetch.continueRequest', { requestId: requestPausedEvent.requestId, headers: headersOverride });
       } else {
-        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId);
+        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId, this._page);
       }
     }
     const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === 'Document';
@@ -606,9 +608,11 @@
   _alreadyContinuedParams: Protocol.Fetch.continueRequestParameters | undefined;
   _fulfilled: boolean = false;
 
-  constructor(session: CRSession, interceptionId: string) {
+  constructor(session: CRSession, interceptionId: string, page: Page) {
+    this._page = void 0;
     this._session = session;
     this._interceptionId = interceptionId;
+    this._page = page;
   }
 
   async continue(overrides: types.NormalizedContinueOverrides): Promise<void> {
@@ -625,6 +629,42 @@
   }
 
   async fulfill(response: types.NormalizedFulfillResponse) {
+    const isTextHtml = response.headers.some(header => header.name === 'content-type' && header.value.includes('text/html'));
+      var allInjections = [...this._page._delegate._mainFrameSession._evaluateOnNewDocumentScripts];
+          for (const binding of this._page._delegate._browserContext._pageBindings.values()) {
+            if (!allInjections.includes(binding)) allInjections.push(binding);
+          }
+      if (isTextHtml && allInjections.length) {
+        // I Chatted so hard for this Code
+        let scriptNonce = crypto.randomBytes(22).toString('hex');
+        for (let i = 0; i < response.headers.length; i++) {
+          if (response.headers[i].name === 'content-security-policy' || response.headers[i].name === 'content-security-policy-report-only') {
+            // Search for an existing script-src nonce that we can hijack
+            let cspValue = response.headers[i].value;
+            const nonceRegex = /script-src[^;]*'nonce-([\w-]+)'/;
+            const nonceMatch = cspValue.match(nonceRegex);
+            if (nonceMatch) {
+              scriptNonce = nonceMatch[1];
+            } else {
+              // Add the new nonce value to the script-src directive
+              const scriptSrcRegex = /(script-src[^;]*)(;|$)/;
+              const newCspValue = cspValue.replace(scriptSrcRegex, `$1 'nonce-${scriptNonce}'$2`);
+              response.headers[i].value = newCspValue;
+            }
+            break;
+          }
+        }
+        let injectionHTML = "";
+        allInjections.forEach((script) => {
+          injectionHTML += `<script class="${this._page._delegate.initScriptTag}" nonce="${scriptNonce}" type="text/javascript">${script.source}</script>`;
+        });
+        if (response.isBase64) {
+          response.isBase64 = false;
+          response.body = injectionHTML + Buffer.from(response.body, 'base64').toString('utf-8');
+        } else {
+          response.body = injectionHTML + response.body;
+        }
+      }
     this._fulfilled = true;
     const body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');
 
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/crPage.ts patchright/node_modules/playwright-core/src/server/chromium/crPage.ts
--- playwright/node_modules/playwright-core/src/server/chromium/crPage.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/node_modules/playwright-core/src/server/chromium/crPage.ts	2025-03-19 15:32:33.834521885 +0000
@@ -1,3 +1,5 @@
+// undetected-undetected_playwright-patch - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -101,7 +103,8 @@
     this.updateOffline();
     this.updateExtraHTTPHeaders();
     this.updateHttpCredentials();
-    this.updateRequestInterception();
+    this._networkManager.setRequestInterception(true);
+    this.initScriptTag = "injected-playwright-init-script-" + crypto.randomBytes(20).toString('hex');
     this._mainFrameSession = new FrameSession(this, client, targetId, null);
     this._sessions.set(targetId, this._mainFrameSession);
     if (opener && !browserContext._options.noDefaultViewport) {
@@ -231,10 +234,11 @@
   }
 
   async addInitScript(initScript: InitScript, world: types.World = 'main'): Promise<void> {
+    this._page.initScripts.push(initScript);
     await this._forAllFrameSessions(frame => frame._evaluateOnNewDocument(initScript, world));
   }
 
-  async removeNonInternalInitScripts() {
+  async removeInitScripts() {
     await this._forAllFrameSessions(frame => frame._removeEvaluatesOnNewDocument());
   }
 
@@ -365,6 +369,15 @@
   shouldToggleStyleSheetToSyncAnimations(): boolean {
     return false;
   }
+
+  async exposeBinding(binding) {
+    await this._forAllFrameSessions(frame => frame._initBinding(binding));
+    await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(binding.source).catch(e => {})));
+  }
+
+  async removeExposedBindings() {
+    await this._forAllFrameSessions(frame => frame._removeExposedBindings());
+  }
 }
 
 class FrameSession {
@@ -479,19 +492,6 @@
           this._handleFrameTree(frameTree);
           this._addRendererListeners();
         }
-
-        const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)!];
-        for (const frame of localFrames) {
-          // Note: frames might be removed before we send these.
-          this._client._sendMayFail('Page.createIsolatedWorld', {
-            frameId: frame._id,
-            grantUniveralAccess: true,
-            worldName: UTILITY_WORLD_NAME,
-          });
-          for (const initScript of this._crPage._page.allInitScripts())
-            frame.evaluateExpression(initScript.source).catch(e => {});
-        }
-
         const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ':';
         if (isInitialEmptyPage) {
           // Ignore lifecycle events, worlds and bindings for the initial empty page. It is never the final page
@@ -501,14 +501,20 @@
             this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
           });
         } else {
+          const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)!];
+          for (const frame of localFrames) {
+            this._page._frameManager.frame(frame._id)._context("utility");
+            for (const binding of this._crPage._browserContext._pageBindings.values())
+              frame.evaluateExpression(binding.source).catch(e => {});
+            for (const source of this._crPage._browserContext.initScripts)
+              frame.evaluateExpression(source).catch(e => {});
+          }
           this._firstNonInitialNavigationCommittedFulfill();
           this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
         }
       }),
       this._client.send('Log.enable', {}),
       lifecycleEventsEnabled = this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-      this._client.send('Runtime.enable', {}),
-      this._client.send('Runtime.addBinding', { name: PageBinding.kPlaywrightBinding }),
       this._client.send('Page.addScriptToEvaluateOnNewDocument', {
         source: '',
         worldName: UTILITY_WORLD_NAME,
@@ -541,14 +547,16 @@
       promises.push(this._updateGeolocation(true));
       promises.push(this._updateEmulateMedia());
       promises.push(this._updateFileChooserInterception(true));
-      for (const initScript of this._crPage._page.allInitScripts())
-        promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+      for (const binding of this._crPage._page.allBindings()) promises.push(this._initBinding(binding));
+      for (const initScript of this._crPage._browserContext.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+      for (const initScript of this._crPage._page.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
       if (screencastOptions)
         promises.push(this._startVideoRecording(screencastOptions));
     }
-    promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
+    if (!(this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size)) promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
     promises.push(this._firstNonInitialNavigationCommittedPromise);
     await Promise.all(promises);
+    if (this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size) await this._client.send('Runtime.runIfWaitingForDebugger');
   }
 
   dispose() {
@@ -565,18 +573,30 @@
 
   async _navigate(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult> {
     const response = await this._client.send('Page.navigate', { url, referrer, frameId: frame._id, referrerPolicy: 'unsafeUrl' });
+    this._client._sendMayFail('Page.waitForDebugger');
     if (response.errorText)
       throw new frames.NavigationAbortedError(response.loaderId, `${response.errorText} at ${url}`);
     return { newDocumentId: response.loaderId };
   }
 
-  _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
+  async _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
     if (this._eventBelongsToStaleFrame(event.frameId))
       return;
     if (event.name === 'load')
       this._page._frameManager.frameLifecycleEvent(event.frameId, 'load');
     else if (event.name === 'DOMContentLoaded')
       this._page._frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded');
+    var document = await this._client._sendMayFail("DOM.getDocument");
+      if (!document) return
+      var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+        nodeId: document.root.nodeId,
+        selector: "[class=" + this._crPage.initScriptTag + "]"
+      });
+      if (!query) return
+      for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+      await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+      // ensuring execution context
+      try { await this._page._frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _handleFrameTree(frameTree: Protocol.Page.FrameTree) {
@@ -623,12 +643,23 @@
     this._page._frameManager.frameAttached(frameId, parentFrameId);
   }
 
-  _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
+  async _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
     if (this._eventBelongsToStaleFrame(framePayload.id))
       return;
     this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ''), framePayload.name || '', framePayload.loaderId, initial);
     if (!initial)
       this._firstNonInitialNavigationCommittedFulfill();
+    var document = await this._client._sendMayFail("DOM.getDocument");
+      if (!document) return
+      var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+        nodeId: document.root.nodeId,
+        selector: "[class=" + this._crPage.initScriptTag + "]"
+      });
+      if (!query) return
+      for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+      await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+      // ensuring execution context
+      try { await this._page._frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _onFrameRequestedNavigation(payload: Protocol.Page.frameRequestedNavigationPayload) {
@@ -665,19 +696,24 @@
   }
 
   _onExecutionContextCreated(contextPayload: Protocol.Runtime.ExecutionContextDescription) {
+    for (const name of this._exposedBindingNames) this._client._sendMayFail('Runtime.addBinding', { name: name, executionContextId: contextPayload.id });
     const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
+    if (contextPayload.auxData.type == "worker") throw new Error("ExecutionContext is worker");
     if (!frame || this._eventBelongsToStaleFrame(frame._id))
       return;
     const delegate = new CRExecutionContext(this._client, contextPayload);
-    let worldName: types.World|null = null;
-    if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
-      worldName = 'main';
-    else if (contextPayload.name === UTILITY_WORLD_NAME)
-      worldName = 'utility';
+    let worldName = contextPayload.name;
     const context = new dom.FrameExecutionContext(delegate, frame, worldName);
     if (worldName)
       frame._contextCreated(worldName, context);
     this._contextIdToContext.set(contextPayload.id, context);
+    for (const source of this._exposedBindingScripts) {
+      this._client._sendMayFail("Runtime.evaluate", {
+        expression: source,
+        contextId: contextPayload.id,
+        awaitPromise: true,
+      })
+    }
   }
 
   _onExecutionContextDestroyed(executionContextId: number) {
@@ -693,7 +729,7 @@
       this._onExecutionContextDestroyed(contextId);
   }
 
-  _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
+  async _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
     const session = this._client.createChildSession(event.sessionId);
 
     if (event.targetInfo.type === 'iframe') {
@@ -725,8 +761,17 @@
     session.once('Runtime.executionContextCreated', async event => {
       worker._createExecutionContext(new CRExecutionContext(session, event.context));
     });
+    var globalThis = await session._sendMayFail('Runtime.evaluate', {
+      expression: "globalThis",
+      serializationOptions: { serialization: "idOnly" }
+
+    });
+    if (globalThis && globalThis.result) {
+      var globalThisObjId = globalThis.result.objectId;
+      var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+      worker._createExecutionContext(new CRExecutionContext(session, { id: executionContextId }));
+    }
     // This might fail if the target is closed before we initialize.
-    session._sendMayFail('Runtime.enable');
     // TODO: attribute workers to the right frame.
     this._crPage._networkManager.addSession(session, this._page._frameManager.frame(this._targetId) ?? undefined).catch(() => {});
     session._sendMayFail('Runtime.runIfWaitingForDebugger');
@@ -805,8 +850,8 @@
     const pageOrError = await this._crPage._page.waitForInitializedOrError();
     if (!(pageOrError instanceof Error)) {
       const context = this._contextIdToContext.get(event.executionContextId);
-      if (context)
-        await this._page._onBindingCalled(event.payload, context);
+      if (context) await this._page._onBindingCalled(event.payload, context);
+      else await this._page._onBindingCalled(event.payload, (await this._page.mainFrame()._mainContext())) // This might be a bit sketchy but it works for now
     }
   }
 
@@ -1052,16 +1097,11 @@
   }
 
   async _evaluateOnNewDocument(initScript: InitScript, world: types.World): Promise<void> {
-    const worldName = world === 'utility' ? UTILITY_WORLD_NAME : undefined;
-    const { identifier } = await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source: initScript.source, worldName });
-    if (!initScript.internal)
-      this._evaluateOnNewDocumentIdentifiers.push(identifier);
+    this._evaluateOnNewDocumentScripts.push(initScript)
   }
 
   async _removeEvaluatesOnNewDocument(): Promise<void> {
-    const identifiers = this._evaluateOnNewDocumentIdentifiers;
-    this._evaluateOnNewDocumentIdentifiers = [];
-    await Promise.all(identifiers.map(identifier => this._client.send('Page.removeScriptToEvaluateOnNewDocument', { identifier })));
+    this._evaluateOnNewDocumentScripts = [];
   }
 
   async _getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null> {
@@ -1168,6 +1208,47 @@
       throw new Error(dom.kUnableToAdoptErrorMessage);
     return createHandle(to, result.object).asElement()!;
   }
+
+  _exposedBindingNames: string[] = [];
+  _evaluateOnNewDocumentScripts: string[] = [];
+  _parsedExecutionContextIds: number[] = [];
+  _exposedBindingScripts: string[] = [];
+
+  async _initBinding(binding = PageBinding) {
+    var result = await this._client._sendMayFail('Page.createIsolatedWorld', {
+      frameId: this._targetId, grantUniveralAccess: true, worldName: "utility"
+    });
+    if (!result) return
+    var isolatedContextId = result.executionContextId
+
+    var globalThis = await this._client._sendMayFail('Runtime.evaluate', {
+      expression: "globalThis",
+      serializationOptions: { serialization: "idOnly" }
+    });
+    if (!globalThis) return
+    var globalThisObjId = globalThis["result"]['objectId']
+    var mainContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+    await Promise.all([
+      this._client._sendMayFail('Runtime.addBinding', { name: binding.name }),
+      this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: mainContextId }),
+      this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: isolatedContextId }),
+      // this._client._sendMayFail("Runtime.evaluate", { expression: binding.source, contextId: mainContextId, awaitPromise: true })
+    ]);
+    this._exposedBindingNames.push(binding.name);
+    this._exposedBindingScripts.push(binding.source);
+    await this._crPage.addInitScript(binding.source);
+    //this._client._sendMayFail('Runtime.runIfWaitingForDebugger')
+  }
+
+  async _removeExposedBindings() {
+    const toRetain: string[] = [];
+    const toRemove: string[] = [];
+    for (const name of this._exposedBindingNames)
+      (name.startsWith('__pw_') ? toRetain : toRemove).push(name);
+    this._exposedBindingNames = toRetain;
+    await Promise.all(toRemove.map(name => this._client.send('Runtime.removeBinding', { name })));
+  }
 }
 
 async function emulateLocale(session: CRSession, locale: string) {
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/crServiceWorker.ts patchright/node_modules/playwright-core/src/server/chromium/crServiceWorker.ts
--- playwright/node_modules/playwright-core/src/server/chromium/crServiceWorker.ts	2025-03-19 15:32:27.008465606 +0000
+++ patchright/node_modules/playwright-core/src/server/chromium/crServiceWorker.ts	2025-03-19 15:32:33.834521885 +0000
@@ -44,8 +44,6 @@
       this.updateOffline();
       this._networkManager.addSession(session, undefined, true /* isMain */).catch(() => {});
     }
-
-    session.send('Runtime.enable', {}).catch(e => { });
     session.send('Runtime.runIfWaitingForDebugger').catch(e => { });
     session.on('Inspector.targetReloadedAfterCrash', () => {
       // Resume service worker after restart.
diff -ruN playwright/node_modules/playwright-core/src/server/clock.ts patchright/node_modules/playwright-core/src/server/clock.ts
--- playwright/node_modules/playwright-core/src/server/clock.ts	2025-03-19 15:32:27.008465606 +0000
+++ patchright/node_modules/playwright-core/src/server/clock.ts	2025-03-19 15:32:33.831521861 +0000
@@ -92,6 +92,14 @@
   }
 
   private async _evaluateInFrames(script: string) {
+    // Dont ask me why this works
+    await Promise.all(this._browserContext.pages().map(async page => {
+      await Promise.all(page.frames().map(async frame => {
+        try {
+          await frame.evaluateExpression("");
+        } catch (e) {}
+      }));
+    }));
     await this._browserContext.safeNonStallingEvaluateInAllFrames(script, 'main', { throwOnJSErrors: true });
   }
 }
diff -ruN playwright/node_modules/playwright-core/src/server/dispatchers/frameDispatcher.ts patchright/node_modules/playwright-core/src/server/dispatchers/frameDispatcher.ts
--- playwright/node_modules/playwright-core/src/server/dispatchers/frameDispatcher.ts	2025-03-19 15:32:27.009465614 +0000
+++ patchright/node_modules/playwright-core/src/server/dispatchers/frameDispatcher.ts	2025-03-19 15:32:33.834521885 +0000
@@ -84,11 +84,15 @@
   }
 
   async evaluateExpression(params: channels.FrameEvaluateExpressionParams, metadata: CallMetadata): Promise<channels.FrameEvaluateExpressionResult> {
-    return { value: serializeResult(await this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg))) };
+    return { value: serializeResult(await this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction,
+      world: params.isolatedContext ? 'utility': 'main'
+    }, parseArgument(params.arg))) };
   }
 
   async evaluateExpressionHandle(params: channels.FrameEvaluateExpressionHandleParams, metadata: CallMetadata): Promise<channels.FrameEvaluateExpressionHandleResult> {
-    return { handle: ElementHandleDispatcher.fromJSHandle(this, await this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg))) };
+    return { handle: ElementHandleDispatcher.fromJSHandle(this, await this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction,
+      world: params.isolatedContext ? 'utility': 'main'
+    }, parseArgument(params.arg))) };
   }
 
   async waitForSelector(params: channels.FrameWaitForSelectorParams, metadata: CallMetadata): Promise<channels.FrameWaitForSelectorResult> {
diff -ruN playwright/node_modules/playwright-core/src/server/dispatchers/jsHandleDispatcher.ts patchright/node_modules/playwright-core/src/server/dispatchers/jsHandleDispatcher.ts
--- playwright/node_modules/playwright-core/src/server/dispatchers/jsHandleDispatcher.ts	2025-03-19 15:32:27.009465614 +0000
+++ patchright/node_modules/playwright-core/src/server/dispatchers/jsHandleDispatcher.ts	2025-03-19 15:32:33.834521885 +0000
@@ -39,11 +39,11 @@
   }
 
   async evaluateExpression(params: channels.JSHandleEvaluateExpressionParams): Promise<channels.JSHandleEvaluateExpressionResult> {
-    return { value: serializeResult(await this._object.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg))) };
+    return { value: serializeResult(await this._object.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg), params.isolatedContext)) };
   }
 
   async evaluateExpressionHandle(params: channels.JSHandleEvaluateExpressionHandleParams): Promise<channels.JSHandleEvaluateExpressionHandleResult> {
-    const jsHandle = await this._object.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg));
+    const jsHandle = await this._object.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg), params.isolatedContext);
     return { handle: ElementHandleDispatcher.fromJSHandle(this.parentScope(), jsHandle) };
   }
 
diff -ruN playwright/node_modules/playwright-core/src/server/dispatchers/pageDispatcher.ts patchright/node_modules/playwright-core/src/server/dispatchers/pageDispatcher.ts
--- playwright/node_modules/playwright-core/src/server/dispatchers/pageDispatcher.ts	2025-03-19 15:32:27.009465614 +0000
+++ patchright/node_modules/playwright-core/src/server/dispatchers/pageDispatcher.ts	2025-03-19 15:32:33.834521885 +0000
@@ -353,11 +353,11 @@
   }
 
   async evaluateExpression(params: channels.WorkerEvaluateExpressionParams, metadata: CallMetadata): Promise<channels.WorkerEvaluateExpressionResult> {
-    return { value: serializeResult(await this._object.evaluateExpression(params.expression, params.isFunction, parseArgument(params.arg))) };
+    return { value: serializeResult(await this._object.evaluateExpression(params.expression, params.isFunction, parseArgument(params.arg), params.isolatedContext)) };
   }
 
   async evaluateExpressionHandle(params: channels.WorkerEvaluateExpressionHandleParams, metadata: CallMetadata): Promise<channels.WorkerEvaluateExpressionHandleResult> {
-    return { handle: ElementHandleDispatcher.fromJSHandle(this, await this._object.evaluateExpressionHandle(params.expression, params.isFunction, parseArgument(params.arg))) };
+    return { handle: ElementHandleDispatcher.fromJSHandle(this, await this._object.evaluateExpressionHandle(params.expression, params.isFunction, parseArgument(params.arg), params.isolatedContext)) };
   }
 }
 
diff -ruN playwright/node_modules/playwright-core/src/server/firefox/ffPage.ts patchright/node_modules/playwright-core/src/server/firefox/ffPage.ts
--- playwright/node_modules/playwright-core/src/server/firefox/ffPage.ts	2025-03-19 15:32:27.010465623 +0000
+++ patchright/node_modules/playwright-core/src/server/firefox/ffPage.ts	2025-03-19 15:32:33.834521885 +0000
@@ -390,7 +390,7 @@
     await this._session.send('Page.setInitScripts', { scripts: this._initScripts.map(s => ({ script: s.initScript.source, worldName: s.worldName })) });
   }
 
-  async removeNonInternalInitScripts() {
+  async removeInitScripts() {
     this._initScripts = this._initScripts.filter(s => s.initScript.internal);
     await this._session.send('Page.setInitScripts', { scripts: this._initScripts.map(s => ({ script: s.initScript.source, worldName: s.worldName })) });
   }
diff -ruN playwright/node_modules/playwright-core/src/server/frames.ts patchright/node_modules/playwright-core/src/server/frames.ts
--- playwright/node_modules/playwright-core/src/server/frames.ts	2025-03-19 15:32:27.011465632 +0000
+++ patchright/node_modules/playwright-core/src/server/frames.ts	2025-03-19 15:32:33.832521869 +0000
@@ -1,3 +1,7 @@
+// undetected-undetected_playwright-patch - custom imports
+import { CRExecutionContext } from './chromium/crExecutionContext';
+import { FrameExecutionContext } from './dom';
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -530,6 +534,9 @@
   }
 
   _onClearLifecycle() {
+    this._isolatedWorld = undefined;
+    this._mainWorld = undefined;
+    this._iframeWorld = undefined;
     for (const event of this._firedLifecycleEvents)
       this.emit(Frame.Events.RemoveLifecycle, event);
     this._firedLifecycleEvents.clear();
@@ -743,12 +750,68 @@
     return this._page._delegate.getFrameElement(this);
   }
 
-  _context(world: types.World): Promise<dom.FrameExecutionContext> {
-    return this._contextData.get(world)!.contextPromise.then(contextOrDestroyedReason => {
-      if (contextOrDestroyedReason instanceof js.ExecutionContext)
-        return contextOrDestroyedReason;
-      throw new Error(contextOrDestroyedReason.destroyedReason);
-    });
+  async _context(world: types.World): Promise<dom.FrameExecutionContext> {
+    /* await this._page._delegate._mainFrameSession._client._sendMayFail('DOM.enable');
+        var globalDoc = await this._page._delegate._mainFrameSession._client._sendMayFail('DOM.getFrameOwner', { frameId: this._id });
+        if (globalDoc) {
+          await this._page._delegate._mainFrameSession._client._sendMayFail("DOM.resolveNode", { nodeId: globalDoc.nodeId })
+        } */
+
+        // if (this.isDetached()) throw new Error('Frame was detached');
+        try {
+          var client = this._page._delegate._sessionForFrame(this)._client
+        } catch (e) { var client = this._page._delegate._mainFrameSession._client }
+        var iframeExecutionContextId = await this._getFrameMainFrameContextId(client)
+
+        if (world == "main") {
+          // Iframe Only
+          if (this != this._page.mainFrame() && iframeExecutionContextId && this._iframeWorld == undefined) {
+            var executionContextId = iframeExecutionContextId
+            var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+            this._iframeWorld = new FrameExecutionContext(crContext, this, world)
+            this._page._delegate._mainFrameSession._onExecutionContextCreated({
+              id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+            })
+          } else if (this._mainWorld == undefined) {
+            var globalThis = await client._sendMayFail('Runtime.evaluate', {
+              expression: "globalThis",
+              serializationOptions: { serialization: "idOnly" }
+            });
+            if (!globalThis) { return }
+            var globalThisObjId = globalThis["result"]['objectId']
+            var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+            var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+            this._mainWorld = new FrameExecutionContext(crContext, this, world)
+            this._page._delegate._mainFrameSession._onExecutionContextCreated({
+              id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+            })
+          }
+        }
+        if (world != "main" && this._isolatedWorld == undefined) {
+          world = "utility"
+          var result = await client._sendMayFail('Page.createIsolatedWorld', {
+            frameId: this._id, grantUniveralAccess: true, worldName: world
+          });
+          if (!result) {
+            // if (this.isDetached()) throw new Error("Frame was detached");
+            return
+          }
+          var executionContextId = result.executionContextId
+          var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+          this._isolatedWorld = new FrameExecutionContext(crContext, this, world)
+          this._page._delegate._mainFrameSession._onExecutionContextCreated({
+            id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+          })
+        }
+
+        if (world != "main") {
+          return this._isolatedWorld;
+        } else if (this != this._page.mainFrame() && iframeExecutionContextId) {
+          return this._iframeWorld;
+        } else {
+          return this._mainWorld;
+        }
   }
 
   _mainContext(): Promise<dom.FrameExecutionContext> {
@@ -796,58 +859,49 @@
   }
 
   async waitForSelectorInternal(progress: Progress, selector: string, performActionPreChecks: boolean, options: types.WaitForElementOptions, scope?: dom.ElementHandle): Promise<dom.ElementHandle<Element> | null> {
-    const { state = 'visible' } = options;
-    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecks)
-        await this._page.performActionPreChecks(progress);
-
-      const resolved = await this.selectors.resolveInjectedForSelector(selector, options, scope);
-      progress.throwIfAborted();
-      if (!resolved) {
-        if (state === 'hidden' || state === 'detached')
-          return null;
-        return continuePolling;
-      }
-      const result = await resolved.injected.evaluateHandle((injected, { info, root }) => {
-        if (root && !root.isConnected)
-          throw injected.createStacklessError('Element is not attached to the DOM');
-        const elements = injected.querySelectorAll(info.parsed, root || document);
-        const element: Element | undefined  = elements[0];
-        const visible = element ? injected.utils.isElementVisible(element) : false;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
-            throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewNode(element)}`;
+    const {
+      state = 'visible'
+    } = options;
+    const promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, true, async handle => {
+      const attached = !!handle;
+      var visible = false;
+      if (attached) {
+        if (handle.parentNode.constructor.name == "ElementHandle") {
+          visible = await handle.parentNode.evaluateInUtility(([injected, node, { handle }]) => {
+            return handle ? injected.utils.isElementVisible(handle) : false;
+          }, {
+            handle
+          });
+        } else {
+          visible = await handle.parentNode.evaluate((injected, { handle }) => {
+            return handle ? injected.utils.isElementVisible(handle) : false;
+          }, {
+            handle
+          });
         }
-        return { log, element, visible, attached: !!element };
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined });
-      const { log, visible, attached } = await result.evaluate(r => ({ log: r.log, visible: r.visible, attached: r.attached }));
-      if (log)
-        progress.log(log);
-      const success = { attached, detached: !attached, visible, hidden: !visible }[state];
+      }
+
+      const success = {
+        attached,
+        detached: !attached,
+        visible,
+        hidden: !visible
+      }[state];
       if (!success) {
-        result.dispose();
-        return continuePolling;
+        return "internal:continuepolling";
       }
       if (options.omitReturnValue) {
-        result.dispose();
         return null;
       }
-      const element = state === 'attached' || state === 'visible' ? await result.evaluateHandle(r => r.element) : null;
-      result.dispose();
-      if (!element)
-        return null;
-      if ((options as any).__testHookBeforeAdoptNode)
-        await (options as any).__testHookBeforeAdoptNode();
+      const element = state === 'attached' || state === 'visible' ? handle : null;
+      if (!element) return null;
+      if (options.__testHookBeforeAdoptNode) await options.__testHookBeforeAdoptNode();
       try {
-        return await element._adoptTo(await resolved.frame._mainContext());
+        return element;
       } catch (e) {
-        return continuePolling;
+        return "internal:continuepolling";
       }
-    });
+    }, 'returnOnNotResolved');
     return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
   }
 
@@ -908,31 +962,38 @@
   }
 
   async setContent(metadata: CallMetadata, html: string, options: types.NavigateOptions = {}): Promise<void> {
-    const controller = new ProgressController(metadata, this);
-    return controller.run(async progress => {
-      await this.raceNavigationAction(progress, options, async () => {
-        const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;
-        progress.log(`setting frame content, waiting until "${waitUntil}"`);
-        const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
-        const context = await this._utilityContext();
-        const lifecyclePromise = new Promise((resolve, reject) => {
-          this._page._frameManager._consoleMessageTags.set(tag, () => {
-            // Clear lifecycle right after document.open() - see 'tag' below.
-            this._onClearLifecycle();
-            this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
+      const controller = new ProgressController(metadata, this);
+      return controller.run(async progress => {
+        await this.raceNavigationAction(progress, options, async () => {
+          const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;
+          progress.log(`setting frame content, waiting until "${waitUntil}"`);
+          const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
+          const bindingName = "_tagDebug" + crypto.randomBytes(20).toString('hex');
+          const context = await this._utilityContext();
+          await this._page._delegate._mainFrameSession._client.send('Runtime.addBinding', { name: bindingName });
+          const lifecyclePromise = new Promise(async (resolve, reject) => {
+            await this._page.exposeBinding(bindingName, false, (tag) => {
+              this._onClearLifecycle();
+              this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
+            });
           });
+          const contentPromise = context.evaluate(({ html, tag, bindingName }) => {
+            document.open();
+            var _tagDebug = window[bindingName].bind({});
+            delete window[bindingName]
+            _tagDebug('{ "name": "' + bindingName + '", "seq": 1, "serializedArgs": ["' + tag + '"] }');
+            console.debug(tag);  // eslint-disable-line no-console
+            document.write(html);
+            document.close();
+          }, { html, tag,
+            bindingName
+          });
+          await Promise.all([contentPromise, lifecyclePromise]);
+          return null;
         });
-        const contentPromise = context.evaluate(({ html, tag }) => {
-          document.open();
-          console.debug(tag);  // eslint-disable-line no-console
-          document.write(html);
-          document.close();
-        }, { html, tag });
-        await Promise.all([contentPromise, lifecyclePromise]);
-        return null;
-      });
-    }, this._page._timeoutSettings.navigationTimeout(options));
-  }
+      }, this._page._timeoutSettings.navigationTimeout(options));
+    }
+
 
   name(): string {
     return this._name || '';
@@ -1125,50 +1186,74 @@
     selector: string,
     strict: boolean | undefined,
     performActionPreChecks: boolean,
-    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>): Promise<R> {
-    progress.log(`waiting for ${this._asLocator(selector)}`);
+    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>, returnAction: boolean | undefined): Promise<R> {
+    progress.log("waiting for " + this._asLocator(selector));
     return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecks)
-        await this._page.performActionPreChecks(progress);
-
-      const resolved = await this.selectors.resolveInjectedForSelector(selector, { strict });
+      if (performActionPreChecks) await this._page.performActionPreChecks(progress);
+      const resolved = await this.selectors.resolveInjectedForSelector(selector, {
+        strict
+      });
       progress.throwIfAborted();
-      if (!resolved)
+      if (!resolved) {
+        if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') return null;
         return continuePolling;
-      const result = await resolved.injected.evaluateHandle((injected, { info, callId }) => {
-        const elements = injected.querySelectorAll(info.parsed, document);
-        if (callId)
-          injected.markTargetElements(new Set(elements), callId);
-        const element = elements[0] as Element | undefined;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
+      }
+
+      try {
+        var client = this._page._delegate._sessionForFrame(resolved.frame)._client;
+      } catch (e) {
+        var client = this._page._delegate._mainFrameSession._client;
+      }
+      var context = await resolved.frame._context("main");
+
+      const documentNode = await client.send('Runtime.evaluate', {
+        expression: "document",
+        serializationOptions: {
+          serialization: "idOnly"
+        },
+        contextId: context.delegate._contextId,
+      });
+      const documentScope = new dom.ElementHandle(context, documentNode.result.objectId);
+
+      const currentScopingElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, resolved.info.parsed);
+      if (currentScopingElements.length == 0) {
+        // TODO: Dispose?
+        if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') return null;
+        return continuePolling;
+      }
+      const resultElement = currentScopingElements[0];
+      if (currentScopingElements.length > 1) {
+        if (resolved.info.strict) {
+          await resolved.injected.evaluateHandle((injected, {
+            info,
+            elements
+          }) => {
             throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${injected.previewNode(element)}`;
+          }, {
+            info: resolved.info,
+            elements: currentScopingElements
+          });
         }
-        return { log, success: !!element, element };
-      }, { info: resolved.info, callId: progress.metadata.id });
-      const { log, success } = await result.evaluate(r => ({ log: r.log, success: r.success }));
-      if (log)
-        progress.log(log);
-      if (!success) {
-        result.dispose();
-        return continuePolling;
+        progress.log("  locator resolved to " + currentScopingElements.length + " elements. Proceeding with the first one: " + resultElement.preview());
+      } else if (resultElement) {
+        progress.log("  locator resolved to " + resultElement.preview());
       }
-      const element = await result.evaluateHandle(r => r.element) as dom.ElementHandle<Element>;
-      result.dispose();
+
       try {
-        const result = await action(element);
+        var result = null;
+        if (returnAction === 'returnAll') {
+          result = await action([resultElement, currentScopingElements]);
+        } else {
+          result = await action(resultElement);
+        }
         if (result === 'error:notconnected') {
           progress.log('element was detached from the DOM, retrying');
           return continuePolling;
+        } else if (result === 'internal:continuepolling') {
+          return continuePolling;
         }
         return result;
-      } finally {
-        element?.dispose();
-      }
+      } finally { }
     });
   }
 
@@ -1319,17 +1404,34 @@
 
   async isVisibleInternal(selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {
     try {
-      const resolved = await this.selectors.resolveInjectedForSelector(selector, options, scope);
-      if (!resolved)
-        return false;
-      return await resolved.injected.evaluate((injected, { info, root }) => {
-        const element = injected.querySelector(info.parsed, root || document, info.strict);
-        const state = element ? injected.elementState(element, 'visible') : { matches: false, received: 'error:notconnected' };
-        return state.matches;
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined });
+      const custom_metadata = { "internal": false, "log": [] };
+      const controller = new ProgressController(custom_metadata, this);
+      return await controller.run(async progress => {
+        progress.log("waiting for " + this._asLocator(selector));
+        const promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, false, async handle => {
+          if (handle.parentNode.constructor.name == "ElementHandle") {
+            return await handle.parentNode.evaluateInUtility(([injected, node, { handle }]) => {
+              const state = handle ? injected.elementState(handle, 'visible') : {
+                matches: false,
+                received: 'error:notconnected'
+              };
+              return state.matches;
+            }, { handle });
+          } else {
+            return await handle.parentNode.evaluate((injected, { handle }) => {
+              const state = handle ? injected.elementState(handle, 'visible') : {
+                matches: false,
+                received: 'error:notconnected'
+              };
+              return state.matches;
+            }, { handle });
+          }
+        });
+
+        return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+      }, 100); // A bit geeky but its okay :D
     } catch (e) {
-      if (js.isJavaScriptErrorInEvaluate(e) || isInvalidSelectorError(e) || isSessionClosedError(e))
-        throw e;
+      if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorParser.isInvalidSelectorError)(e) || (0, _protocolError.isSessionClosedError)(e)) throw e;
       return false;
     }
   }
@@ -1489,40 +1591,46 @@
   }
 
   private async _expectInternal(progress: Progress, selector: string, options: FrameExpectParams, lastIntermediateResult: { received?: any, isSet: boolean }) {
-    const selectorInFrame = await this.selectors.resolveFrameForSelector(selector, { strict: true });
-    progress.throwIfAborted();
+    progress.log("waiting for " + this._asLocator(selector));
+    const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
 
-    const { frame, info } = selectorInFrame || { frame: this, info: undefined };
-    const world = options.expression === 'to.have.property' ? 'main' : (info?.world ?? 'utility');
-    const context = await frame._context(world);
-    const injected = await context.injectedScript();
-    progress.throwIfAborted();
+    const promise = await this._retryWithProgressIfNotConnected(progress, selector, !isArray, false, async result => {
+      const handle = result[0];
+      const handles = result[1];
+
+      if (handle.parentNode.constructor.name == "ElementHandle") {
+        return await handle.parentNode.evaluateInUtility(async ([injected, node, { handle, options, handles }]) => {
+          return await injected.expect(handle, options, handles);
+        }, { handle, options, handles });
+      } else {
+        return await handle.parentNode.evaluate(async (injected, { handle, options, handles }) => {
+          return await injected.expect(handle, options, handles);
+        }, { handle, options, handles });
+      }
+    }, 'returnAll');
 
-    const { log, matches, received, missingReceived } = await injected.evaluate(async (injected, { info, options, callId }) => {
-      const elements = info ? injected.querySelectorAll(info.parsed, document) : [];
-      if (callId)
-        injected.markTargetElements(new Set(elements), callId);
-      const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
-      let log = '';
-      if (isArray)
-        log = `  locator resolved to ${elements.length} element${elements.length === 1 ? '' : 's'}`;
-      else if (elements.length > 1)
-        throw injected.strictModeViolationError(info!.parsed, elements);
-      else if (elements.length)
-        log = `  locator resolved to ${injected.previewNode(elements[0])}`;
-      return { log, ...await injected.expect(elements[0], options, elements) };
-    }, { info, options, callId: progress.metadata.id });
-
-    if (log)
-      progress.log(log);
-    // Note: missingReceived avoids `unexpected value "undefined"` when element was not found.
+    // Default Values, if no Elements found
+    var matches = false;
+    var received = 0;
+    var missingReceived = null;
+    if (promise) {
+      matches = promise.matches;
+      received = promise.received;
+      missingReceived = promise.missingReceived;
+    } else if (options.expectedNumber === 0) {
+      matches = true;
+    }
+
+    // Note: missingReceived avoids unexpected value "undefined" when element was not found.
     if (matches === options.isNot) {
       lastIntermediateResult.received = missingReceived ? '<element(s) not found>' : received;
       lastIntermediateResult.isSet = true;
-      if (!missingReceived && !Array.isArray(received))
-        progress.log(`  unexpected value "${renderUnexpectedValue(options.expression, received)}"`);
+      if (!missingReceived && !Array.isArray(received)) progress.log('  unexpected value "' + renderUnexpectedValue(options.expression, received) + '"');
     }
-    return { matches, received };
+    return {
+      matches,
+      received
+    };
   }
 
   async _waitForFunctionExpression<R>(metadata: CallMetadata, expression: string, isFunction: boolean | undefined, arg: any, options: types.WaitForFunctionOptions, world: types.World = 'main'): Promise<js.SmartHandle<R>> {
@@ -1632,28 +1740,27 @@
     const callbackText = body.toString();
     const controller = new ProgressController(metadata, this);
     return controller.run(async progress => {
-      progress.log(`waiting for ${this._asLocator(selector)}`);
-      const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-        const resolved = await this.selectors.resolveInjectedForSelector(selector, options, scope);
-        progress.throwIfAborted();
-        if (!resolved)
-          return continuePolling;
-        const { log, success, value } = await resolved.injected.evaluate((injected, { info, callbackText, taskData, callId, root }) => {
-          const callback = injected.eval(callbackText) as ElementCallback<T, R>;
-          const element = injected.querySelector(info.parsed, root || document, info.strict);
-          if (!element)
-            return { success: false };
-          const log = `  locator resolved to ${injected.previewNode(element)}`;
-          if (callId)
-            injected.markTargetElements(new Set([element]), callId);
-          return { log, success: true, value: callback(injected, element, taskData as T) };
-        }, { info: resolved.info, callbackText, taskData, callId: progress.metadata.id, root: resolved.frame === this ? scope : undefined });
-
-        if (log)
-          progress.log(log);
-        if (!success)
-          return continuePolling;
-        return value!;
+      progress.log("waiting for "+ this._asLocator(selector));
+      const promise = this._retryWithProgressIfNotConnected(progress, selector, false, false, async handle => {
+        if (handle.parentNode.constructor.name == "ElementHandle") {
+          return await handle.parentNode.evaluateInUtility(([injected, node, { callbackText, handle, taskData }]) => {
+            const callback = injected.eval(callbackText);
+            return callback(injected, handle, taskData);
+          }, {
+            callbackText,
+            handle,
+            taskData
+          });
+        } else {
+          return await handle.parentNode.evaluate((injected, { callbackText, handle, taskData }) => {
+            const callback = injected.eval(callbackText);
+            return callback(injected, handle, taskData);
+          }, {
+            callbackText,
+            handle,
+            taskData
+          });
+        }
       });
       return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
     }, this._page._timeoutSettings.timeout(options));
@@ -1757,6 +1864,169 @@
   private _asLocator(selector: string) {
     return asLocator(this._page.attribution.playwright.options.sdkLanguage, selector);
   }
+
+  _isolatedWorld: dom.FrameExecutionContext;
+  _mainWorld: dom.FrameExecutionContext;
+  _iframeWorld: dom.FrameExecutionContext;
+
+  async _getFrameMainFrameContextId(client): Promise<number> {
+    try {
+        var globalDocument = await client._sendMayFail("DOM.getFrameOwner", {frameId: this._id,});
+        if (globalDocument && globalDocument.nodeId) {
+          var describedNode = await client._sendMayFail("DOM.describeNode", {
+            backendNodeId: globalDocument.backendNodeId,
+          });
+          if (describedNode) {
+            var resolvedNode = await client._sendMayFail("DOM.resolveNode", {
+              nodeId: describedNode.node.contentDocument.nodeId,
+            });
+            var _executionContextId = parseInt(resolvedNode.object.objectId.split(".")[1], 10);
+            return _executionContextId;
+            }
+          }
+        } catch (e) {}
+        return 0;
+  }
+
+  async _customFindElementsByParsed(resolved, client, context, documentScope, progress, parsed) {
+    var parsedEdits = { ...parsed };
+    // Note: We start scoping at document level
+    var currentScopingElements = [documentScope];
+    while (parsed.parts.length > 0) {
+      var part = parsed.parts.shift();
+      parsedEdits.parts = [part];
+      var isUsingXPath = false;
+      // Getting All Elements
+      var elements = [];
+      var elementsIndexes = [];
+
+      if (part.name == "xpath") {
+        isUsingXPath = true;
+      } else if (part.name == "nth") {
+        const partNth = Number(part.body);
+        if (partNth > currentScopingElements.length || partNth < -currentScopingElements.length) {
+          return continuePolling;
+        } else {
+          currentScopingElements = [currentScopingElements.at(partNth)];
+          continue;
+        }
+      } else if (part.name == "internal:or") {
+        var orredElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+        elements = currentScopingElements.concat(orredElements);
+      } else if (part.name == "internal:and") {
+        var andedElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+        const backendNodeIds = new Set(andedElements.map(item => item.backendNodeId));
+        elements = currentScopingElements.filter(item => backendNodeIds.has(item.backendNodeId));
+      } else {
+        for (const scope of currentScopingElements) {
+          const describedScope = await client.send('DOM.describeNode', {
+            objectId: scope._objectId,
+            depth: -1,
+            pierce: true
+          });
+
+          // Elements Queryed in the "current round"
+          var queryingElements = [];
+
+          if (!isUsingXPath) {
+            function findClosedShadowRoots(node, results = []) {
+              if (!node || typeof node !== 'object') return results;
+              if (node.shadowRoots && Array.isArray(node.shadowRoots)) {
+                for (const shadowRoot of node.shadowRoots) {
+                  if (shadowRoot.shadowRootType === 'closed' && shadowRoot.backendNodeId) {
+                    results.push(shadowRoot.backendNodeId);
+                  }
+                  findClosedShadowRoots(shadowRoot, results);
+                }
+              }
+              if (node.nodeName !== 'IFRAME' && node.children && Array.isArray(node.children)) {
+                for (const child of node.children) {
+                  findClosedShadowRoots(child, results);
+                }
+              }
+              return results;
+            }
+
+            var shadowRootBackendIds = findClosedShadowRoots(describedScope.node);
+            var shadowRoots = [];
+            for (var shadowRootBackendId of shadowRootBackendIds) {
+              var resolvedShadowRoot = await client.send('DOM.resolveNode', {
+                backendNodeId: shadowRootBackendId,
+                contextId: context.delegate._contextId
+              });
+              shadowRoots.push(new dom.ElementHandle(context, resolvedShadowRoot.object.objectId));
+            }
+
+            for (var shadowRoot of shadowRoots) {
+              const shadowElements = await shadowRoot.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+                const elements = injected.querySelectorAll(parsed, node);
+                if (callId) injected.markTargetElements(new Set(elements), callId);
+                return elements
+              }, {
+                parsed: parsedEdits,
+                callId: progress.metadata.id
+              });
+
+              const shadowElementsAmount = await shadowElements.getProperty("length");
+              queryingElements.push([shadowElements, shadowElementsAmount, shadowRoot]);
+            }
+          }
+
+          // Document Root Elements (not in CSR)
+          const rootElements = await scope.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+            const elements = injected.querySelectorAll(parsed, node);
+            if (callId) injected.markTargetElements(new Set(elements), callId);
+            return elements
+          }, {
+            parsed: parsedEdits,
+            callId: progress.metadata.id
+          });
+          const rootElementsAmount = await rootElements.getProperty("length");
+          queryingElements.push([rootElements, rootElementsAmount, resolved.injected]);
+
+          // Querying and Sorting the elements by their backendNodeId
+          for (var queryedElement of queryingElements) {
+            var elementsToCheck = queryedElement[0];
+            var elementsAmount = await queryedElement[1].jsonValue();
+            var parentNode = queryedElement[2];
+            for (var i = 0; i < elementsAmount; i++) {
+              if (parentNode.constructor.name == "ElementHandle") {
+                var elementToCheck = await parentNode.evaluateHandleInUtility(([injected, node, { index, elementsToCheck }]) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+              } else {
+                var elementToCheck = await parentNode.evaluateHandle((injected, { index, elementsToCheck }) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+              }
+              // For other Functions/Utilities
+              elementToCheck.parentNode = parentNode;
+              var resolvedElement = await client.send('DOM.describeNode', {
+                objectId: elementToCheck._objectId,
+                depth: -1,
+              });
+              // Note: Possible Bug, Maybe well actually have to check the Documents Node Position instead of using the backendNodeId
+              elementToCheck.backendNodeId = resolvedElement.node.backendNodeId;
+              elements.push(elementToCheck);
+            }
+          }
+        }
+      }
+      // Setting currentScopingElements to the elements we just queried
+      currentScopingElements = [];
+      for (var element of elements) {
+        var elemIndex = element.backendNodeId;
+        // Sorting the Elements by their occourance in the DOM
+        var elemPos = elementsIndexes.findIndex(index => index > elemIndex);
+
+        // Sort the elements by their backendNodeId
+        if (elemPos === -1) {
+          currentScopingElements.push(element);
+          elementsIndexes.push(elemIndex);
+        } else {
+          currentScopingElements.splice(elemPos, 0, element);
+          elementsIndexes.splice(elemPos, 0, elemIndex);
+        }
+      }
+    }
+    return currentScopingElements;
+  }
 }
 
 class SignalBarrier {
diff -ruN playwright/node_modules/playwright-core/src/server/javascript.ts patchright/node_modules/playwright-core/src/server/javascript.ts
--- playwright/node_modules/playwright-core/src/server/javascript.ts	2025-03-19 15:32:27.012465640 +0000
+++ patchright/node_modules/playwright-core/src/server/javascript.ts	2025-03-19 15:32:33.832521869 +0000
@@ -149,17 +149,33 @@
     return evaluate(this._context, false /* returnByValue */, pageFunction, this, arg);
   }
 
-  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any) {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: true }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean) {
+    let context = this._context;
+      if (context.constructor.name === "FrameExecutionContext") {
+          const frame = context.frame;
+          if (frame) {
+              if (isolatedContext) context = await frame._utilityContext();
+              else if (!isolatedContext) context = await frame._mainContext();
+          }
+      }
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: true }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
 
-  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any): Promise<JSHandle<any>> {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: false }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean): Promise<JSHandle<any>> {
+    let context = this._context;
+      if (this._context.constructor.name === "FrameExecutionContext") {
+          const frame = this._context.frame;
+          if (frame) {
+              if (isolatedContext) context = await frame._utilityContext();
+              else if (!isolatedContext) context = await frame._mainContext();
+          }
+      }
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: false }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
 
   async getProperty(propertyName: string): Promise<JSHandle> {
     const objectHandle = await this.evaluateHandle((object: any, propertyName) => {
diff -ruN playwright/node_modules/playwright-core/src/server/page.ts patchright/node_modules/playwright-core/src/server/page.ts
--- playwright/node_modules/playwright-core/src/server/page.ts	2025-03-19 15:32:27.013465649 +0000
+++ patchright/node_modules/playwright-core/src/server/page.ts	2025-03-19 15:32:33.832521869 +0000
@@ -60,7 +60,7 @@
   goForward(): Promise<boolean>;
   requestGC(): Promise<void>;
   addInitScript(initScript: InitScript): Promise<void>;
-  removeNonInternalInitScripts(): Promise<void>;
+  removeInitScripts(): Promise<void>;
   closePage(runBeforeUnload: boolean): Promise<void>;
 
   navigateFrame(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult>;
@@ -351,15 +351,15 @@
       throw new Error(`Function "${name}" has been already registered in the browser context`);
     const binding = new PageBinding(name, playwrightBinding, needsHandle);
     this._pageBindings.set(name, binding);
-    await this._delegate.addInitScript(binding.initScript);
-    await Promise.all(this.frames().map(frame => frame.evaluateExpression(binding.initScript.source).catch(e => {})));
+    await this._delegate.exposeBinding(binding);
   }
 
   async _removeExposedBindings() {
-    for (const [key, binding] of this._pageBindings) {
-      if (!binding.internal)
+    for (const key of this._pageBindings.keys()) {
+      if (!key.startsWith('__pw'))
         this._pageBindings.delete(key);
     }
+    await this._delegate.removeExposedBindings();
   }
 
   setExtraHTTPHeaders(headers: types.HeadersArray) {
@@ -576,8 +576,8 @@
   }
 
   async _removeInitScripts() {
-    this.initScripts = this.initScripts.filter(script => script.internal);
-    await this._delegate.removeNonInternalInitScripts();
+    this.initScripts.splice(0, this.initScripts.length);
+    await this._delegate.removeInitScripts();
   }
 
   needsRequestInterception(): boolean {
@@ -769,11 +769,6 @@
       this._browserContext.addVisitedOrigin(origin);
   }
 
-  allInitScripts() {
-    const bindings = [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
-    return [...bindings.map(binding => binding.initScript), ...this._browserContext.initScripts, ...this.initScripts];
-  }
-
   getBinding(name: string) {
     return this._pageBindings.get(name) || this._browserContext._pageBindings.get(name);
   }
@@ -810,6 +805,10 @@
   markAsServerSideOnly() {
     this._isServerSideOnly = true;
   }
+
+  allBindings() {
+    return [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
+  }
 }
 
 export class Worker extends SdkObject {
@@ -847,13 +846,29 @@
     this.openScope.close(new Error('Worker closed'));
   }
 
-  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: true, isFunction }, arg);
-  }
+  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
+    let context = await this._executionContextPromise;
+      if (context.constructor.name === "FrameExecutionContext") {
+          const frame = context.frame;
+          if (frame) {
+              if (isolatedContext) context = await frame._utilityContext();
+              else if (!isolatedContext) context = await frame._mainContext();
+          }
+      }
+      return js.evaluateExpression(context, expression, { returnByValue: true, isFunction }, arg);
+    }
 
-  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: false, isFunction }, arg);
-  }
+  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
+    let context = await this._executionContextPromise;
+      if (this._context.constructor.name === "FrameExecutionContext") {
+          const frame = this._context.frame;
+          if (frame) {
+              if (isolatedContext) context = await frame._utilityContext();
+              else if (!isolatedContext) context = await frame._mainContext();
+          }
+      }
+      return js.evaluateExpression(context, expression, { returnByValue: false, isFunction }, arg);
+    }
 }
 
 type BindingPayload = {
@@ -863,20 +878,16 @@
 };
 
 export class PageBinding {
-  static kPlaywrightBinding = '__playwright__binding__';
-
   readonly name: string;
   readonly playwrightFunction: frames.FunctionWithSource;
-  readonly initScript: InitScript;
   readonly needsHandle: boolean;
   readonly internal: boolean;
 
   constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean) {
     this.name = name;
     this.playwrightFunction = playwrightFunction;
-    this.initScript = new InitScript(`(${addPageBinding.toString()})(${JSON.stringify(PageBinding.kPlaywrightBinding)}, ${JSON.stringify(name)}, ${needsHandle}, (${source})())`, true /* internal */);
+    this.source = `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle}, (${source})())`;
     this.needsHandle = needsHandle;
-    this.internal = name.startsWith('__pw');
   }
 
   static async dispatch(page: Page, payload: string, context: dom.FrameExecutionContext) {
@@ -916,10 +927,13 @@
       callbacks.delete(arg.seq);
     }
   }
+
+  readonly source: string;
 }
 
-function addPageBinding(playwrightBinding: string, bindingName: string, needsHandle: boolean, utilityScriptSerializers: ReturnType<typeof source>) {
-  const binding = (globalThis as any)[playwrightBinding];
+function addPageBinding(bindingName: string, needsHandle: boolean, utilityScriptSerializers: ReturnType<typeof source>) {
+  const binding = (globalThis as any)[bindingName];
+  if (binding && binding.toString().startsWith("(...args) => {")) return
   (globalThis as any)[bindingName] = (...args: any[]) => {
     const me = (globalThis as any)[bindingName];
     if (needsHandle && args.slice(1).some(arg => arg !== undefined))
@@ -953,7 +967,6 @@
     binding(JSON.stringify(payload));
     return promise;
   };
-  (globalThis as any)[bindingName].__installed = true;
 }
 
 export class InitScript {
@@ -963,14 +976,7 @@
 
   constructor(source: string, internal?: boolean, name?: string) {
     const guid = createGuid();
-    this.source = `(() => {
-      globalThis.__pwInitScripts = globalThis.__pwInitScripts || {};
-      const hasInitScript = globalThis.__pwInitScripts[${JSON.stringify(guid)}];
-      if (hasInitScript)
-        return;
-      globalThis.__pwInitScripts[${JSON.stringify(guid)}] = true;
-      ${source}
-    })();`;
+    this.source = `(() => { ${source} })();`;
     this.internal = !!internal;
     this.name = name;
   }
diff -ruN playwright/node_modules/playwright-core/src/server/webkit/wkPage.ts patchright/node_modules/playwright-core/src/server/webkit/wkPage.ts
--- playwright/node_modules/playwright-core/src/server/webkit/wkPage.ts	2025-03-19 15:32:27.016465675 +0000
+++ patchright/node_modules/playwright-core/src/server/webkit/wkPage.ts	2025-03-19 15:32:33.835521893 +0000
@@ -768,7 +768,7 @@
     await this._updateBootstrapScript();
   }
 
-  async removeNonInternalInitScripts() {
+  async removeInitScripts() {
     await this._updateBootstrapScript();
   }
 
diff -ruN playwright/packages/playwright-core/src/protocol/validator.ts patchright/packages/playwright-core/src/protocol/validator.ts
--- playwright/packages/playwright-core/src/protocol/validator.ts	2025-03-19 15:32:27.004465571 +0000
+++ patchright/packages/playwright-core/src/protocol/validator.ts	2025-03-19 15:32:33.831521861 +0000
@@ -1551,6 +1551,7 @@
   expression: tString,
   isFunction: tOptional(tBoolean),
   arg: tType('SerializedArgument'),
+  isolatedContext: tBoolean
 });
 scheme.FrameEvaluateExpressionResult = tObject({
   value: tType('SerializedValue'),
@@ -1836,6 +1837,7 @@
   expression: tString,
   isFunction: tOptional(tBoolean),
   arg: tType('SerializedArgument'),
+  isolatedContext: tBoolean
 });
 scheme.WorkerEvaluateExpressionResult = tObject({
   value: tType('SerializedValue'),
@@ -1863,6 +1865,7 @@
   expression: tString,
   isFunction: tOptional(tBoolean),
   arg: tType('SerializedArgument'),
+  isolatedContext: tBoolean
 });
 scheme.ElementHandleEvaluateExpressionParams = tType('JSHandleEvaluateExpressionParams');
 scheme.JSHandleEvaluateExpressionResult = tObject({
diff -ruN playwright/packages/playwright-core/src/server/bidi/bidiPage.ts patchright/packages/playwright-core/src/server/bidi/bidiPage.ts
--- playwright/packages/playwright-core/src/server/bidi/bidiPage.ts	2025-03-19 15:32:27.006465589 +0000
+++ patchright/packages/playwright-core/src/server/bidi/bidiPage.ts	2025-03-19 15:32:33.832521869 +0000
@@ -376,7 +376,7 @@
       this._initScriptIds.push(script);
   }
 
-  async removeNonInternalInitScripts() {
+  async removeInitScripts() {
     const promises = this._initScriptIds.map(script => this._session.send('script.removePreloadScript', { script }));
     this._initScriptIds = [];
     await Promise.all(promises);
diff -ruN playwright/packages/playwright-core/src/server/browserContext.ts patchright/packages/playwright-core/src/server/browserContext.ts
--- playwright/packages/playwright-core/src/server/browserContext.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/packages/playwright-core/src/server/browserContext.ts	2025-03-19 15:32:33.831521861 +0000
@@ -149,7 +149,7 @@
     if (debugMode() === 'console')
       await this.extendInjectedScript(consoleApiSource.source);
     if (this._options.serviceWorkers === 'block')
-      await this.addInitScript(`\nif (navigator.serviceWorker) navigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };\n`);
+      await this.addInitScript(`navigator.serviceWorker.register = async () => { };`);
 
     if (this._options.permissions)
       await this.grantPermissions(this._options.permissions);
@@ -332,16 +332,15 @@
     }
     const binding = new PageBinding(name, playwrightBinding, needsHandle);
     this._pageBindings.set(name, binding);
-    await this.doAddInitScript(binding.initScript);
-    const frames = this.pages().map(page => page.frames()).flat();
-    await Promise.all(frames.map(frame => frame.evaluateExpression(binding.initScript.source).catch(e => {})));
+    await this.doExposeBinding(binding);
   }
 
   async _removeExposedBindings() {
-    for (const [key, binding] of this._pageBindings) {
-      if (!binding.internal)
+    for (const key of this._pageBindings.keys()) {
+      if (!key.startsWith('__pw'))
         this._pageBindings.delete(key);
     }
+    await this.doRemoveExposedBindings();
   }
 
   async grantPermissions(permissions: string[], origin?: string) {
@@ -430,8 +429,8 @@
   }
 
   async _removeInitScripts(): Promise<void> {
-    this.initScripts = this.initScripts.filter(script => script.internal);
-    await this.doRemoveNonInternalInitScripts();
+    this.initScripts.splice(0, this.initScripts.length);
+    await this.doRemoveInitScripts();
   }
 
   async setRequestInterceptor(handler: network.RouteHandler | undefined): Promise<void> {
diff -ruN playwright/packages/playwright-core/src/server/chromium/chromiumSwitches.ts patchright/packages/playwright-core/src/server/chromium/chromiumSwitches.ts
--- playwright/packages/playwright-core/src/server/chromium/chromiumSwitches.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/packages/playwright-core/src/server/chromium/chromiumSwitches.ts	2025-03-19 15:32:33.833521877 +0000
@@ -58,27 +58,16 @@
   '--disable-field-trial-config', // https://source.chromium.org/chromium/chromium/src/+/main:testing/variations/README.md
   '--disable-background-networking',
   '--disable-background-timer-throttling',
-  '--disable-backgrounding-occluded-windows',
-  '--disable-back-forward-cache', // Avoids surprises like main request not being intercepted during page.goBack().
-  '--disable-breakpad',
-  '--disable-client-side-phishing-detection',
-  '--disable-component-extensions-with-background-pages',
-  '--disable-component-update', // Avoids unneeded network activity after startup.
+  '--disable-backgrounding-occluded-windows', // Avoids surprises like main request not being intercepted during page.goBack().
+  '--disable-breakpad', // Avoids unneeded network activity after startup.
   '--no-default-browser-check',
-  '--disable-default-apps',
   '--disable-dev-shm-usage',
-  '--disable-extensions',
   '--disable-features=' + disabledFeatures.join(','),
-  '--allow-pre-commit-input',
   '--disable-hang-monitor',
-  '--disable-ipc-flooding-protection',
-  '--disable-popup-blocking',
   '--disable-prompt-on-repost',
   '--disable-renderer-backgrounding',
   '--force-color-profile=srgb',
-  '--metrics-recording-only',
   '--no-first-run',
-  '--enable-automation',
   '--password-store=basic',
   '--use-mock-keychain',
   // See https://chromium-review.googlesource.com/c/chromium/src/+/2436773
@@ -86,6 +75,5 @@
   '--export-tagged-pdf',
   // https://chromium-review.googlesource.com/c/chromium/src/+/4853540
   '--disable-search-engine-choice-screen',
-  // https://issues.chromium.org/41491762
-  '--unsafely-disable-devtools-self-xss-warnings',
+  '--disable-blink-features=AutomationControlled'
 ];
diff -ruN playwright/packages/playwright-core/src/server/chromium/crBrowser.ts patchright/packages/playwright-core/src/server/chromium/crBrowser.ts
--- playwright/packages/playwright-core/src/server/chromium/crBrowser.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/packages/playwright-core/src/server/chromium/crBrowser.ts	2025-03-19 15:32:33.833521877 +0000
@@ -474,11 +474,6 @@
       await (page._delegate as CRPage).addInitScript(initScript);
   }
 
-  async doRemoveNonInternalInitScripts() {
-    for (const page of this.pages())
-      await (page._delegate as CRPage).removeNonInternalInitScripts();
-  }
-
   async doUpdateRequestInterception(): Promise<void> {
     for (const page of this.pages())
       await (page._delegate as CRPage).updateRequestInterception();
@@ -578,4 +573,16 @@
     const rootSession = await this._browser._clientRootSession();
     return rootSession.attachToTarget(targetId);
   }
+
+  async doRemoveInitScripts() {
+    for (const page of this.pages()) await (page._delegate as CRPage).removeInitScripts();
+  }
+
+  async doExposeBinding(binding: PageBinding) {
+    for (const page of this.pages()) await (page._delegate as CRPage).exposeBinding(binding);
+  }
+
+  async doRemoveExposedBindings() {
+    for (const page of this.pages()) await (page._delegate as CRPage).removeExposedBindings();
+  }
 }
diff -ruN playwright/packages/playwright-core/src/server/chromium/crDevTools.ts patchright/packages/playwright-core/src/server/chromium/crDevTools.ts
--- playwright/packages/playwright-core/src/server/chromium/crDevTools.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/packages/playwright-core/src/server/chromium/crDevTools.ts	2025-03-19 15:32:33.833521877 +0000
@@ -67,7 +67,6 @@
       }).catch(e => null);
     });
     Promise.all([
-      session.send('Runtime.enable'),
       session.send('Runtime.addBinding', { name: kBindingName }),
       session.send('Page.enable'),
       session.send('Page.addScriptToEvaluateOnNewDocument', { source: `
diff -ruN playwright/packages/playwright-core/src/server/chromium/crNetworkManager.ts patchright/packages/playwright-core/src/server/chromium/crNetworkManager.ts
--- playwright/packages/playwright-core/src/server/chromium/crNetworkManager.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/packages/playwright-core/src/server/chromium/crNetworkManager.ts	2025-03-19 15:32:33.833521877 +0000
@@ -1,3 +1,5 @@
+// undetected-undetected_playwright-patch - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -156,7 +158,7 @@
     const enabled = this._protocolRequestInterceptionEnabled;
     if (initial && !enabled)
       return;
-    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: enabled });
+    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: false });
     let fetchPromise = Promise.resolve<any>(undefined);
     if (!info.workerFrame) {
       if (enabled)
@@ -342,7 +344,7 @@
         headersOverride = redirectedFrom?._originalRequestRoute?._alreadyContinuedParams?.headers;
         requestPausedSessionInfo!.session._sendMayFail('Fetch.continueRequest', { requestId: requestPausedEvent.requestId, headers: headersOverride });
       } else {
-        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId);
+        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId, this._page);
       }
     }
     const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === 'Document';
@@ -606,9 +608,11 @@
   _alreadyContinuedParams: Protocol.Fetch.continueRequestParameters | undefined;
   _fulfilled: boolean = false;
 
-  constructor(session: CRSession, interceptionId: string) {
+  constructor(session: CRSession, interceptionId: string, page: Page) {
+    this._page = void 0;
     this._session = session;
     this._interceptionId = interceptionId;
+    this._page = page;
   }
 
   async continue(overrides: types.NormalizedContinueOverrides): Promise<void> {
@@ -625,6 +629,42 @@
   }
 
   async fulfill(response: types.NormalizedFulfillResponse) {
+    const isTextHtml = response.headers.some(header => header.name === 'content-type' && header.value.includes('text/html'));
+      var allInjections = [...this._page._delegate._mainFrameSession._evaluateOnNewDocumentScripts];
+          for (const binding of this._page._delegate._browserContext._pageBindings.values()) {
+            if (!allInjections.includes(binding)) allInjections.push(binding);
+          }
+      if (isTextHtml && allInjections.length) {
+        // I Chatted so hard for this Code
+        let scriptNonce = crypto.randomBytes(22).toString('hex');
+        for (let i = 0; i < response.headers.length; i++) {
+          if (response.headers[i].name === 'content-security-policy' || response.headers[i].name === 'content-security-policy-report-only') {
+            // Search for an existing script-src nonce that we can hijack
+            let cspValue = response.headers[i].value;
+            const nonceRegex = /script-src[^;]*'nonce-([\w-]+)'/;
+            const nonceMatch = cspValue.match(nonceRegex);
+            if (nonceMatch) {
+              scriptNonce = nonceMatch[1];
+            } else {
+              // Add the new nonce value to the script-src directive
+              const scriptSrcRegex = /(script-src[^;]*)(;|$)/;
+              const newCspValue = cspValue.replace(scriptSrcRegex, `$1 'nonce-${scriptNonce}'$2`);
+              response.headers[i].value = newCspValue;
+            }
+            break;
+          }
+        }
+        let injectionHTML = "";
+        allInjections.forEach((script) => {
+          injectionHTML += `<script class="${this._page._delegate.initScriptTag}" nonce="${scriptNonce}" type="text/javascript">${script.source}</script>`;
+        });
+        if (response.isBase64) {
+          response.isBase64 = false;
+          response.body = injectionHTML + Buffer.from(response.body, 'base64').toString('utf-8');
+        } else {
+          response.body = injectionHTML + response.body;
+        }
+      }
     this._fulfilled = true;
     const body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');
 
diff -ruN playwright/packages/playwright-core/src/server/chromium/crPage.ts patchright/packages/playwright-core/src/server/chromium/crPage.ts
--- playwright/packages/playwright-core/src/server/chromium/crPage.ts	2025-03-19 15:32:27.007465597 +0000
+++ patchright/packages/playwright-core/src/server/chromium/crPage.ts	2025-03-19 15:32:33.834521885 +0000
@@ -1,3 +1,5 @@
+// undetected-undetected_playwright-patch - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -101,7 +103,8 @@
     this.updateOffline();
     this.updateExtraHTTPHeaders();
     this.updateHttpCredentials();
-    this.updateRequestInterception();
+    this._networkManager.setRequestInterception(true);
+    this.initScriptTag = "injected-playwright-init-script-" + crypto.randomBytes(20).toString('hex');
     this._mainFrameSession = new FrameSession(this, client, targetId, null);
     this._sessions.set(targetId, this._mainFrameSession);
     if (opener && !browserContext._options.noDefaultViewport) {
@@ -231,10 +234,11 @@
   }
 
   async addInitScript(initScript: InitScript, world: types.World = 'main'): Promise<void> {
+    this._page.initScripts.push(initScript);
     await this._forAllFrameSessions(frame => frame._evaluateOnNewDocument(initScript, world));
   }
 
-  async removeNonInternalInitScripts() {
+  async removeInitScripts() {
     await this._forAllFrameSessions(frame => frame._removeEvaluatesOnNewDocument());
   }
 
@@ -365,6 +369,15 @@
   shouldToggleStyleSheetToSyncAnimations(): boolean {
     return false;
   }
+
+  async exposeBinding(binding) {
+    await this._forAllFrameSessions(frame => frame._initBinding(binding));
+    await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(binding.source).catch(e => {})));
+  }
+
+  async removeExposedBindings() {
+    await this._forAllFrameSessions(frame => frame._removeExposedBindings());
+  }
 }
 
 class FrameSession {
@@ -479,19 +492,6 @@
           this._handleFrameTree(frameTree);
           this._addRendererListeners();
         }
-
-        const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)!];
-        for (const frame of localFrames) {
-          // Note: frames might be removed before we send these.
-          this._client._sendMayFail('Page.createIsolatedWorld', {
-            frameId: frame._id,
-            grantUniveralAccess: true,
-            worldName: UTILITY_WORLD_NAME,
-          });
-          for (const initScript of this._crPage._page.allInitScripts())
-            frame.evaluateExpression(initScript.source).catch(e => {});
-        }
-
         const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ':';
         if (isInitialEmptyPage) {
           // Ignore lifecycle events, worlds and bindings for the initial empty page. It is never the final page
@@ -501,14 +501,20 @@
             this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
           });
         } else {
+          const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)!];
+          for (const frame of localFrames) {
+            this._page._frameManager.frame(frame._id)._context("utility");
+            for (const binding of this._crPage._browserContext._pageBindings.values())
+              frame.evaluateExpression(binding.source).catch(e => {});
+            for (const source of this._crPage._browserContext.initScripts)
+              frame.evaluateExpression(source).catch(e => {});
+          }
           this._firstNonInitialNavigationCommittedFulfill();
           this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
         }
       }),
       this._client.send('Log.enable', {}),
       lifecycleEventsEnabled = this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-      this._client.send('Runtime.enable', {}),
-      this._client.send('Runtime.addBinding', { name: PageBinding.kPlaywrightBinding }),
       this._client.send('Page.addScriptToEvaluateOnNewDocument', {
         source: '',
         worldName: UTILITY_WORLD_NAME,
@@ -541,14 +547,16 @@
       promises.push(this._updateGeolocation(true));
       promises.push(this._updateEmulateMedia());
       promises.push(this._updateFileChooserInterception(true));
-      for (const initScript of this._crPage._page.allInitScripts())
-        promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+      for (const binding of this._crPage._page.allBindings()) promises.push(this._initBinding(binding));
+      for (const initScript of this._crPage._browserContext.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+      for (const initScript of this._crPage._page.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
       if (screencastOptions)
         promises.push(this._startVideoRecording(screencastOptions));
     }
-    promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
+    if (!(this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size)) promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
     promises.push(this._firstNonInitialNavigationCommittedPromise);
     await Promise.all(promises);
+    if (this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size) await this._client.send('Runtime.runIfWaitingForDebugger');
   }
 
   dispose() {
@@ -565,18 +573,30 @@
 
   async _navigate(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult> {
     const response = await this._client.send('Page.navigate', { url, referrer, frameId: frame._id, referrerPolicy: 'unsafeUrl' });
+    this._client._sendMayFail('Page.waitForDebugger');
     if (response.errorText)
       throw new frames.NavigationAbortedError(response.loaderId, `${response.errorText} at ${url}`);
     return { newDocumentId: response.loaderId };
   }
 
-  _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
+  async _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
     if (this._eventBelongsToStaleFrame(event.frameId))
       return;
     if (event.name === 'load')
       this._page._frameManager.frameLifecycleEvent(event.frameId, 'load');
     else if (event.name === 'DOMContentLoaded')
       this._page._frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded');
+    var document = await this._client._sendMayFail("DOM.getDocument");
+      if (!document) return
+      var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+        nodeId: document.root.nodeId,
+        selector: "[class=" + this._crPage.initScriptTag + "]"
+      });
+      if (!query) return
+      for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+      await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+      // ensuring execution context
+      try { await this._page._frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _handleFrameTree(frameTree: Protocol.Page.FrameTree) {
@@ -623,12 +643,23 @@
     this._page._frameManager.frameAttached(frameId, parentFrameId);
   }
 
-  _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
+  async _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
     if (this._eventBelongsToStaleFrame(framePayload.id))
       return;
     this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ''), framePayload.name || '', framePayload.loaderId, initial);
     if (!initial)
       this._firstNonInitialNavigationCommittedFulfill();
+    var document = await this._client._sendMayFail("DOM.getDocument");
+      if (!document) return
+      var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+        nodeId: document.root.nodeId,
+        selector: "[class=" + this._crPage.initScriptTag + "]"
+      });
+      if (!query) return
+      for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+      await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+      // ensuring execution context
+      try { await this._page._frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _onFrameRequestedNavigation(payload: Protocol.Page.frameRequestedNavigationPayload) {
@@ -665,19 +696,24 @@
   }
 
   _onExecutionContextCreated(contextPayload: Protocol.Runtime.ExecutionContextDescription) {
+    for (const name of this._exposedBindingNames) this._client._sendMayFail('Runtime.addBinding', { name: name, executionContextId: contextPayload.id });
     const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
+    if (contextPayload.auxData.type == "worker") throw new Error("ExecutionContext is worker");
     if (!frame || this._eventBelongsToStaleFrame(frame._id))
       return;
     const delegate = new CRExecutionContext(this._client, contextPayload);
-    let worldName: types.World|null = null;
-    if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
-      worldName = 'main';
-    else if (contextPayload.name === UTILITY_WORLD_NAME)
-      worldName = 'utility';
+    let worldName = contextPayload.name;
     const context = new dom.FrameExecutionContext(delegate, frame, worldName);
     if (worldName)
       frame._contextCreated(worldName, context);
     this._contextIdToContext.set(contextPayload.id, context);
+    for (const source of this._exposedBindingScripts) {
+      this._client._sendMayFail("Runtime.evaluate", {
+        expression: source,
+        contextId: contextPayload.id,
+        awaitPromise: true,
+      })
+    }
   }
 
   _onExecutionContextDestroyed(executionContextId: number) {
@@ -693,7 +729,7 @@
       this._onExecutionContextDestroyed(contextId);
   }
 
-  _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
+  async _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
     const session = this._client.createChildSession(event.sessionId);
 
     if (event.targetInfo.type === 'iframe') {
@@ -725,8 +761,17 @@
     session.once('Runtime.executionContextCreated', async event => {
       worker._createExecutionContext(new CRExecutionContext(session, event.context));
     });
+    var globalThis = await session._sendMayFail('Runtime.evaluate', {
+      expression: "globalThis",
+      serializationOptions: { serialization: "idOnly" }
+
+    });
+    if (globalThis && globalThis.result) {
+      var globalThisObjId = globalThis.result.objectId;
+      var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+      worker._createExecutionContext(new CRExecutionContext(session, { id: executionContextId }));
+    }
     // This might fail if the target is closed before we initialize.
-    session._sendMayFail('Runtime.enable');
     // TODO: attribute workers to the right frame.
     this._crPage._networkManager.addSession(session, this._page._frameManager.frame(this._targetId) ?? undefined).catch(() => {});
     session._sendMayFail('Runtime.runIfWaitingForDebugger');
@@ -805,8 +850,8 @@
     const pageOrError = await this._crPage._page.waitForInitializedOrError();
     if (!(pageOrError instanceof Error)) {
       const context = this._contextIdToContext.get(event.executionContextId);
-      if (context)
-        await this._page._onBindingCalled(event.payload, context);
+      if (context) await this._page._onBindingCalled(event.payload, context);
+      else await this._page._onBindingCalled(event.payload, (await this._page.mainFrame()._mainContext())) // This might be a bit sketchy but it works for now
     }
   }
 
@@ -1052,16 +1097,11 @@
   }
 
   async _evaluateOnNewDocument(initScript: InitScript, world: types.World): Promise<void> {
-    const worldName = world === 'utility' ? UTILITY_WORLD_NAME : undefined;
-    const { identifier } = await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source: initScript.source, worldName });
-    if (!initScript.internal)
-      this._evaluateOnNewDocumentIdentifiers.push(identifier);
+    this._evaluateOnNewDocumentScripts.push(initScript)
   }
 
   async _removeEvaluatesOnNewDocument(): Promise<void> {
-    const identifiers = this._evaluateOnNewDocumentIdentifiers;
-    this._evaluateOnNewDocumentIdentifiers = [];
-    await Promise.all(identifiers.map(identifier => this._client.send('Page.removeScriptToEvaluateOnNewDocument', { identifier })));
+    this._evaluateOnNewDocumentScripts = [];
   }
 
   async _getContentFrame(handle: dom.ElementHandle): Promise<frames.Frame | null> {
@@ -1168,6 +1208,47 @@
       throw new Error(dom.kUnableToAdoptErrorMessage);
     return createHandle(to, result.object).asElement()!;
   }
+
+  _exposedBindingNames: string[] = [];
+  _evaluateOnNewDocumentScripts: string[] = [];
+  _parsedExecutionContextIds: number[] = [];
+  _exposedBindingScripts: string[] = [];
+
+  async _initBinding(binding = PageBinding) {
+    var result = await this._client._sendMayFail('Page.createIsolatedWorld', {
+      frameId: this._targetId, grantUniveralAccess: true, worldName: "utility"
+    });
+    if (!result) return
+    var isolatedContextId = result.executionContextId
+
+    var globalThis = await this._client._sendMayFail('Runtime.evaluate', {
+      expression: "globalThis",
+      serializationOptions: { serialization: "idOnly" }
+    });
+    if (!globalThis) return
+    var globalThisObjId = globalThis["result"]['objectId']
+    var mainContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+    await Promise.all([
+      this._client._sendMayFail('Runtime.addBinding', { name: binding.name }),
+      this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: mainContextId }),
+      this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: isolatedContextId }),
+      // this._client._sendMayFail("Runtime.evaluate", { expression: binding.source, contextId: mainContextId, awaitPromise: true })
+    ]);
+    this._exposedBindingNames.push(binding.name);
+    this._exposedBindingScripts.push(binding.source);
+    await this._crPage.addInitScript(binding.source);
+    //this._client._sendMayFail('Runtime.runIfWaitingForDebugger')
+  }
+
+  async _removeExposedBindings() {
+    const toRetain: string[] = [];
+    const toRemove: string[] = [];
+    for (const name of this._exposedBindingNames)
+      (name.startsWith('__pw_') ? toRetain : toRemove).push(name);
+    this._exposedBindingNames = toRetain;
+    await Promise.all(toRemove.map(name => this._client.send('Runtime.removeBinding', { name })));
+  }
 }
 
 async function emulateLocale(session: CRSession, locale: string) {
diff -ruN playwright/packages/playwright-core/src/server/chromium/crServiceWorker.ts patchright/packages/playwright-core/src/server/chromium/crServiceWorker.ts
--- playwright/packages/playwright-core/src/server/chromium/crServiceWorker.ts	2025-03-19 15:32:27.008465606 +0000
+++ patchright/packages/playwright-core/src/server/chromium/crServiceWorker.ts	2025-03-19 15:32:33.834521885 +0000
@@ -44,8 +44,6 @@
       this.updateOffline();
       this._networkManager.addSession(session, undefined, true /* isMain */).catch(() => {});
     }
-
-    session.send('Runtime.enable', {}).catch(e => { });
     session.send('Runtime.runIfWaitingForDebugger').catch(e => { });
     session.on('Inspector.targetReloadedAfterCrash', () => {
       // Resume service worker after restart.
diff -ruN playwright/packages/playwright-core/src/server/clock.ts patchright/packages/playwright-core/src/server/clock.ts
--- playwright/packages/playwright-core/src/server/clock.ts	2025-03-19 15:32:27.008465606 +0000
+++ patchright/packages/playwright-core/src/server/clock.ts	2025-03-19 15:32:33.831521861 +0000
@@ -92,6 +92,14 @@
   }
 
   private async _evaluateInFrames(script: string) {
+    // Dont ask me why this works
+    await Promise.all(this._browserContext.pages().map(async page => {
+      await Promise.all(page.frames().map(async frame => {
+        try {
+          await frame.evaluateExpression("");
+        } catch (e) {}
+      }));
+    }));
     await this._browserContext.safeNonStallingEvaluateInAllFrames(script, 'main', { throwOnJSErrors: true });
   }
 }
diff -ruN playwright/packages/playwright-core/src/server/dispatchers/frameDispatcher.ts patchright/packages/playwright-core/src/server/dispatchers/frameDispatcher.ts
--- playwright/packages/playwright-core/src/server/dispatchers/frameDispatcher.ts	2025-03-19 15:32:27.009465614 +0000
+++ patchright/packages/playwright-core/src/server/dispatchers/frameDispatcher.ts	2025-03-19 15:32:33.834521885 +0000
@@ -84,11 +84,15 @@
   }
 
   async evaluateExpression(params: channels.FrameEvaluateExpressionParams, metadata: CallMetadata): Promise<channels.FrameEvaluateExpressionResult> {
-    return { value: serializeResult(await this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg))) };
+    return { value: serializeResult(await this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction,
+      world: params.isolatedContext ? 'utility': 'main'
+    }, parseArgument(params.arg))) };
   }
 
   async evaluateExpressionHandle(params: channels.FrameEvaluateExpressionHandleParams, metadata: CallMetadata): Promise<channels.FrameEvaluateExpressionHandleResult> {
-    return { handle: ElementHandleDispatcher.fromJSHandle(this, await this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg))) };
+    return { handle: ElementHandleDispatcher.fromJSHandle(this, await this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction,
+      world: params.isolatedContext ? 'utility': 'main'
+    }, parseArgument(params.arg))) };
   }
 
   async waitForSelector(params: channels.FrameWaitForSelectorParams, metadata: CallMetadata): Promise<channels.FrameWaitForSelectorResult> {
diff -ruN playwright/packages/playwright-core/src/server/dispatchers/jsHandleDispatcher.ts patchright/packages/playwright-core/src/server/dispatchers/jsHandleDispatcher.ts
--- playwright/packages/playwright-core/src/server/dispatchers/jsHandleDispatcher.ts	2025-03-19 15:32:27.009465614 +0000
+++ patchright/packages/playwright-core/src/server/dispatchers/jsHandleDispatcher.ts	2025-03-19 15:32:33.834521885 +0000
@@ -39,11 +39,11 @@
   }
 
   async evaluateExpression(params: channels.JSHandleEvaluateExpressionParams): Promise<channels.JSHandleEvaluateExpressionResult> {
-    return { value: serializeResult(await this._object.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg))) };
+    return { value: serializeResult(await this._object.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg), params.isolatedContext)) };
   }
 
   async evaluateExpressionHandle(params: channels.JSHandleEvaluateExpressionHandleParams): Promise<channels.JSHandleEvaluateExpressionHandleResult> {
-    const jsHandle = await this._object.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg));
+    const jsHandle = await this._object.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg), params.isolatedContext);
     return { handle: ElementHandleDispatcher.fromJSHandle(this.parentScope(), jsHandle) };
   }
 
diff -ruN playwright/packages/playwright-core/src/server/dispatchers/pageDispatcher.ts patchright/packages/playwright-core/src/server/dispatchers/pageDispatcher.ts
--- playwright/packages/playwright-core/src/server/dispatchers/pageDispatcher.ts	2025-03-19 15:32:27.009465614 +0000
+++ patchright/packages/playwright-core/src/server/dispatchers/pageDispatcher.ts	2025-03-19 15:32:33.834521885 +0000
@@ -353,11 +353,11 @@
   }
 
   async evaluateExpression(params: channels.WorkerEvaluateExpressionParams, metadata: CallMetadata): Promise<channels.WorkerEvaluateExpressionResult> {
-    return { value: serializeResult(await this._object.evaluateExpression(params.expression, params.isFunction, parseArgument(params.arg))) };
+    return { value: serializeResult(await this._object.evaluateExpression(params.expression, params.isFunction, parseArgument(params.arg), params.isolatedContext)) };
   }
 
   async evaluateExpressionHandle(params: channels.WorkerEvaluateExpressionHandleParams, metadata: CallMetadata): Promise<channels.WorkerEvaluateExpressionHandleResult> {
-    return { handle: ElementHandleDispatcher.fromJSHandle(this, await this._object.evaluateExpressionHandle(params.expression, params.isFunction, parseArgument(params.arg))) };
+    return { handle: ElementHandleDispatcher.fromJSHandle(this, await this._object.evaluateExpressionHandle(params.expression, params.isFunction, parseArgument(params.arg), params.isolatedContext)) };
   }
 }
 
diff -ruN playwright/packages/playwright-core/src/server/firefox/ffPage.ts patchright/packages/playwright-core/src/server/firefox/ffPage.ts
--- playwright/packages/playwright-core/src/server/firefox/ffPage.ts	2025-03-19 15:32:27.010465623 +0000
+++ patchright/packages/playwright-core/src/server/firefox/ffPage.ts	2025-03-19 15:32:33.834521885 +0000
@@ -390,7 +390,7 @@
     await this._session.send('Page.setInitScripts', { scripts: this._initScripts.map(s => ({ script: s.initScript.source, worldName: s.worldName })) });
   }
 
-  async removeNonInternalInitScripts() {
+  async removeInitScripts() {
     this._initScripts = this._initScripts.filter(s => s.initScript.internal);
     await this._session.send('Page.setInitScripts', { scripts: this._initScripts.map(s => ({ script: s.initScript.source, worldName: s.worldName })) });
   }
diff -ruN playwright/packages/playwright-core/src/server/frames.ts patchright/packages/playwright-core/src/server/frames.ts
--- playwright/packages/playwright-core/src/server/frames.ts	2025-03-19 15:32:27.011465632 +0000
+++ patchright/packages/playwright-core/src/server/frames.ts	2025-03-19 15:32:33.832521869 +0000
@@ -1,3 +1,7 @@
+// undetected-undetected_playwright-patch - custom imports
+import { CRExecutionContext } from './chromium/crExecutionContext';
+import { FrameExecutionContext } from './dom';
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -530,6 +534,9 @@
   }
 
   _onClearLifecycle() {
+    this._isolatedWorld = undefined;
+    this._mainWorld = undefined;
+    this._iframeWorld = undefined;
     for (const event of this._firedLifecycleEvents)
       this.emit(Frame.Events.RemoveLifecycle, event);
     this._firedLifecycleEvents.clear();
@@ -743,12 +750,68 @@
     return this._page._delegate.getFrameElement(this);
   }
 
-  _context(world: types.World): Promise<dom.FrameExecutionContext> {
-    return this._contextData.get(world)!.contextPromise.then(contextOrDestroyedReason => {
-      if (contextOrDestroyedReason instanceof js.ExecutionContext)
-        return contextOrDestroyedReason;
-      throw new Error(contextOrDestroyedReason.destroyedReason);
-    });
+  async _context(world: types.World): Promise<dom.FrameExecutionContext> {
+    /* await this._page._delegate._mainFrameSession._client._sendMayFail('DOM.enable');
+        var globalDoc = await this._page._delegate._mainFrameSession._client._sendMayFail('DOM.getFrameOwner', { frameId: this._id });
+        if (globalDoc) {
+          await this._page._delegate._mainFrameSession._client._sendMayFail("DOM.resolveNode", { nodeId: globalDoc.nodeId })
+        } */
+
+        // if (this.isDetached()) throw new Error('Frame was detached');
+        try {
+          var client = this._page._delegate._sessionForFrame(this)._client
+        } catch (e) { var client = this._page._delegate._mainFrameSession._client }
+        var iframeExecutionContextId = await this._getFrameMainFrameContextId(client)
+
+        if (world == "main") {
+          // Iframe Only
+          if (this != this._page.mainFrame() && iframeExecutionContextId && this._iframeWorld == undefined) {
+            var executionContextId = iframeExecutionContextId
+            var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+            this._iframeWorld = new FrameExecutionContext(crContext, this, world)
+            this._page._delegate._mainFrameSession._onExecutionContextCreated({
+              id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+            })
+          } else if (this._mainWorld == undefined) {
+            var globalThis = await client._sendMayFail('Runtime.evaluate', {
+              expression: "globalThis",
+              serializationOptions: { serialization: "idOnly" }
+            });
+            if (!globalThis) { return }
+            var globalThisObjId = globalThis["result"]['objectId']
+            var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+            var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+            this._mainWorld = new FrameExecutionContext(crContext, this, world)
+            this._page._delegate._mainFrameSession._onExecutionContextCreated({
+              id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+            })
+          }
+        }
+        if (world != "main" && this._isolatedWorld == undefined) {
+          world = "utility"
+          var result = await client._sendMayFail('Page.createIsolatedWorld', {
+            frameId: this._id, grantUniveralAccess: true, worldName: world
+          });
+          if (!result) {
+            // if (this.isDetached()) throw new Error("Frame was detached");
+            return
+          }
+          var executionContextId = result.executionContextId
+          var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+          this._isolatedWorld = new FrameExecutionContext(crContext, this, world)
+          this._page._delegate._mainFrameSession._onExecutionContextCreated({
+            id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+          })
+        }
+
+        if (world != "main") {
+          return this._isolatedWorld;
+        } else if (this != this._page.mainFrame() && iframeExecutionContextId) {
+          return this._iframeWorld;
+        } else {
+          return this._mainWorld;
+        }
   }
 
   _mainContext(): Promise<dom.FrameExecutionContext> {
@@ -796,58 +859,49 @@
   }
 
   async waitForSelectorInternal(progress: Progress, selector: string, performActionPreChecks: boolean, options: types.WaitForElementOptions, scope?: dom.ElementHandle): Promise<dom.ElementHandle<Element> | null> {
-    const { state = 'visible' } = options;
-    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecks)
-        await this._page.performActionPreChecks(progress);
-
-      const resolved = await this.selectors.resolveInjectedForSelector(selector, options, scope);
-      progress.throwIfAborted();
-      if (!resolved) {
-        if (state === 'hidden' || state === 'detached')
-          return null;
-        return continuePolling;
-      }
-      const result = await resolved.injected.evaluateHandle((injected, { info, root }) => {
-        if (root && !root.isConnected)
-          throw injected.createStacklessError('Element is not attached to the DOM');
-        const elements = injected.querySelectorAll(info.parsed, root || document);
-        const element: Element | undefined  = elements[0];
-        const visible = element ? injected.utils.isElementVisible(element) : false;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
-            throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewNode(element)}`;
+    const {
+      state = 'visible'
+    } = options;
+    const promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, true, async handle => {
+      const attached = !!handle;
+      var visible = false;
+      if (attached) {
+        if (handle.parentNode.constructor.name == "ElementHandle") {
+          visible = await handle.parentNode.evaluateInUtility(([injected, node, { handle }]) => {
+            return handle ? injected.utils.isElementVisible(handle) : false;
+          }, {
+            handle
+          });
+        } else {
+          visible = await handle.parentNode.evaluate((injected, { handle }) => {
+            return handle ? injected.utils.isElementVisible(handle) : false;
+          }, {
+            handle
+          });
         }
-        return { log, element, visible, attached: !!element };
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined });
-      const { log, visible, attached } = await result.evaluate(r => ({ log: r.log, visible: r.visible, attached: r.attached }));
-      if (log)
-        progress.log(log);
-      const success = { attached, detached: !attached, visible, hidden: !visible }[state];
+      }
+
+      const success = {
+        attached,
+        detached: !attached,
+        visible,
+        hidden: !visible
+      }[state];
       if (!success) {
-        result.dispose();
-        return continuePolling;
+        return "internal:continuepolling";
       }
       if (options.omitReturnValue) {
-        result.dispose();
         return null;
       }
-      const element = state === 'attached' || state === 'visible' ? await result.evaluateHandle(r => r.element) : null;
-      result.dispose();
-      if (!element)
-        return null;
-      if ((options as any).__testHookBeforeAdoptNode)
-        await (options as any).__testHookBeforeAdoptNode();
+      const element = state === 'attached' || state === 'visible' ? handle : null;
+      if (!element) return null;
+      if (options.__testHookBeforeAdoptNode) await options.__testHookBeforeAdoptNode();
       try {
-        return await element._adoptTo(await resolved.frame._mainContext());
+        return element;
       } catch (e) {
-        return continuePolling;
+        return "internal:continuepolling";
       }
-    });
+    }, 'returnOnNotResolved');
     return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
   }
 
@@ -908,31 +962,38 @@
   }
 
   async setContent(metadata: CallMetadata, html: string, options: types.NavigateOptions = {}): Promise<void> {
-    const controller = new ProgressController(metadata, this);
-    return controller.run(async progress => {
-      await this.raceNavigationAction(progress, options, async () => {
-        const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;
-        progress.log(`setting frame content, waiting until "${waitUntil}"`);
-        const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
-        const context = await this._utilityContext();
-        const lifecyclePromise = new Promise((resolve, reject) => {
-          this._page._frameManager._consoleMessageTags.set(tag, () => {
-            // Clear lifecycle right after document.open() - see 'tag' below.
-            this._onClearLifecycle();
-            this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
+      const controller = new ProgressController(metadata, this);
+      return controller.run(async progress => {
+        await this.raceNavigationAction(progress, options, async () => {
+          const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;
+          progress.log(`setting frame content, waiting until "${waitUntil}"`);
+          const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
+          const bindingName = "_tagDebug" + crypto.randomBytes(20).toString('hex');
+          const context = await this._utilityContext();
+          await this._page._delegate._mainFrameSession._client.send('Runtime.addBinding', { name: bindingName });
+          const lifecyclePromise = new Promise(async (resolve, reject) => {
+            await this._page.exposeBinding(bindingName, false, (tag) => {
+              this._onClearLifecycle();
+              this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
+            });
           });
+          const contentPromise = context.evaluate(({ html, tag, bindingName }) => {
+            document.open();
+            var _tagDebug = window[bindingName].bind({});
+            delete window[bindingName]
+            _tagDebug('{ "name": "' + bindingName + '", "seq": 1, "serializedArgs": ["' + tag + '"] }');
+            console.debug(tag);  // eslint-disable-line no-console
+            document.write(html);
+            document.close();
+          }, { html, tag,
+            bindingName
+          });
+          await Promise.all([contentPromise, lifecyclePromise]);
+          return null;
         });
-        const contentPromise = context.evaluate(({ html, tag }) => {
-          document.open();
-          console.debug(tag);  // eslint-disable-line no-console
-          document.write(html);
-          document.close();
-        }, { html, tag });
-        await Promise.all([contentPromise, lifecyclePromise]);
-        return null;
-      });
-    }, this._page._timeoutSettings.navigationTimeout(options));
-  }
+      }, this._page._timeoutSettings.navigationTimeout(options));
+    }
+
 
   name(): string {
     return this._name || '';
@@ -1125,50 +1186,74 @@
     selector: string,
     strict: boolean | undefined,
     performActionPreChecks: boolean,
-    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>): Promise<R> {
-    progress.log(`waiting for ${this._asLocator(selector)}`);
+    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>, returnAction: boolean | undefined): Promise<R> {
+    progress.log("waiting for " + this._asLocator(selector));
     return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecks)
-        await this._page.performActionPreChecks(progress);
-
-      const resolved = await this.selectors.resolveInjectedForSelector(selector, { strict });
+      if (performActionPreChecks) await this._page.performActionPreChecks(progress);
+      const resolved = await this.selectors.resolveInjectedForSelector(selector, {
+        strict
+      });
       progress.throwIfAborted();
-      if (!resolved)
+      if (!resolved) {
+        if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') return null;
         return continuePolling;
-      const result = await resolved.injected.evaluateHandle((injected, { info, callId }) => {
-        const elements = injected.querySelectorAll(info.parsed, document);
-        if (callId)
-          injected.markTargetElements(new Set(elements), callId);
-        const element = elements[0] as Element | undefined;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
+      }
+
+      try {
+        var client = this._page._delegate._sessionForFrame(resolved.frame)._client;
+      } catch (e) {
+        var client = this._page._delegate._mainFrameSession._client;
+      }
+      var context = await resolved.frame._context("main");
+
+      const documentNode = await client.send('Runtime.evaluate', {
+        expression: "document",
+        serializationOptions: {
+          serialization: "idOnly"
+        },
+        contextId: context.delegate._contextId,
+      });
+      const documentScope = new dom.ElementHandle(context, documentNode.result.objectId);
+
+      const currentScopingElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, resolved.info.parsed);
+      if (currentScopingElements.length == 0) {
+        // TODO: Dispose?
+        if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') return null;
+        return continuePolling;
+      }
+      const resultElement = currentScopingElements[0];
+      if (currentScopingElements.length > 1) {
+        if (resolved.info.strict) {
+          await resolved.injected.evaluateHandle((injected, {
+            info,
+            elements
+          }) => {
             throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${injected.previewNode(element)}`;
+          }, {
+            info: resolved.info,
+            elements: currentScopingElements
+          });
         }
-        return { log, success: !!element, element };
-      }, { info: resolved.info, callId: progress.metadata.id });
-      const { log, success } = await result.evaluate(r => ({ log: r.log, success: r.success }));
-      if (log)
-        progress.log(log);
-      if (!success) {
-        result.dispose();
-        return continuePolling;
+        progress.log("  locator resolved to " + currentScopingElements.length + " elements. Proceeding with the first one: " + resultElement.preview());
+      } else if (resultElement) {
+        progress.log("  locator resolved to " + resultElement.preview());
       }
-      const element = await result.evaluateHandle(r => r.element) as dom.ElementHandle<Element>;
-      result.dispose();
+
       try {
-        const result = await action(element);
+        var result = null;
+        if (returnAction === 'returnAll') {
+          result = await action([resultElement, currentScopingElements]);
+        } else {
+          result = await action(resultElement);
+        }
         if (result === 'error:notconnected') {
           progress.log('element was detached from the DOM, retrying');
           return continuePolling;
+        } else if (result === 'internal:continuepolling') {
+          return continuePolling;
         }
         return result;
-      } finally {
-        element?.dispose();
-      }
+      } finally { }
     });
   }
 
@@ -1319,17 +1404,34 @@
 
   async isVisibleInternal(selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {
     try {
-      const resolved = await this.selectors.resolveInjectedForSelector(selector, options, scope);
-      if (!resolved)
-        return false;
-      return await resolved.injected.evaluate((injected, { info, root }) => {
-        const element = injected.querySelector(info.parsed, root || document, info.strict);
-        const state = element ? injected.elementState(element, 'visible') : { matches: false, received: 'error:notconnected' };
-        return state.matches;
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined });
+      const custom_metadata = { "internal": false, "log": [] };
+      const controller = new ProgressController(custom_metadata, this);
+      return await controller.run(async progress => {
+        progress.log("waiting for " + this._asLocator(selector));
+        const promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, false, async handle => {
+          if (handle.parentNode.constructor.name == "ElementHandle") {
+            return await handle.parentNode.evaluateInUtility(([injected, node, { handle }]) => {
+              const state = handle ? injected.elementState(handle, 'visible') : {
+                matches: false,
+                received: 'error:notconnected'
+              };
+              return state.matches;
+            }, { handle });
+          } else {
+            return await handle.parentNode.evaluate((injected, { handle }) => {
+              const state = handle ? injected.elementState(handle, 'visible') : {
+                matches: false,
+                received: 'error:notconnected'
+              };
+              return state.matches;
+            }, { handle });
+          }
+        });
+
+        return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+      }, 100); // A bit geeky but its okay :D
     } catch (e) {
-      if (js.isJavaScriptErrorInEvaluate(e) || isInvalidSelectorError(e) || isSessionClosedError(e))
-        throw e;
+      if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorParser.isInvalidSelectorError)(e) || (0, _protocolError.isSessionClosedError)(e)) throw e;
       return false;
     }
   }
@@ -1489,40 +1591,46 @@
   }
 
   private async _expectInternal(progress: Progress, selector: string, options: FrameExpectParams, lastIntermediateResult: { received?: any, isSet: boolean }) {
-    const selectorInFrame = await this.selectors.resolveFrameForSelector(selector, { strict: true });
-    progress.throwIfAborted();
+    progress.log("waiting for " + this._asLocator(selector));
+    const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
 
-    const { frame, info } = selectorInFrame || { frame: this, info: undefined };
-    const world = options.expression === 'to.have.property' ? 'main' : (info?.world ?? 'utility');
-    const context = await frame._context(world);
-    const injected = await context.injectedScript();
-    progress.throwIfAborted();
+    const promise = await this._retryWithProgressIfNotConnected(progress, selector, !isArray, false, async result => {
+      const handle = result[0];
+      const handles = result[1];
+
+      if (handle.parentNode.constructor.name == "ElementHandle") {
+        return await handle.parentNode.evaluateInUtility(async ([injected, node, { handle, options, handles }]) => {
+          return await injected.expect(handle, options, handles);
+        }, { handle, options, handles });
+      } else {
+        return await handle.parentNode.evaluate(async (injected, { handle, options, handles }) => {
+          return await injected.expect(handle, options, handles);
+        }, { handle, options, handles });
+      }
+    }, 'returnAll');
 
-    const { log, matches, received, missingReceived } = await injected.evaluate(async (injected, { info, options, callId }) => {
-      const elements = info ? injected.querySelectorAll(info.parsed, document) : [];
-      if (callId)
-        injected.markTargetElements(new Set(elements), callId);
-      const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
-      let log = '';
-      if (isArray)
-        log = `  locator resolved to ${elements.length} element${elements.length === 1 ? '' : 's'}`;
-      else if (elements.length > 1)
-        throw injected.strictModeViolationError(info!.parsed, elements);
-      else if (elements.length)
-        log = `  locator resolved to ${injected.previewNode(elements[0])}`;
-      return { log, ...await injected.expect(elements[0], options, elements) };
-    }, { info, options, callId: progress.metadata.id });
-
-    if (log)
-      progress.log(log);
-    // Note: missingReceived avoids `unexpected value "undefined"` when element was not found.
+    // Default Values, if no Elements found
+    var matches = false;
+    var received = 0;
+    var missingReceived = null;
+    if (promise) {
+      matches = promise.matches;
+      received = promise.received;
+      missingReceived = promise.missingReceived;
+    } else if (options.expectedNumber === 0) {
+      matches = true;
+    }
+
+    // Note: missingReceived avoids unexpected value "undefined" when element was not found.
     if (matches === options.isNot) {
       lastIntermediateResult.received = missingReceived ? '<element(s) not found>' : received;
       lastIntermediateResult.isSet = true;
-      if (!missingReceived && !Array.isArray(received))
-        progress.log(`  unexpected value "${renderUnexpectedValue(options.expression, received)}"`);
+      if (!missingReceived && !Array.isArray(received)) progress.log('  unexpected value "' + renderUnexpectedValue(options.expression, received) + '"');
     }
-    return { matches, received };
+    return {
+      matches,
+      received
+    };
   }
 
   async _waitForFunctionExpression<R>(metadata: CallMetadata, expression: string, isFunction: boolean | undefined, arg: any, options: types.WaitForFunctionOptions, world: types.World = 'main'): Promise<js.SmartHandle<R>> {
@@ -1632,28 +1740,27 @@
     const callbackText = body.toString();
     const controller = new ProgressController(metadata, this);
     return controller.run(async progress => {
-      progress.log(`waiting for ${this._asLocator(selector)}`);
-      const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-        const resolved = await this.selectors.resolveInjectedForSelector(selector, options, scope);
-        progress.throwIfAborted();
-        if (!resolved)
-          return continuePolling;
-        const { log, success, value } = await resolved.injected.evaluate((injected, { info, callbackText, taskData, callId, root }) => {
-          const callback = injected.eval(callbackText) as ElementCallback<T, R>;
-          const element = injected.querySelector(info.parsed, root || document, info.strict);
-          if (!element)
-            return { success: false };
-          const log = `  locator resolved to ${injected.previewNode(element)}`;
-          if (callId)
-            injected.markTargetElements(new Set([element]), callId);
-          return { log, success: true, value: callback(injected, element, taskData as T) };
-        }, { info: resolved.info, callbackText, taskData, callId: progress.metadata.id, root: resolved.frame === this ? scope : undefined });
-
-        if (log)
-          progress.log(log);
-        if (!success)
-          return continuePolling;
-        return value!;
+      progress.log("waiting for "+ this._asLocator(selector));
+      const promise = this._retryWithProgressIfNotConnected(progress, selector, false, false, async handle => {
+        if (handle.parentNode.constructor.name == "ElementHandle") {
+          return await handle.parentNode.evaluateInUtility(([injected, node, { callbackText, handle, taskData }]) => {
+            const callback = injected.eval(callbackText);
+            return callback(injected, handle, taskData);
+          }, {
+            callbackText,
+            handle,
+            taskData
+          });
+        } else {
+          return await handle.parentNode.evaluate((injected, { callbackText, handle, taskData }) => {
+            const callback = injected.eval(callbackText);
+            return callback(injected, handle, taskData);
+          }, {
+            callbackText,
+            handle,
+            taskData
+          });
+        }
       });
       return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
     }, this._page._timeoutSettings.timeout(options));
@@ -1757,6 +1864,169 @@
   private _asLocator(selector: string) {
     return asLocator(this._page.attribution.playwright.options.sdkLanguage, selector);
   }
+
+  _isolatedWorld: dom.FrameExecutionContext;
+  _mainWorld: dom.FrameExecutionContext;
+  _iframeWorld: dom.FrameExecutionContext;
+
+  async _getFrameMainFrameContextId(client): Promise<number> {
+    try {
+        var globalDocument = await client._sendMayFail("DOM.getFrameOwner", {frameId: this._id,});
+        if (globalDocument && globalDocument.nodeId) {
+          var describedNode = await client._sendMayFail("DOM.describeNode", {
+            backendNodeId: globalDocument.backendNodeId,
+          });
+          if (describedNode) {
+            var resolvedNode = await client._sendMayFail("DOM.resolveNode", {
+              nodeId: describedNode.node.contentDocument.nodeId,
+            });
+            var _executionContextId = parseInt(resolvedNode.object.objectId.split(".")[1], 10);
+            return _executionContextId;
+            }
+          }
+        } catch (e) {}
+        return 0;
+  }
+
+  async _customFindElementsByParsed(resolved, client, context, documentScope, progress, parsed) {
+    var parsedEdits = { ...parsed };
+    // Note: We start scoping at document level
+    var currentScopingElements = [documentScope];
+    while (parsed.parts.length > 0) {
+      var part = parsed.parts.shift();
+      parsedEdits.parts = [part];
+      var isUsingXPath = false;
+      // Getting All Elements
+      var elements = [];
+      var elementsIndexes = [];
+
+      if (part.name == "xpath") {
+        isUsingXPath = true;
+      } else if (part.name == "nth") {
+        const partNth = Number(part.body);
+        if (partNth > currentScopingElements.length || partNth < -currentScopingElements.length) {
+          return continuePolling;
+        } else {
+          currentScopingElements = [currentScopingElements.at(partNth)];
+          continue;
+        }
+      } else if (part.name == "internal:or") {
+        var orredElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+        elements = currentScopingElements.concat(orredElements);
+      } else if (part.name == "internal:and") {
+        var andedElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+        const backendNodeIds = new Set(andedElements.map(item => item.backendNodeId));
+        elements = currentScopingElements.filter(item => backendNodeIds.has(item.backendNodeId));
+      } else {
+        for (const scope of currentScopingElements) {
+          const describedScope = await client.send('DOM.describeNode', {
+            objectId: scope._objectId,
+            depth: -1,
+            pierce: true
+          });
+
+          // Elements Queryed in the "current round"
+          var queryingElements = [];
+
+          if (!isUsingXPath) {
+            function findClosedShadowRoots(node, results = []) {
+              if (!node || typeof node !== 'object') return results;
+              if (node.shadowRoots && Array.isArray(node.shadowRoots)) {
+                for (const shadowRoot of node.shadowRoots) {
+                  if (shadowRoot.shadowRootType === 'closed' && shadowRoot.backendNodeId) {
+                    results.push(shadowRoot.backendNodeId);
+                  }
+                  findClosedShadowRoots(shadowRoot, results);
+                }
+              }
+              if (node.nodeName !== 'IFRAME' && node.children && Array.isArray(node.children)) {
+                for (const child of node.children) {
+                  findClosedShadowRoots(child, results);
+                }
+              }
+              return results;
+            }
+
+            var shadowRootBackendIds = findClosedShadowRoots(describedScope.node);
+            var shadowRoots = [];
+            for (var shadowRootBackendId of shadowRootBackendIds) {
+              var resolvedShadowRoot = await client.send('DOM.resolveNode', {
+                backendNodeId: shadowRootBackendId,
+                contextId: context.delegate._contextId
+              });
+              shadowRoots.push(new dom.ElementHandle(context, resolvedShadowRoot.object.objectId));
+            }
+
+            for (var shadowRoot of shadowRoots) {
+              const shadowElements = await shadowRoot.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+                const elements = injected.querySelectorAll(parsed, node);
+                if (callId) injected.markTargetElements(new Set(elements), callId);
+                return elements
+              }, {
+                parsed: parsedEdits,
+                callId: progress.metadata.id
+              });
+
+              const shadowElementsAmount = await shadowElements.getProperty("length");
+              queryingElements.push([shadowElements, shadowElementsAmount, shadowRoot]);
+            }
+          }
+
+          // Document Root Elements (not in CSR)
+          const rootElements = await scope.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+            const elements = injected.querySelectorAll(parsed, node);
+            if (callId) injected.markTargetElements(new Set(elements), callId);
+            return elements
+          }, {
+            parsed: parsedEdits,
+            callId: progress.metadata.id
+          });
+          const rootElementsAmount = await rootElements.getProperty("length");
+          queryingElements.push([rootElements, rootElementsAmount, resolved.injected]);
+
+          // Querying and Sorting the elements by their backendNodeId
+          for (var queryedElement of queryingElements) {
+            var elementsToCheck = queryedElement[0];
+            var elementsAmount = await queryedElement[1].jsonValue();
+            var parentNode = queryedElement[2];
+            for (var i = 0; i < elementsAmount; i++) {
+              if (parentNode.constructor.name == "ElementHandle") {
+                var elementToCheck = await parentNode.evaluateHandleInUtility(([injected, node, { index, elementsToCheck }]) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+              } else {
+                var elementToCheck = await parentNode.evaluateHandle((injected, { index, elementsToCheck }) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+              }
+              // For other Functions/Utilities
+              elementToCheck.parentNode = parentNode;
+              var resolvedElement = await client.send('DOM.describeNode', {
+                objectId: elementToCheck._objectId,
+                depth: -1,
+              });
+              // Note: Possible Bug, Maybe well actually have to check the Documents Node Position instead of using the backendNodeId
+              elementToCheck.backendNodeId = resolvedElement.node.backendNodeId;
+              elements.push(elementToCheck);
+            }
+          }
+        }
+      }
+      // Setting currentScopingElements to the elements we just queried
+      currentScopingElements = [];
+      for (var element of elements) {
+        var elemIndex = element.backendNodeId;
+        // Sorting the Elements by their occourance in the DOM
+        var elemPos = elementsIndexes.findIndex(index => index > elemIndex);
+
+        // Sort the elements by their backendNodeId
+        if (elemPos === -1) {
+          currentScopingElements.push(element);
+          elementsIndexes.push(elemIndex);
+        } else {
+          currentScopingElements.splice(elemPos, 0, element);
+          elementsIndexes.splice(elemPos, 0, elemIndex);
+        }
+      }
+    }
+    return currentScopingElements;
+  }
 }
 
 class SignalBarrier {
diff -ruN playwright/packages/playwright-core/src/server/javascript.ts patchright/packages/playwright-core/src/server/javascript.ts
--- playwright/packages/playwright-core/src/server/javascript.ts	2025-03-19 15:32:27.012465640 +0000
+++ patchright/packages/playwright-core/src/server/javascript.ts	2025-03-19 15:32:33.832521869 +0000
@@ -149,17 +149,33 @@
     return evaluate(this._context, false /* returnByValue */, pageFunction, this, arg);
   }
 
-  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any) {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: true }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean) {
+    let context = this._context;
+      if (context.constructor.name === "FrameExecutionContext") {
+          const frame = context.frame;
+          if (frame) {
+              if (isolatedContext) context = await frame._utilityContext();
+              else if (!isolatedContext) context = await frame._mainContext();
+          }
+      }
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: true }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
 
-  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any): Promise<JSHandle<any>> {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: false }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean): Promise<JSHandle<any>> {
+    let context = this._context;
+      if (this._context.constructor.name === "FrameExecutionContext") {
+          const frame = this._context.frame;
+          if (frame) {
+              if (isolatedContext) context = await frame._utilityContext();
+              else if (!isolatedContext) context = await frame._mainContext();
+          }
+      }
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: false }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
 
   async getProperty(propertyName: string): Promise<JSHandle> {
     const objectHandle = await this.evaluateHandle((object: any, propertyName) => {
diff -ruN playwright/packages/playwright-core/src/server/page.ts patchright/packages/playwright-core/src/server/page.ts
--- playwright/packages/playwright-core/src/server/page.ts	2025-03-19 15:32:27.013465649 +0000
+++ patchright/packages/playwright-core/src/server/page.ts	2025-03-19 15:32:33.832521869 +0000
@@ -60,7 +60,7 @@
   goForward(): Promise<boolean>;
   requestGC(): Promise<void>;
   addInitScript(initScript: InitScript): Promise<void>;
-  removeNonInternalInitScripts(): Promise<void>;
+  removeInitScripts(): Promise<void>;
   closePage(runBeforeUnload: boolean): Promise<void>;
 
   navigateFrame(frame: frames.Frame, url: string, referrer: string | undefined): Promise<frames.GotoResult>;
@@ -351,15 +351,15 @@
       throw new Error(`Function "${name}" has been already registered in the browser context`);
     const binding = new PageBinding(name, playwrightBinding, needsHandle);
     this._pageBindings.set(name, binding);
-    await this._delegate.addInitScript(binding.initScript);
-    await Promise.all(this.frames().map(frame => frame.evaluateExpression(binding.initScript.source).catch(e => {})));
+    await this._delegate.exposeBinding(binding);
   }
 
   async _removeExposedBindings() {
-    for (const [key, binding] of this._pageBindings) {
-      if (!binding.internal)
+    for (const key of this._pageBindings.keys()) {
+      if (!key.startsWith('__pw'))
         this._pageBindings.delete(key);
     }
+    await this._delegate.removeExposedBindings();
   }
 
   setExtraHTTPHeaders(headers: types.HeadersArray) {
@@ -576,8 +576,8 @@
   }
 
   async _removeInitScripts() {
-    this.initScripts = this.initScripts.filter(script => script.internal);
-    await this._delegate.removeNonInternalInitScripts();
+    this.initScripts.splice(0, this.initScripts.length);
+    await this._delegate.removeInitScripts();
   }
 
   needsRequestInterception(): boolean {
@@ -769,11 +769,6 @@
       this._browserContext.addVisitedOrigin(origin);
   }
 
-  allInitScripts() {
-    const bindings = [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
-    return [...bindings.map(binding => binding.initScript), ...this._browserContext.initScripts, ...this.initScripts];
-  }
-
   getBinding(name: string) {
     return this._pageBindings.get(name) || this._browserContext._pageBindings.get(name);
   }
@@ -810,6 +805,10 @@
   markAsServerSideOnly() {
     this._isServerSideOnly = true;
   }
+
+  allBindings() {
+    return [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
+  }
 }
 
 export class Worker extends SdkObject {
@@ -847,13 +846,29 @@
     this.openScope.close(new Error('Worker closed'));
   }
 
-  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: true, isFunction }, arg);
-  }
+  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
+    let context = await this._executionContextPromise;
+      if (context.constructor.name === "FrameExecutionContext") {
+          const frame = context.frame;
+          if (frame) {
+              if (isolatedContext) context = await frame._utilityContext();
+              else if (!isolatedContext) context = await frame._mainContext();
+          }
+      }
+      return js.evaluateExpression(context, expression, { returnByValue: true, isFunction }, arg);
+    }
 
-  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: false, isFunction }, arg);
-  }
+  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
+    let context = await this._executionContextPromise;
+      if (this._context.constructor.name === "FrameExecutionContext") {
+          const frame = this._context.frame;
+          if (frame) {
+              if (isolatedContext) context = await frame._utilityContext();
+              else if (!isolatedContext) context = await frame._mainContext();
+          }
+      }
+      return js.evaluateExpression(context, expression, { returnByValue: false, isFunction }, arg);
+    }
 }
 
 type BindingPayload = {
@@ -863,20 +878,16 @@
 };
 
 export class PageBinding {
-  static kPlaywrightBinding = '__playwright__binding__';
-
   readonly name: string;
   readonly playwrightFunction: frames.FunctionWithSource;
-  readonly initScript: InitScript;
   readonly needsHandle: boolean;
   readonly internal: boolean;
 
   constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean) {
     this.name = name;
     this.playwrightFunction = playwrightFunction;
-    this.initScript = new InitScript(`(${addPageBinding.toString()})(${JSON.stringify(PageBinding.kPlaywrightBinding)}, ${JSON.stringify(name)}, ${needsHandle}, (${source})())`, true /* internal */);
+    this.source = `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle}, (${source})())`;
     this.needsHandle = needsHandle;
-    this.internal = name.startsWith('__pw');
   }
 
   static async dispatch(page: Page, payload: string, context: dom.FrameExecutionContext) {
@@ -916,10 +927,13 @@
       callbacks.delete(arg.seq);
     }
   }
+
+  readonly source: string;
 }
 
-function addPageBinding(playwrightBinding: string, bindingName: string, needsHandle: boolean, utilityScriptSerializers: ReturnType<typeof source>) {
-  const binding = (globalThis as any)[playwrightBinding];
+function addPageBinding(bindingName: string, needsHandle: boolean, utilityScriptSerializers: ReturnType<typeof source>) {
+  const binding = (globalThis as any)[bindingName];
+  if (binding && binding.toString().startsWith("(...args) => {")) return
   (globalThis as any)[bindingName] = (...args: any[]) => {
     const me = (globalThis as any)[bindingName];
     if (needsHandle && args.slice(1).some(arg => arg !== undefined))
@@ -953,7 +967,6 @@
     binding(JSON.stringify(payload));
     return promise;
   };
-  (globalThis as any)[bindingName].__installed = true;
 }
 
 export class InitScript {
@@ -963,14 +976,7 @@
 
   constructor(source: string, internal?: boolean, name?: string) {
     const guid = createGuid();
-    this.source = `(() => {
-      globalThis.__pwInitScripts = globalThis.__pwInitScripts || {};
-      const hasInitScript = globalThis.__pwInitScripts[${JSON.stringify(guid)}];
-      if (hasInitScript)
-        return;
-      globalThis.__pwInitScripts[${JSON.stringify(guid)}] = true;
-      ${source}
-    })();`;
+    this.source = `(() => { ${source} })();`;
     this.internal = !!internal;
     this.name = name;
   }
diff -ruN playwright/packages/playwright-core/src/server/webkit/wkPage.ts patchright/packages/playwright-core/src/server/webkit/wkPage.ts
--- playwright/packages/playwright-core/src/server/webkit/wkPage.ts	2025-03-19 15:32:27.016465675 +0000
+++ patchright/packages/playwright-core/src/server/webkit/wkPage.ts	2025-03-19 15:32:33.835521893 +0000
@@ -768,7 +768,7 @@
     await this._updateBootstrapScript();
   }
 
-  async removeNonInternalInitScripts() {
+  async removeInitScripts() {
     await this._updateBootstrapScript();
   }
 
diff -ruN playwright/packages/protocol/src/channels.d.ts patchright/packages/protocol/src/channels.d.ts
--- playwright/packages/protocol/src/channels.d.ts	2025-03-19 15:32:27.090466313 +0000
+++ patchright/packages/protocol/src/channels.d.ts	2025-03-19 15:32:33.831521861 +0000
@@ -2809,6 +2809,7 @@
   expression: string,
   isFunction?: boolean,
   arg: SerializedArgument,
+  isolatedContext?: boolean;
 };
 export type FrameEvaluateExpressionOptions = {
   isFunction?: boolean,
@@ -2820,6 +2821,7 @@
   expression: string,
   isFunction?: boolean,
   arg: SerializedArgument,
+  isolatedContext?: boolean;
 };
 export type FrameEvaluateExpressionHandleOptions = {
   isFunction?: boolean,
@@ -3269,6 +3271,7 @@
   expression: string,
   isFunction?: boolean,
   arg: SerializedArgument,
+  isolatedContext?: boolean;
 };
 export type WorkerEvaluateExpressionOptions = {
   isFunction?: boolean,
@@ -3280,6 +3283,7 @@
   expression: string,
   isFunction?: boolean,
   arg: SerializedArgument,
+  isolatedContext?: boolean;
 };
 export type WorkerEvaluateExpressionHandleOptions = {
   isFunction?: boolean,
@@ -3318,6 +3322,7 @@
   expression: string,
   isFunction?: boolean,
   arg: SerializedArgument,
+  isolatedContext?: boolean;
 };
 export type JSHandleEvaluateExpressionOptions = {
   isFunction?: boolean,
