# NOTE: This patch file is generated automatically and is not used, it is only for documentation. The driver is actually patched using [patchright_driver_patch](https://github.com/Kaliiiiiiiiii-Vinyzu/patchright/blob/main/patchright_driver_patch.js), see [the workflow](https://github.com/Kaliiiiiiiiii-Vinyzu/patchright/blob/main/.github/workflows/patchright_workflow.yml)
diff -ruN playwright/node_modules/playwright-core/src/server/browserContext.ts patchright/node_modules/playwright-core/src/server/browserContext.ts
---
+++
@@ -146,7 +146,7 @@
       `);
     }
     if (this._options.serviceWorkers === 'block')
-      await this.addInitScript(undefined, `\nif (navigator.serviceWorker) navigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };\n`);
+      await this.addInitScript(undefined, `navigator.serviceWorker.register = async () => { };`);
 
     if (this._options.permissions)
       await this.grantPermissions(this._options.permissions);
@@ -326,27 +326,19 @@
       if (page.getBinding(name))
         throw new Error(`Function "${name}" has been already registered in one of the pages`);
     }
-    await progress.race(this.exposePlaywrightBindingIfNeeded());
     const binding = new PageBinding(name, playwrightBinding, needsHandle);
     binding.forClient = forClient;
     this._pageBindings.set(name, binding);
-    try {
-      await progress.race(this.doAddInitScript(binding.initScript));
-      await progress.race(this.safeNonStallingEvaluateInAllFrames(binding.initScript.source, 'main'));
-      return binding;
-    } catch (error) {
-      this._pageBindings.delete(name);
-      throw error;
-    }
+    await this.doExposeBinding(binding);
   }
 
   async removeExposedBindings(bindings: PageBinding[]) {
-    bindings = bindings.filter(binding => this._pageBindings.get(binding.name) === binding);
-    for (const binding of bindings)
-      this._pageBindings.delete(binding.name);
-    await this.doRemoveInitScripts(bindings.map(binding => binding.initScript));
-    const cleanup = bindings.map(binding => `{ ${binding.cleanupScript} };\n`).join('');
-    await this.safeNonStallingEvaluateInAllFrames(cleanup, 'main');
+
+          for (const key of this._pageBindings.keys()) {
+            if (!key.startsWith('__pw')) this._pageBindings.delete(key);
+          }
+          await this.doRemoveExposedBindings();
+        
   }
 
   async grantPermissions(permissions: string[], origin?: string) {
@@ -463,9 +455,10 @@
   }
 
   async removeInitScripts(initScripts: InitScript[]) {
-    const set = new Set(initScripts);
-    this.initScripts = this.initScripts.filter(script => !set.has(script));
-    await this.doRemoveInitScripts(initScripts);
+
+          this.initScripts.splice(0, this.initScripts.length);
+          await this.doRemoveInitScripts();
+          
   }
 
   async addRequestInterceptor(progress: Progress, handler: network.RouteHandler): Promise<void> {
@@ -815,4 +808,5 @@
   strictSelectors: false,
   serviceWorkers: 'allow',
   locale: 'en-US',
+  focusControl: false
 };
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/chromiumSwitches.ts patchright/node_modules/playwright-core/src/server/chromium/chromiumSwitches.ts
---
+++
@@ -51,26 +51,16 @@
   '--disable-field-trial-config', // https://source.chromium.org/chromium/chromium/src/+/main:testing/variations/README.md
   '--disable-background-networking',
   '--disable-background-timer-throttling',
-  '--disable-backgrounding-occluded-windows',
-  '--disable-back-forward-cache', // Avoids surprises like main request not being intercepted during page.goBack().
-  '--disable-breakpad',
-  '--disable-client-side-phishing-detection',
-  '--disable-component-extensions-with-background-pages',
-  '--disable-component-update', // Avoids unneeded network activity after startup.
+  '--disable-backgrounding-occluded-windows', // Avoids surprises like main request not being intercepted during page.goBack().
+  '--disable-breakpad', // Avoids unneeded network activity after startup.
   '--no-default-browser-check',
-  '--disable-default-apps',
   '--disable-dev-shm-usage',
-  '--disable-extensions',
   '--disable-features=' + disabledFeatures(assistantMode).join(','),
   process.env.PLAYWRIGHT_LEGACY_SCREENSHOT ? '' : '--enable-features=CDPScreenshotNewSurface',
-  '--allow-pre-commit-input',
   '--disable-hang-monitor',
-  '--disable-ipc-flooding-protection',
-  '--disable-popup-blocking',
   '--disable-prompt-on-repost',
   '--disable-renderer-backgrounding',
   '--force-color-profile=srgb',
-  '--metrics-recording-only',
   '--no-first-run',
   '--password-store=basic',
   '--use-mock-keychain',
@@ -79,11 +69,8 @@
   '--export-tagged-pdf',
   // https://chromium-review.googlesource.com/c/chromium/src/+/4853540
   '--disable-search-engine-choice-screen',
-  // https://issues.chromium.org/41491762
-  '--unsafely-disable-devtools-self-xss-warnings',
   // Edge can potentially restart on Windows (msRelaunchNoCompatLayer) which looses its file descriptors (stdout/stderr) and CDP (3/4). Disable until fixed upstream.
   '--edge-skip-compat-layer-relaunch',
-  assistantMode ? '' : '--enable-automation',
   // This disables Chrome for Testing infobar that is visible in the persistent context.
   // The switch is ignored everywhere else, including Chromium/Chrome/Edge.
   '--disable-infobars',
@@ -91,4 +78,5 @@
   '--disable-search-engine-choice-screen',
   // Prevents the "three dots" menu crash in IdentityManager::HasPrimaryAccount for ephemeral contexts.
   android ? '' : '--disable-sync',
+  '--disable-blink-features=AutomationControlled'
 ].filter(Boolean);
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/crBrowser.ts patchright/node_modules/playwright-core/src/server/chromium/crBrowser.ts
---
+++
@@ -501,8 +501,9 @@
   }
 
   async doRemoveInitScripts(initScripts: InitScript[]) {
-    for (const page of this.pages())
-      await (page.delegate as CRPage).removeInitScripts(initScripts);
+
+          for (const page of this.pages()) await (page.delegate as CRPage).removeInitScripts();
+        
   }
 
   async doUpdateRequestInterception(): Promise<void> {
@@ -595,4 +596,16 @@
     const rootSession = await this._browser._clientRootSession();
     return rootSession.attachToTarget(targetId);
   }
+
+  async doExposeBinding(binding: PageBinding) {
+
+          for (const page of this.pages()) await (page.delegate as CRPage).exposeBinding(binding);
+        
+  }
+
+  async doRemoveExposedBindings() {
+
+          for (const page of this.pages()) await (page.delegate as CRPage).removeExposedBindings();
+        
+  }
 }
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/crDevTools.ts patchright/node_modules/playwright-core/src/server/chromium/crDevTools.ts
---
+++
@@ -67,7 +67,6 @@
       }).catch(e => null);
     });
     Promise.all([
-      session.send('Runtime.enable'),
       session.send('Runtime.addBinding', { name: kBindingName }),
       session.send('Page.enable'),
       session.send('Page.addScriptToEvaluateOnNewDocument', { source: `
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/crNetworkManager.ts patchright/node_modules/playwright-core/src/server/chromium/crNetworkManager.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -156,7 +158,7 @@
     const enabled = this._protocolRequestInterceptionEnabled;
     if (initial && !enabled)
       return;
-    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: enabled });
+    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: false });
     let fetchPromise = Promise.resolve<any>(undefined);
     if (!info.workerFrame) {
       if (enabled)
@@ -238,6 +240,7 @@
   }
 
   _onRequestPaused(sessionInfo: SessionInfo, event: Protocol.Fetch.requestPausedPayload) {
+    if (this._alreadyTrackedNetworkIds.has(event.networkId)) return;
     if (!event.networkId) {
       // Fetch without networkId means that request was not recognized by inspector, and
       // it will never receive Network.requestWillBeSent. Continue the request to not affect it.
@@ -276,6 +279,7 @@
   }
 
   _onRequest(requestWillBeSentSessionInfo: SessionInfo, requestWillBeSentEvent: Protocol.Network.requestWillBeSentPayload, requestPausedSessionInfo: SessionInfo | undefined, requestPausedEvent: Protocol.Fetch.requestPausedPayload | undefined) {
+    if (this._alreadyTrackedNetworkIds.has(requestWillBeSentEvent.initiator.requestId)) return;
     if (requestWillBeSentEvent.request.url.startsWith('data:'))
       return;
     let redirectedFrom: InterceptableRequest | null = null;
@@ -342,7 +346,7 @@
         headersOverride = redirectedFrom?._originalRequestRoute?._alreadyContinuedParams?.headers;
         requestPausedSessionInfo!.session._sendMayFail('Fetch.continueRequest', { requestId: requestPausedEvent.requestId, headers: headersOverride });
       } else {
-        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId);
+        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId, this._page, requestPausedEvent.networkId, this);
       }
     }
     const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === 'Document';
@@ -553,6 +557,8 @@
     if (request.session !== sessionInfo.session && !sessionInfo.isMain && (request._documentId === request._requestId || sessionInfo.workerFrame))
       request.session = sessionInfo.session;
   }
+
+  _alreadyTrackedNetworkIds: Set<string> = new Set();
 }
 
 class InterceptableRequest {
@@ -612,38 +618,189 @@
   _alreadyContinuedParams: Protocol.Fetch.continueRequestParameters | undefined;
   _fulfilled: boolean = false;
 
-  constructor(session: CRSession, interceptionId: string) {
+  constructor(session: CRSession, interceptionId: string, page, networkId, sessionManager) {
+    this._sessionManager = void 0;
+    this._networkId = void 0;
+    this._page = void 0;
     this._session = session;
     this._interceptionId = interceptionId;
+    this._page = page;
+    this._networkId = networkId;
+    this._sessionManager = sessionManager;
+    eventsHelper.addEventListener(this._session, 'Fetch.requestPaused', async e => await this._networkRequestIntercepted(e));
   }
 
   async continue(overrides: types.NormalizedContinueOverrides): Promise<void> {
-    this._alreadyContinuedParams = {
-      requestId: this._interceptionId!,
-      url: overrides.url,
-      headers: overrides.headers,
-      method: overrides.method,
-      postData: overrides.postData ? overrides.postData.toString('base64') : undefined
-    };
-    await catchDisallowedErrors(async () => {
-      await this._session.send('Fetch.continueRequest', this._alreadyContinuedParams);
-    });
+
+          this._alreadyContinuedParams = {
+            requestId: this._interceptionId,
+            url: overrides.url,
+            headers: overrides.headers,
+            method: overrides.method,
+            postData: overrides.postData ? overrides.postData.toString('base64') : undefined,
+          };
+          if (overrides.url && (overrides.url === 'http://patchright-init-script-inject.internal/' || overrides.url === 'https://patchright-init-script-inject.internal/')) {
+            await catchDisallowedErrors(async () => {
+              this._sessionManager._alreadyTrackedNetworkIds.add(this._networkId);
+              this._session._sendMayFail('Fetch.continueRequest', { requestId: this._interceptionId, interceptResponse: true });
+            });
+          } else {
+            await catchDisallowedErrors(async () => {
+              await this._session._sendMayFail('Fetch.continueRequest', this._alreadyContinuedParams);
+            });
+          }
+        
   }
 
   async fulfill(response: types.NormalizedFulfillResponse) {
-    this._fulfilled = true;
-    const body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');
 
-    const responseHeaders = splitSetCookieHeader(response.headers);
-    await catchDisallowedErrors(async () => {
-      await this._session.send('Fetch.fulfillRequest', {
-        requestId: this._interceptionId!,
-        responseCode: response.status,
-        responsePhrase: network.statusText(response.status),
-        responseHeaders,
-        body,
-      });
-    });
+          const isTextHtml = response.headers.some((header) => header.name.toLowerCase() === "content-type" && header.value.includes("text/html"));
+          var allInjections = [...this._page.delegate._mainFrameSession._evaluateOnNewDocumentScripts];
+          for (const binding of this._page.delegate._browserContext._pageBindings.values()) {
+            if (!allInjections.includes(binding)) allInjections.push(binding);
+          }
+          if (isTextHtml && allInjections.length) {
+            let useNonce = false;
+            let scriptNonce = null;
+            // Decode body if needed
+            if (response.isBase64) {
+              response.isBase64 = false;
+              response.body = Buffer.from(response.body, "base64").toString("utf-8");
+            }
+            // === CSP Detection and Fixing ===
+            const cspHeaderNames = ["content-security-policy", "content-security-policy-report-only"];
+            // Fix CSP in headers
+            for (let i = 0; i < response.headers.length; i++) {
+              const headerName = response.headers[i].name.toLowerCase();
+              if (cspHeaderNames.includes(headerName)) {
+                const originalCsp = response.headers[i].value || "";
+                // Extract nonce if present
+                if (!useNonce) {
+                  const nonceMatch = originalCsp.match(/script-src[^;]*'nonce-([^'"\s;]+)'/i);
+                  if (nonceMatch && nonceMatch[1]) {
+                    scriptNonce = nonceMatch[1];
+                    useNonce = true;
+                  }
+                }
+                
+                const fixedCsp = this._fixCSP(originalCsp, scriptNonce);
+                response.headers[i].value = fixedCsp;
+              }
+            }
+            
+            // Fix CSP in meta tags
+            if (typeof response.body === "string" && response.body.length) {
+              response.body = response.body.replace(
+                /<meta[^>]*http-equiv=(?:"|')?Content-Security-Policy(?:"|')?[^>]*>/gi,
+                (match) => {
+                  const contentMatch = match.match(/content=(?:"|')([^"']*)(?:"|')/i);
+                  if (contentMatch && contentMatch[1]) {
+                    let originalCsp = contentMatch[1];
+                    
+                    // Decode HTML entities
+                    originalCsp = originalCsp.replace(/&amp;/g, '&')  // Must be first!
+                        .replace(/&lt;/g, '<')
+                        .replace(/&gt;/g, '>')
+                        .replace(/&quot;/g, '"')
+                        .replace(/&#x27;/g, "'")
+                        .replace(/&#x22;/g, '"')
+                        .replace(/&nbsp;/g, ' ')
+                        .replace(/&#(d+);/g, (match, dec) => String.fromCharCode(dec))
+                        .replace(/&#x([0-9a-fA-F]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)));
+                    
+                    // Extract nonce if not already found
+                    if (!useNonce) {
+                      const nonceMatch = originalCsp.match(/script-src[^;]*'nonce-([^'"\s;]+)'/i);
+                      if (nonceMatch && nonceMatch[1]) {
+                        scriptNonce = nonceMatch[1];
+                        useNonce = true;
+                      }
+                    }
+                    
+                    const fixedCsp = this._fixCSP(originalCsp, scriptNonce);
+                    // Re-encode for HTML
+                    const encodedCsp = fixedCsp.replace(/'/g, '&#x27;').replace(/"/g, '&#x22;');
+                    return match.replace(contentMatch[1], encodedCsp);
+                  }
+                  return match;
+                }
+              );
+            }
+            
+            // Build injection HTML - only use nonce if one was found in existing CSP
+            let injectionHTML = "";
+            allInjections.forEach((script) => {
+              let scriptId = crypto.randomBytes(22).toString("hex");
+              let scriptSource = script.source || script;
+              const nonceAttr = useNonce ? `nonce="${scriptNonce}"` : '';
+              injectionHTML += `<script class="${this._page.delegate.initScriptTag}" ${nonceAttr} id="${scriptId}" type="text/javascript">document.getElementById("${scriptId}")?.remove();${scriptSource}</script>`;
+            });
+
+            // Inject at END of <head>
+            const lower = response.body.toLowerCase();
+            const headStartIndex = lower.indexOf("<head");
+            if (headStartIndex !== -1) {
+              const headEndTagIndex = lower.indexOf("</head>", headStartIndex);
+              if (headEndTagIndex !== -1) {
+                // Find the head opening tag end
+                const headOpenEnd = response.body.indexOf(">", headStartIndex) + 1;
+                const headContent = response.body.slice(headOpenEnd, headEndTagIndex);
+                const headContentLower = headContent.toLowerCase();
+                
+                // Look for the first <script> tag in the head content
+                const firstScriptIndex = headContentLower.indexOf("<script");
+                
+                if (firstScriptIndex !== -1) {
+                  // Inject before the first script tag
+                  const insertPosition = headOpenEnd + firstScriptIndex;
+                  response.body =
+                    response.body.slice(0, insertPosition) +
+                    injectionHTML +
+                    response.body.slice(insertPosition);
+                } else {
+                  // No script tags found, inject at the end of head content (before </head>)
+                  response.body =
+                    response.body.slice(0, headEndTagIndex) +
+                    injectionHTML +
+                    response.body.slice(headEndTagIndex);
+                }
+              } else {
+                const headStartTagEnd = response.body.indexOf(">", headStartIndex) + 1;
+                response.body =
+                  response.body.slice(0, headStartTagEnd) +
+                  injectionHTML +
+                  response.body.slice(headStartTagEnd);
+              }
+            } else {
+              const doctypeIndex = lower.indexOf("<!doctype");
+              if (doctypeIndex === 0) {
+                const doctypeEnd = response.body.indexOf(">", doctypeIndex) + 1;
+                response.body = response.body.slice(0, doctypeEnd) + injectionHTML + response.body.slice(doctypeEnd);
+              } else {
+                const htmlIndex = lower.indexOf("<html");
+                if (htmlIndex !== -1) {
+                  const htmlTagEnd = response.body.indexOf(">", htmlIndex) + 1;
+                  response.body =
+                    response.body.slice(0, htmlTagEnd) + `<head>${injectionHTML}</head>` + response.body.slice(htmlTagEnd);
+                } else {
+                  response.body = injectionHTML + response.body;
+                }
+              }
+            }
+          }
+          this._fulfilled = true;
+          const body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
+          const responseHeaders = splitSetCookieHeader(response.headers);
+          await catchDisallowedErrors(async () => {
+            await this._session.send("Fetch.fulfillRequest", {
+              requestId: response.interceptionId ? response.interceptionId : this._interceptionId,
+              responseCode: response.status,
+              responsePhrase: network.statusText(response.status),
+              responseHeaders,
+              body
+            });
+          });
+        
   }
 
   async abort(errorCode: string = 'failed') {
@@ -656,6 +813,155 @@
       });
     });
   }
+
+  _fixCSP(csp, scriptNonce) {
+
+          if (!csp || typeof csp !== 'string') return csp;
+
+          // Split by semicolons and clean up
+          const directives = csp.split(';')
+            .map(d => d.trim())
+            .filter(d => d && d.length > 0);
+
+          const fixedDirectives = [];
+          let hasScriptSrc = false;
+
+          for (let directive of directives) {
+            // Skip empty directives
+            if (!directive.trim()) continue;
+
+            // Improved directive parsing to handle more edge cases
+            const directiveMatch = directive.match(/^([a-zA-Z-]+)\s+(.*)$/);
+            if (!directiveMatch) {
+              fixedDirectives.push(directive);
+              continue;
+            }
+
+            const directiveName = directiveMatch[1].toLowerCase();
+            const directiveValues = directiveMatch[2].split(/\s+/).filter(v => v.length > 0);
+
+            switch (directiveName) {
+              case 'script-src':
+                hasScriptSrc = true;
+                let values = [...directiveValues];
+
+                // Add nonce if we have one and it's not already present
+                if (scriptNonce && !values.some(v => v.includes(`nonce-${scriptNonce}`))) {
+                  values.push(`'nonce-${scriptNonce}'`);
+                }
+
+                // Add 'unsafe-eval' if not present
+                if (!values.includes("'unsafe-eval'")) {
+                  values.push("'unsafe-eval'");
+                }
+
+                // Add unsafe-inline if not present and no nonce is being used
+                if (!values.includes("'unsafe-inline'") && !scriptNonce) {
+                  values.push("'unsafe-inline'");
+                }
+
+                // Add wildcard for external scripts if not already present
+                if (!values.includes("*") && !values.includes("'self'") && !values.some(v => v.includes("https:"))) {
+                  values.push("*");
+                }
+
+                fixedDirectives.push(`script-src ${values.join(' ')}`);
+                break;
+
+              case 'style-src':
+                let styleValues = [...directiveValues];
+                // Add 'unsafe-inline' for styles if not present
+                if (!styleValues.includes("'unsafe-inline'")) {
+                  styleValues.push("'unsafe-inline'");
+                }
+                fixedDirectives.push(`style-src ${styleValues.join(' ')}`);
+                break;
+
+              case 'img-src':
+                let imgValues = [...directiveValues];
+                // Allow data: URLs for images if not already allowed
+                if (!imgValues.includes("data:") && !imgValues.includes("*")) {
+                  imgValues.push("data:");
+                }
+                fixedDirectives.push(`img-src ${imgValues.join(' ')}`);
+                break;
+
+              case 'font-src':
+                let fontValues = [...directiveValues];
+                // Allow data: URLs for fonts if not already allowed
+                if (!fontValues.includes("data:") && !fontValues.includes("*")) {
+                  fontValues.push("data:");
+                }
+                fixedDirectives.push(`font-src ${fontValues.join(' ')}`);
+                break;
+
+              case 'connect-src':
+                let connectValues = [...directiveValues];
+                // Allow WebSocket connections if not already allowed
+                const hasWs = connectValues.some(v => v.includes("ws:") || v.includes("wss:") || v === "*");
+                if (!hasWs) {
+                  connectValues.push("ws:", "wss:");
+                }
+                fixedDirectives.push(`connect-src ${connectValues.join(' ')}`);
+                break;
+
+              case 'frame-ancestors':
+                let frameAncestorValues = [...directiveValues];
+                // If completely blocked with 'none', allow 'self' at least
+                if (frameAncestorValues.includes("'none'")) {
+                  frameAncestorValues = ["'self'"];
+                }
+                fixedDirectives.push(`frame-ancestors ${frameAncestorValues.join(' ')}`);
+                break;
+
+              default:
+                // Keep other directives as-is
+                fixedDirectives.push(directive);
+                break;
+            }
+          }
+
+          // Add script-src if it doesn't exist (for our injected scripts)
+          if (!hasScriptSrc) {
+            if (scriptNonce) {
+              fixedDirectives.push(`script-src 'self' 'unsafe-eval' 'nonce-${scriptNonce}' *`);
+            } else {
+              fixedDirectives.push(`script-src 'self' 'unsafe-eval' 'unsafe-inline' *`);
+            }
+          }
+
+          return fixedDirectives.join('; ');
+        
+  }
+
+  async _networkRequestIntercepted(event) {
+
+          if (event.resourceType !== 'Document') {
+            /*await catchDisallowedErrors(async () => {
+              await this._session.send('Fetch.continueRequest', { requestId: event.requestId });
+            });*/
+            return;
+          }
+          if (this._networkId != event.networkId || !this._sessionManager._alreadyTrackedNetworkIds.has(event.networkId)) return;
+          try {
+            if (event.responseStatusCode >= 301 && event.responseStatusCode <= 308  || (event.redirectedRequestId && !event.responseStatusCode)) {
+              await this._session.send('Fetch.continueRequest', { requestId: event.requestId, interceptResponse: true });
+            } else {
+              const responseBody = await this._session.send('Fetch.getResponseBody', { requestId: event.requestId });
+              await this.fulfill({
+                headers: event.responseHeaders,
+                isBase64: true,
+                body: responseBody.body,
+                status: event.responseStatusCode,
+                interceptionId: event.requestId,
+                resourceType: event.resourceType,
+              })
+            }
+          } catch (error) {
+            await this._session._sendMayFail('Fetch.continueRequest', { requestId: event.requestId });
+          }
+        
+  }
 }
 
 // In certain cases, protocol will return error if the request was already canceled
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/crPage.ts patchright/node_modules/playwright-core/src/server/chromium/crPage.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -99,7 +101,8 @@
     this.updateOffline();
     this.updateExtraHTTPHeaders();
     this.updateHttpCredentials();
-    this.updateRequestInterception();
+    this._networkManager.setRequestInterception(true);
+        this.initScriptTag = crypto.randomBytes(20).toString('hex');
     this._mainFrameSession = new FrameSession(this, client, targetId, null);
     this._sessions.set(targetId, this._mainFrameSession);
     if (opener && !browserContext._options.noDefaultViewport) {
@@ -228,6 +231,7 @@
   }
 
   async addInitScript(initScript: InitScript, world: types.World = 'main'): Promise<void> {
+    this._page.initScripts.push(initScript);
     await this._forAllFrameSessions(frame => frame._evaluateOnNewDocument(initScript, world));
   }
 
@@ -361,6 +365,19 @@
   shouldToggleStyleSheetToSyncAnimations(): boolean {
     return false;
   }
+
+  async exposeBinding(binding) {
+
+          await this._forAllFrameSessions(frame => frame._initBinding(binding));
+          await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(binding.source).catch(e => {})));
+        
+  }
+
+  async removeExposedBindings() {
+
+          await this._forAllFrameSessions(frame => frame._removeExposedBindings());
+        
+  }
 }
 
 class FrameSession {
@@ -488,17 +505,6 @@
         this._bufferedAttachedToTargetEvents = undefined;
         for (const event of attachedToTargetEvents)
           this._onAttachedToTarget(event);
-
-        const localFrames = this._isMainFrame() ? this._page.frames() : [this._page.frameManager.frame(this._targetId)!];
-        for (const frame of localFrames) {
-          // Note: frames might be removed before we send these.
-          this._client._sendMayFail('Page.createIsolatedWorld', {
-            frameId: frame._id,
-            grantUniveralAccess: true,
-            worldName: this._crPage.utilityWorldName,
-          });
-        }
-
         const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ':';
         if (isInitialEmptyPage) {
           // Ignore lifecycle events, worlds and bindings for the initial empty page. It is never the final page
@@ -508,13 +514,22 @@
             this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
           });
         } else {
+
+                  const localFrames = this._isMainFrame() ? this._page.frames() : [this._page.frameManager.frame(this._targetId)!];
+                    for (const frame of localFrames) {
+                      this._page.frameManager.frame(frame._id)._context("utility");
+                      for (const binding of this._crPage._browserContext._pageBindings.values())
+                        frame.evaluateExpression(binding.source).catch(e => {});
+                      for (const source of this._crPage._browserContext.initScripts)
+                        frame.evaluateExpression(source).catch(e => {});
+                    }
+                  
           this._firstNonInitialNavigationCommittedFulfill();
           this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
         }
       }),
       this._client.send('Log.enable', {}),
       lifecycleEventsEnabled = this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-      this._client.send('Runtime.enable', {}),
       this._client.send('Page.addScriptToEvaluateOnNewDocument', {
         source: '',
         worldName: this._crPage.utilityWorldName,
@@ -525,8 +540,10 @@
     if (!this._page.isStorageStatePage) {
       if (this._crPage._browserContext.needsPlaywrightBinding())
         promises.push(this.exposePlaywrightBinding());
-      if (this._isMainFrame())
-        promises.push(this._client.send('Emulation.setFocusEmulationEnabled', { enabled: true }));
+      
+              if (this._isMainFrame() && this._crPage._browserContext._options.focusControl)
+                  promises.push(this._client.send("Emulation.setFocusEmulationEnabled", { enabled: true }));
+              
       const options = this._crPage._browserContext._options;
       if (options.bypassCSP)
         promises.push(this._client.send('Page.setBypassCSP', { enabled: true }));
@@ -549,14 +566,24 @@
       promises.push(this._updateGeolocation(true));
       promises.push(this._updateEmulateMedia());
       promises.push(this._updateFileChooserInterception(true));
-      for (const initScript of this._crPage._page.allInitScripts())
-        promises.push(this._evaluateOnNewDocument(initScript, 'main', true /* runImmediately */));
+      
+                    for (const binding of this._crPage._page.allBindings()) promises.push(this._initBinding(binding));
+                    for (const initScript of this._crPage._browserContext.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+                    for (const initScript of this._crPage._page.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+                  
       if (screencastOptions)
         promises.push(this._startVideoRecording(screencastOptions));
     }
-    promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
+    
+            if (!(this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size))
+              promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
+          
     promises.push(this._firstNonInitialNavigationCommittedPromise);
     await Promise.all(promises);
+
+            if (this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size)
+              await this._client.send('Runtime.runIfWaitingForDebugger');
+          
   }
 
   dispose() {
@@ -580,13 +607,25 @@
     return { newDocumentId: response.loaderId };
   }
 
-  _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
+  async _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
     if (this._eventBelongsToStaleFrame(event.frameId))
       return;
     if (event.name === 'load')
       this._page.frameManager.frameLifecycleEvent(event.frameId, 'load');
     else if (event.name === 'DOMContentLoaded')
       this._page.frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded');
+    await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          var document = await this._client._sendMayFail("DOM.getDocument");
+          if (!document) return
+          var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+            nodeId: document.root.nodeId,
+            selector: "[class=" + this._crPage.initScriptTag + "]"
+          });
+          if (!query) return
+          for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+          await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          // ensuring execution context
+          try { await this._page.frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _handleFrameTree(frameTree: Protocol.Page.FrameTree) {
@@ -633,12 +672,24 @@
     this._page.frameManager.frameAttached(frameId, parentFrameId);
   }
 
-  _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
+  async _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
     if (this._eventBelongsToStaleFrame(framePayload.id))
       return;
     this._page.frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ''), framePayload.name || '', framePayload.loaderId, initial);
     if (!initial)
       this._firstNonInitialNavigationCommittedFulfill();
+    await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          var document = await this._client._sendMayFail("DOM.getDocument");
+          if (!document) return
+          var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+            nodeId: document.root.nodeId,
+            selector: "[class=" + this._crPage.initScriptTag + "]"
+          });
+          if (!query) return
+          for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+          await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          // ensuring execution context
+          try { await this._page.frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _onFrameRequestedNavigation(payload: Protocol.Page.frameRequestedNavigationPayload) {
@@ -675,19 +726,31 @@
   }
 
   _onExecutionContextCreated(contextPayload: Protocol.Runtime.ExecutionContextDescription) {
+
+          for (const name of this._exposedBindingNames)
+            this._client._sendMayFail('Runtime.addBinding', { name: name, executionContextId: contextPayload.id });
+        
     const frame = contextPayload.auxData ? this._page.frameManager.frame(contextPayload.auxData.frameId) : null;
+
+          if (contextPayload.auxData.type == "worker") throw new Error("ExecutionContext is worker");
+        
     if (!frame || this._eventBelongsToStaleFrame(frame._id))
       return;
     const delegate = new CRExecutionContext(this._client, contextPayload);
-    let worldName: types.World|null = null;
-    if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
-      worldName = 'main';
-    else if (contextPayload.name === this._crPage.utilityWorldName)
-      worldName = 'utility';
+    let worldName = contextPayload.name;
     const context = new dom.FrameExecutionContext(delegate, frame, worldName);
     if (worldName)
       frame._contextCreated(worldName, context);
     this._contextIdToContext.set(contextPayload.id, context);
+
+          for (const source of this._exposedBindingScripts) {
+            this._client._sendMayFail("Runtime.evaluate", {
+              expression: source,
+              contextId: contextPayload.id,
+              awaitPromise: true,
+            })
+          }
+        
   }
 
   _onExecutionContextDestroyed(executionContextId: number) {
@@ -703,7 +766,7 @@
       this._onExecutionContextDestroyed(contextId);
   }
 
-  _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
+  async _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
     if (this._bufferedAttachedToTargetEvents) {
       this._bufferedAttachedToTargetEvents.push(event);
       return;
@@ -745,12 +808,22 @@
     session.once('Runtime.executionContextCreated', async event => {
       worker.createExecutionContext(new CRExecutionContext(session, event.context));
     });
+
+          var globalThis = await session._sendMayFail('Runtime.evaluate', {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          });
+          if (globalThis && globalThis.result) {
+            var globalThisObjId = globalThis.result.objectId;
+            var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+            worker.createExecutionContext(new CRExecutionContext(session, { id: executionContextId }));
+          }
+        
     if (this._crPage._browserContext._browser.majorVersion() >= 143)
       session.on('Inspector.workerScriptLoaded', () => worker.workerScriptLoaded());
     else
       worker.workerScriptLoaded();
     // This might fail if the target is closed before we initialize.
-    session._sendMayFail('Runtime.enable');
     // TODO: attribute workers to the right frame.
     this._crPage._networkManager.addSession(session, this._page.frameManager.frame(this._targetId) ?? undefined).catch(() => {});
     session._sendMayFail('Runtime.runIfWaitingForDebugger');
@@ -1076,20 +1149,11 @@
   }
 
   async _evaluateOnNewDocument(initScript: InitScript, world: types.World, runImmediately?: boolean): Promise<void> {
-    const worldName = world === 'utility' ? this._crPage.utilityWorldName : undefined;
-    const { identifier } = await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source: initScript.source, worldName, runImmediately });
-    this._initScriptIds.set(initScript, identifier);
+    this._evaluateOnNewDocumentScripts.push(initScript)
   }
 
   async _removeEvaluatesOnNewDocument(initScripts: InitScript[]): Promise<void> {
-    const ids: string[] = [];
-    for (const script of initScripts) {
-      const id = this._initScriptIds.get(script);
-      if (id)
-        ids.push(id);
-      this._initScriptIds.delete(script);
-    }
-    await Promise.all(ids.map(identifier => this._client.send('Page.removeScriptToEvaluateOnNewDocument', { identifier }).catch(() => {}))); // target can be closed
+    this._evaluateOnNewDocumentScripts = [];
   }
 
   async exposePlaywrightBinding() {
@@ -1200,6 +1264,49 @@
       throw new Error(dom.kUnableToAdoptErrorMessage);
     return createHandle(to, result.object).asElement()!;
   }
+
+  _exposedBindingNames: string[] = [];
+  _evaluateOnNewDocumentScripts: string[] = [];
+  _parsedExecutionContextIds: number[] = [];
+  _exposedBindingScripts: string[] = [];
+
+  async _initBinding(binding = PageBinding) {
+
+          var result = await this._client._sendMayFail('Page.createIsolatedWorld', {
+            frameId: this._targetId, grantUniveralAccess: true, worldName: "utility"
+          });
+          if (!result) return
+          var isolatedContextId = result.executionContextId
+
+          var globalThis = await this._client._sendMayFail('Runtime.evaluate', {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          });
+          if (!globalThis) return
+          var globalThisObjId = globalThis["result"]['objectId']
+          var mainContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+          await Promise.all([
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name }),
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: mainContextId }),
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: isolatedContextId }),
+            // this._client._sendMayFail("Runtime.evaluate", { expression: binding.source, contextId: mainContextId, awaitPromise: true })
+          ]);
+          this._exposedBindingNames.push(binding.name);
+          this._exposedBindingScripts.push(binding.source);
+          await this._crPage.addInitScript(binding.source);
+          //this._client._sendMayFail('Runtime.runIfWaitingForDebugger')
+  }
+
+  async _removeExposedBindings() {
+    const toRetain: string[] = [];
+          const toRemove: string[] = [];
+          for (const name of this._exposedBindingNames)
+            (name.startsWith('__pw_') ? toRetain : toRemove).push(name);
+          this._exposedBindingNames = toRetain;
+          await Promise.all(toRemove.map(name => this._client.send('Runtime.removeBinding', { name })));
+        
+  }
 }
 
 async function emulateLocale(session: CRSession, locale: string) {
diff -ruN playwright/node_modules/playwright-core/src/server/chromium/crServiceWorker.ts patchright/node_modules/playwright-core/src/server/chromium/crServiceWorker.ts
---
+++
@@ -58,13 +58,23 @@
       const message = new ConsoleMessage(null, this, event.type, undefined, args, toConsoleMessageLocation(event.stackTrace));
       this.browserContext.emit(BrowserContext.Events.Console, message);
     });
-
-    session.send('Runtime.enable', {}).catch(e => { });
     session.send('Runtime.runIfWaitingForDebugger').catch(e => { });
     session.on('Inspector.targetReloadedAfterCrash', () => {
       // Resume service worker after restart.
       session._sendMayFail('Runtime.runIfWaitingForDebugger', {});
     });
+
+          session._sendMayFail("Runtime.evaluate", {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          }).then(globalThis => {
+            if (globalThis && globalThis.result) {
+              var globalThisObjId = globalThis.result.objectId;
+              var executionContextId = parseInt(globalThisObjId.split(".")[1], 10);
+              this.createExecutionContext(new CRExecutionContext(session, { id: executionContextId }));
+            }
+          });
+        
   }
 
   override didClose() {
diff -ruN playwright/node_modules/playwright-core/src/server/clock.ts patchright/node_modules/playwright-core/src/server/clock.ts
---
+++
@@ -106,6 +106,16 @@
   }
 
   private async _evaluateInFrames(script: string) {
+
+          // Dont ask me why this works
+          await Promise.all(this._browserContext.pages().map(async page => {
+            await Promise.all(page.frames().map(async frame => {
+              try {
+                await frame.evaluateExpression("");
+              } catch (e) {}
+            }));
+          }));
+        
     await this._browserContext.safeNonStallingEvaluateInAllFrames(script, 'main', { throwOnJSErrors: true });
   }
 }
diff -ruN playwright/node_modules/playwright-core/src/server/dispatchers/frameDispatcher.ts patchright/node_modules/playwright-core/src/server/dispatchers/frameDispatcher.ts
---
+++
@@ -84,11 +84,15 @@
   }
 
   async evaluateExpression(params: channels.FrameEvaluateExpressionParams, progress: Progress): Promise<channels.FrameEvaluateExpressionResult> {
-    return { value: serializeResult(await progress.race(this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)))) };
+
+          return { value: serializeResult(await progress.race(this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction, world: params.isolatedContext ? 'utility': 'main' }, parseArgument(params.arg)))) };
+        
   }
 
   async evaluateExpressionHandle(params: channels.FrameEvaluateExpressionHandleParams, progress: Progress): Promise<channels.FrameEvaluateExpressionHandleResult> {
-    return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this, await progress.race(this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)))) };
+
+          return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this, await progress.race(this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction, world: params.isolatedContext ? 'utility': 'main' }, parseArgument(params.arg)))) };
+        
   }
 
   async waitForSelector(params: channels.FrameWaitForSelectorParams, progress: Progress): Promise<channels.FrameWaitForSelectorResult> {
@@ -104,7 +108,9 @@
   }
 
   async evalOnSelectorAll(params: channels.FrameEvalOnSelectorAllParams, progress: Progress): Promise<channels.FrameEvalOnSelectorAllResult> {
-    return { value: serializeResult(await progress.race(this._frame.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg)))) };
+
+          return { value: serializeResult(await this._frame.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg), null, params.isolatedContext)) };
+        
   }
 
   async querySelector(params: channels.FrameQuerySelectorParams, progress: Progress): Promise<channels.FrameQuerySelectorResult> {
diff -ruN playwright/node_modules/playwright-core/src/server/frameSelectors.ts patchright/node_modules/playwright-core/src/server/frameSelectors.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import { ElementHandle } from './dom';
 /**
  * Copyright (c) Microsoft Corporation.
  *
@@ -65,8 +67,8 @@
     return adoptIfNeeded(elementHandle, await resolved.frame._mainContext());
   }
 
-  async queryArrayInMainWorld(selector: string, scope?: ElementHandle): Promise<JSHandle<Element[]>> {
-    const resolved = await this.resolveInjectedForSelector(selector, { mainWorld: true }, scope);
+  async queryArrayInMainWorld(selector: string, scope?: ElementHandle, isolatedContext?: boolean): Promise<JSHandle<Element[]>> {
+    const resolved = await this.resolveInjectedForSelector(selector, { mainWorld: !isolatedContext }, scope);
     // Be careful, |this.frame| can be different from |resolved.frame|.
     if (!resolved)
       throw new Error(`Failed to find frame for selector "${selector}"`);
@@ -150,9 +152,31 @@
           throw injected.createStacklessError(`Selector "${selectorString}" resolved to ${injected.previewNode(element)}, <iframe> was expected`);
         return element;
       }, { info, scope: i === 0 ? scope : undefined, selectorString: stringifySelector(info.parsed) });
-      const element = handle.asElement() as ElementHandle<Element> | null;
-      if (!element)
-        return null;
+      let element = handle.asElement() as ElementHandle<Element> | null;
+      
+            if (!element) {
+              try {
+                var client = frame._page.delegate._sessionForFrame(frame)._client;
+              } catch (e) {
+                var client = frame._page.delegate._mainFrameSession._client;
+              }
+              var mainContext = await frame._context("main");
+              const documentNode = await client.send("Runtime.evaluate", {
+                expression: "document",
+                serializationOptions: {
+                  serialization: "idOnly"
+                },
+                contextId: mainContext.delegate._contextId
+              });
+              const documentScope = new ElementHandle(mainContext, documentNode.result.objectId);
+              var check = await this._customFindFramesByParsed(injectedScript, client, mainContext, documentScope, info.parsed);
+              if (check.length > 0) {
+                element = check[0];
+              } else {
+                return null;
+              }
+            }
+          
       const maybeFrame = await frame._page.delegate.getContentFrame(element);
       element.dispose();
       if (!maybeFrame)
@@ -176,6 +200,162 @@
     const injected = await context.injectedScript();
     return { injected, info: resolved.info, frame: resolved.frame, scope: resolved.scope };
   }
+
+  async _customFindFramesByParsed(injected, client, context, documentScope, parsed) {
+
+          var parsedEdits = { ...parsed };
+          var currentScopingElements = [documentScope];
+          while (parsed.parts.length > 0) {
+            var part = parsed.parts.shift();
+            parsedEdits.parts = [part];
+            var elements = [];
+            var elementsIndexes = [];
+            if (part.name == "nth") {
+              const partNth = Number(part.body);
+              if (partNth > currentScopingElements.length || partNth < -currentScopingElements.length) {
+                return continuePolling;
+              } else {
+                currentScopingElements = [currentScopingElements.at(partNth)];
+                continue;
+              }
+            } else if (part.name == "internal:or") {
+              var orredElements = await this._customFindFramesByParsed(injected, client, context, documentScope, part.body.parsed);
+              elements = currentScopingElements.concat(orredElements);
+            } else if (part.name == "internal:and") {
+              var andedElements = await this._customFindFramesByParsed(injected, client, context, documentScope, part.body.parsed);
+              const backendNodeIds = new Set(andedElements.map((item) => item.backendNodeId));
+              elements = currentScopingElements.filter((item) => backendNodeIds.has(item.backendNodeId));
+            } else {
+              for (const scope of currentScopingElements) {
+                const describedScope = await client.send("DOM.describeNode", {
+                  objectId: scope._objectId,
+                  depth: -1,
+                  pierce: true
+                });
+                var queryingElements = [];
+                let findClosedShadowRoots2 = function(node, results = []) {
+                  if (!node || typeof node !== "object") return results;
+                  if (node.shadowRoots && Array.isArray(node.shadowRoots)) {
+                    for (const shadowRoot2 of node.shadowRoots) {
+                      if (shadowRoot2.shadowRootType === "closed" && shadowRoot2.backendNodeId) {
+                        results.push(shadowRoot2.backendNodeId);
+                      }
+                      findClosedShadowRoots2(shadowRoot2, results);
+                    }
+                  }
+                  if (node.nodeName !== "IFRAME" && node.children && Array.isArray(node.children)) {
+                    for (const child of node.children) {
+                      findClosedShadowRoots2(child, results);
+                    }
+                  }
+                  return results;
+                };
+                var findClosedShadowRoots = findClosedShadowRoots2;
+                var shadowRootBackendIds = findClosedShadowRoots2(describedScope.node);
+                var shadowRoots = [];
+                for (var shadowRootBackendId of shadowRootBackendIds) {
+                  var resolvedShadowRoot = await client.send("DOM.resolveNode", {
+                    backendNodeId: shadowRootBackendId,
+                    contextId: context.delegate._contextId
+                  });
+                  shadowRoots.push(new ElementHandle(context, resolvedShadowRoot.object.objectId));
+                }
+                for (var shadowRoot of shadowRoots) {
+                  const shadowElements = await shadowRoot.evaluateHandleInUtility(([injected, node, { parsed: parsed2 }]) => {
+                    const elements2 = injected.querySelectorAll(parsed2, node);
+                    return elements2;
+                  }, {
+                    parsed: parsedEdits,
+                  });
+                  const shadowElementsAmount = await shadowElements.getProperty("length");
+                  queryingElements.push([shadowElements, shadowElementsAmount, shadowRoot]);
+                }
+                const rootElements = await scope.evaluateHandleInUtility(([injected, node, { parsed: parsed2 }]) => {
+                  const elements2 = injected.querySelectorAll(parsed2, node);
+                  return elements2;
+                }, {
+                  parsed: parsedEdits
+                });
+                const rootElementsAmount = await rootElements.getProperty("length");
+                queryingElements.push([rootElements, rootElementsAmount, injected]);
+                for (var queryedElement of queryingElements) {
+                  var elementsToCheck = queryedElement[0];
+                  var elementsAmount = await queryedElement[1].jsonValue();
+                  var parentNode = queryedElement[2];
+                  for (var i = 0; i < elementsAmount; i++) {
+                    if (parentNode.constructor.name == "ElementHandle") {
+                      var elementToCheck = await parentNode.evaluateHandleInUtility(([injected, node, { index, elementsToCheck: elementsToCheck2 }]) => {
+                        return elementsToCheck2[index];
+                      }, { index: i, elementsToCheck });
+                    } else {
+                      var elementToCheck = await parentNode.evaluateHandle((injected, { index, elementsToCheck: elementsToCheck2 }) => {
+                        return elementsToCheck2[index];
+                      }, { index: i, elementsToCheck });
+                    }
+                    elementToCheck.parentNode = parentNode;
+                    var resolvedElement = await client.send("DOM.describeNode", {
+                      objectId: elementToCheck._objectId,
+                      depth: -1
+                    });
+                    elementToCheck.backendNodeId = resolvedElement.node.backendNodeId;
+                    elementToCheck.nodePosition = this._findElementPositionInDomTree(elementToCheck, describedScope.node, context, "");
+                    elements.push(elementToCheck);
+                  }
+                }
+              }
+            }
+            // Sorting elements by their nodePosition, which is a index to the Element in the DOM tree
+            const getParts = (pos) => (pos?.match(/../g) || []).map(Number);
+            elements.sort((a, b) => {
+              const partA = getParts(a.nodePosition);
+              const partB = getParts(b.nodePosition);
+              const maxLength = Math.max(partA.length, partB.length);
+
+              for (let i = 0; i < maxLength; i++) {
+                const aVal = partA[i] ?? -1;
+                const bVal = partB[i] ?? -1;
+                if (aVal !== bVal) return aVal - bVal;
+              }
+              return 0;
+            });
+
+            // Remove duplicates by nodePosition, keeping the first occurrence
+            currentScopingElements = Array.from(
+              new Map(elements.map(e => [e.nodePosition, e])).values()
+            );
+          }
+          return currentScopingElements;
+        
+  }
+
+  _findElementPositionInDomTree(element, queryingElement, documentScope, currentIndex) {
+
+          // Get Element Position in DOM Tree by Indexing it via their children indexes, like a search tree index
+          // Check if backendNodeId matches, if so, return currentIndex
+          if (element.backendNodeId === queryingElement.backendNodeId) {
+            return currentIndex;
+          }
+          // Iterating through children of queryingElement
+          for (const child of queryingElement.children || []) {
+            // Getting index of child in queryingElement's children
+            const childrenNodeIndex = queryingElement.children.indexOf(child);
+            // Further querying the child recursively and appending the children index to the currentIndex
+            const childIndex = this._findElementPositionInDomTree(element, child, documentScope, currentIndex + childrenNodeIndex.toString());
+            if (childIndex !== null) return childIndex;
+          }
+          if (queryingElement.shadowRoots && Array.isArray(queryingElement.shadowRoots)) {
+            // Basically same for CSRs, but we dont have to append its index because patchright treats CSRs like they dont exist
+            for (const shadowRoot of queryingElement.shadowRoots) {
+              if (shadowRoot.shadowRootType === "closed" && shadowRoot.backendNodeId) {
+                const shadowRootHandle = new ElementHandle(documentScope, shadowRoot.backendNodeId);
+                const childIndex = this._findElementPositionInDomTree(element, shadowRootHandle, documentScope, currentIndex);
+                if (childIndex !== null) return childIndex;
+              }
+            }
+          }
+          return null;
+        
+  }
 }
 
 async function adoptIfNeeded<T extends Node>(handle: ElementHandle<T>, context: FrameExecutionContext): Promise<ElementHandle<T>> {
diff -ruN playwright/node_modules/playwright-core/src/server/frames.ts patchright/node_modules/playwright-core/src/server/frames.ts
---
+++
@@ -1,3 +1,7 @@
+// patchright - custom imports
+import { CRExecutionContext } from './chromium/crExecutionContext';
+import { FrameExecutionContext } from './dom';
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -506,6 +510,9 @@
   }
 
   _onClearLifecycle() {
+    this._isolatedWorld = undefined;
+    this._mainWorld = undefined;
+    this._iframeWorld = undefined;
     for (const event of this._firedLifecycleEvents)
       this.emit(Frame.Events.RemoveLifecycle, event);
     this._firedLifecycleEvents.clear();
@@ -714,12 +721,69 @@
     return this._page.delegate.getFrameElement(this);
   }
 
-  _context(world: types.World): Promise<dom.FrameExecutionContext> {
-    return this._contextData.get(world)!.contextPromise.then(contextOrDestroyedReason => {
-      if (contextOrDestroyedReason instanceof js.ExecutionContext)
-        return contextOrDestroyedReason;
-      throw new Error(contextOrDestroyedReason.destroyedReason);
-    });
+  async _context(world: types.World): Promise<dom.FrameExecutionContext> {
+
+          /* await this._page.delegate._mainFrameSession._client._sendMayFail('DOM.enable');
+          var globalDoc = await this._page.delegate._mainFrameSession._client._sendMayFail('DOM.getFrameOwner', { frameId: this._id });
+          if (globalDoc) {
+            await this._page.delegate._mainFrameSession._client._sendMayFail("DOM.resolveNode", { nodeId: globalDoc.nodeId })
+          } */
+
+          if (this.isDetached()) throw new Error('Frame was detached');
+          try {
+            var client = this._page.delegate._sessionForFrame(this)._client
+          } catch (e) { var client = this._page.delegate._mainFrameSession._client }
+          var iframeExecutionContextId = await this._getFrameMainFrameContextId(client)
+
+          if (world == "main") {
+            // Iframe Only
+            if (this != this._page.mainFrame() && iframeExecutionContextId && this._iframeWorld == undefined) {
+              var executionContextId = iframeExecutionContextId
+              var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+              this._iframeWorld = new FrameExecutionContext(crContext, this, world)
+              this._page.delegate._mainFrameSession._onExecutionContextCreated({
+                id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+              })
+            } else if (this._mainWorld == undefined) {
+              var globalThis = await client._sendMayFail('Runtime.evaluate', {
+                expression: "globalThis",
+                serializationOptions: { serialization: "idOnly" }
+              });
+              if (!globalThis) { return }
+              var globalThisObjId = globalThis["result"]['objectId']
+              var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+              var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+              this._mainWorld = new FrameExecutionContext(crContext, this, world)
+              this._page.delegate._mainFrameSession._onExecutionContextCreated({
+                id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+              })
+            }
+          }
+          if (world != "main" && this._isolatedWorld == undefined) {
+            world = "utility"
+            var result = await client._sendMayFail('Page.createIsolatedWorld', {
+              frameId: this._id, grantUniveralAccess: true, worldName: world
+            });
+            if (!result) {
+              // if (this.isDetached()) throw new Error("Frame was detached");
+              return
+            }
+            var executionContextId = result.executionContextId
+            var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+            this._isolatedWorld = new FrameExecutionContext(crContext, this, world)
+            this._page.delegate._mainFrameSession._onExecutionContextCreated({
+              id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+            })
+          }
+
+          if (world != "main") {
+            return this._isolatedWorld;
+          } else if (this != this._page.mainFrame() && iframeExecutionContextId) {
+            return this._iframeWorld;
+          } else {
+            return this._mainWorld;
+          }
   }
 
   _mainContext(): Promise<dom.FrameExecutionContext> {
@@ -741,78 +805,73 @@
   }
 
   async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean, world?: types.World } = {}, arg?: any): Promise<js.JSHandle<any>> {
-    const context = await this._context(options.world ?? 'main');
-    const value = await context.evaluateExpressionHandle(expression, options, arg);
-    return value;
+
+          const context = await this._context(options.world ?? "utility");
+          const value = await context.evaluateExpressionHandle(expression, options, arg);
+          return value;
+        
   }
 
   async querySelector(selector: string, options: types.StrictOptions): Promise<dom.ElementHandle<Element> | null> {
-    debugLogger.log('api', `    finding element using the selector "${selector}"`);
-    return this.selectors.query(selector, options);
+
+          return this.querySelectorAll(selector, options).then((handles) => {
+            if (handles.length === 0)
+              return null;
+            if (handles.length > 1 && options?.strict)
+              throw new Error(`Strict mode: expected one element matching selector "${selector}", found ${handles.length}`);
+            return handles[0];
+          });
+        
   }
 
   async waitForSelector(progress: Progress, selector: string, performActionPreChecksAndLog: boolean, options: types.WaitForElementOptions, scope?: dom.ElementHandle): Promise<dom.ElementHandle<Element> | null> {
-    if ((options as any).visibility)
-      throw new Error('options.visibility is not supported, did you mean options.state?');
-    if ((options as any).waitFor && (options as any).waitFor !== 'visible')
-      throw new Error('options.waitFor is not supported, did you mean options.state?');
-    const { state = 'visible' } = options;
-    if (!['attached', 'detached', 'visible', 'hidden'].includes(state))
-      throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
-    if (performActionPreChecksAndLog)
-      progress.log(`waiting for ${this._asLocator(selector)}${state === 'attached' ? '' : ' to be ' + state}`);
-    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecksAndLog)
-        await this._page.performActionPreChecks(progress);
 
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved) {
-        if (state === 'hidden' || state === 'detached')
-          return null;
-        return continuePolling;
-      }
-      const result = await progress.race(resolved.injected.evaluateHandle((injected, { info, root }) => {
-        if (root && !root.isConnected)
-          throw injected.createStacklessError('Element is not attached to the DOM');
-        const elements = injected.querySelectorAll(info.parsed, root || document);
-        const element: Element | undefined  = elements[0];
-        const visible = element ? injected.utils.isElementVisible(element) : false;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
-            throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewNode(element)}`;
-        }
-        return { log, element, visible, attached: !!element };
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined }));
-      const { log, visible, attached } = await progress.race(result.evaluate(r => ({ log: r.log, visible: r.visible, attached: r.attached })));
-      if (log)
-        progress.log(log);
-      const success = { attached, detached: !attached, visible, hidden: !visible }[state];
-      if (!success) {
-        result.dispose();
-        return continuePolling;
-      }
-      if (options.omitReturnValue) {
-        result.dispose();
-        return null;
-      }
-      const element = state === 'attached' || state === 'visible' ? await progress.race(result.evaluateHandle(r => r.element)) : null;
-      result.dispose();
-      if (!element)
-        return null;
-      if ((options as any).__testHookBeforeAdoptNode)
-        await progress.race((options as any).__testHookBeforeAdoptNode());
-      try {
-        const mainContext = await progress.race(resolved.frame._mainContext());
-        return await progress.race(element._adoptTo(mainContext));
-      } catch (e) {
-        return continuePolling;
-      }
-    });
-    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+          if ((options as any).visibility)
+            throw new Error('options.visibility is not supported, did you mean options.state?');
+          if ((options as any).waitFor && (options as any).waitFor !== 'visible')
+            throw new Error('options.waitFor is not supported, did you mean options.state?');
+          const { state = 'visible' } = options;
+          if (!['attached', 'detached', 'visible', 'hidden'].includes(state))
+            throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
+          if (performActionPreChecksAndLog)
+            progress.log(`waiting for ${this._asLocator(selector)}${state === 'attached' ? '' : ' to be ' + state}`);
+
+          const promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, true, async handle => {
+            const attached = !!handle;
+            var visible = false;
+            if (attached) {
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                visible = await handle.parentNode.evaluateInUtility(([injected, node, { handle }]) => {
+                  return handle ? injected.utils.isElementVisible(handle) : false;
+                }, { handle });
+              } else {
+                visible = await handle.parentNode.evaluate((injected, { handle }) => {
+                  return handle ? injected.utils.isElementVisible(handle) : false;
+                }, { handle });
+              }
+            }
+
+            const success = {
+              attached,
+              detached: !attached,
+              visible,
+              hidden: !visible
+            }[state];
+            if (!success) return "internal:continuepolling";
+            if (options.omitReturnValue) return null;
+
+            const element = state === 'attached' || state === 'visible' ? handle : null;
+            if (!element) return null;
+            if (options.__testHookBeforeAdoptNode) await options.__testHookBeforeAdoptNode();
+            try {
+              return element;
+            } catch (e) {
+              return "internal:continuepolling";
+            }
+          }, "returnOnNotResolved");
+
+          return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+        
   }
 
   async dispatchEvent(progress: Progress, selector: string, type: string, eventInit: Object = {}, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<void> {
@@ -823,18 +882,27 @@
 
   async evalOnSelector(selector: string, strict: boolean, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any> {
     const handle = await this.selectors.query(selector, { strict }, scope);
-    if (!handle)
-      throw new Error(`Failed to find element matching selector "${selector}"`);
-    const result = await handle.evaluateExpression(expression, { isFunction }, arg);
-    handle.dispose();
-    return result;
+            if (!handle)
+              throw new Error('Failed to find element matching selector ' + selector);
+            const result = await handle.evaluateExpression(expression, { isFunction }, arg, true);
+            handle.dispose();
+            return result;
   }
 
-  async evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any> {
-    const arrayHandle = await this.selectors.queryArrayInMainWorld(selector, scope);
-    const result = await arrayHandle.evaluateExpression(expression, { isFunction }, arg);
-    arrayHandle.dispose();
-    return result;
+  async evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle, isolatedContext?: boolean): Promise<any> {
+
+          try {
+            isolatedContext = this.selectors._parseSelector(selector, { strict: false }).world !== "main" && isolatedContext;
+            const arrayHandle = await this.selectors.queryArrayInMainWorld(selector, scope, isolatedContext);
+            const result = await arrayHandle.evaluateExpression(expression, { isFunction }, arg, isolatedContext);
+            arrayHandle.dispose();
+            return result;
+          } catch (e) {
+            // Do i look like i know whats going on here?
+            if ("JSHandles can be evaluated only in the context they were created!" === e.message) return await this.evalOnSelectorAll(selector, expression, isFunction, arg, scope, isolatedContext);
+            throw e;
+          }
+        
   }
 
   async maskSelectors(selectors: ParsedSelector[], color: string): Promise<void> {
@@ -846,17 +914,35 @@
   }
 
   async querySelectorAll(selector: string): Promise<dom.ElementHandle<Element>[]> {
-    return this.selectors.queryAll(selector);
+
+          const metadata = { internal: false, log: [], method: "querySelectorAll" };
+          const progress = {
+            log: message => metadata.log.push(message),
+            metadata,
+            race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+          }
+          return await this._retryWithoutProgress(progress, selector, null, false, async (result) => {
+            if (!result || !result[0]) return [];
+            return result[1];
+          }, 'returnAll', null);
+        
   }
 
   async queryCount(selector: string, options: any): Promise<number> {
-    try {
-      return await this.selectors.queryCount(selector, options);
-    } catch (e) {
-      if (this.isNonRetriableError(e))
-        throw e;
-      return 0;
-    }
+
+          const metadata = { internal: false, log: [], method: "queryCount" };
+          const progress = {
+            log: message => metadata.log.push(message),
+            metadata,
+            race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+          }
+          return await this._retryWithoutProgress(progress, selector, null, false, async (result) => {
+            if (!result) return 0;
+            const handle = result[0];
+            const handles = result[1];
+            return handle ? handles.length : 0;
+          }, 'returnAll', null);
+        
   }
 
   async content(): Promise<string> {
@@ -878,29 +964,23 @@
   }
 
   async setContent(progress: Progress, html: string, options: types.NavigateOptions): Promise<void> {
-    const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
-    await this.raceNavigationAction(progress, async () => {
-      const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;
-      progress.log(`setting frame content, waiting until "${waitUntil}"`);
-      const context = await progress.race(this._utilityContext());
-      const tagPromise = new ManualPromise<void>();
-      this._page.frameManager._consoleMessageTags.set(tag, () => {
-        // Clear lifecycle right after document.open() - see 'tag' below.
-        this._onClearLifecycle();
-        tagPromise.resolve();
-      });
-      const lifecyclePromise = progress.race(tagPromise).then(() => this._waitForLoadState(progress, waitUntil));
-      const contentPromise = progress.race(context.evaluate(({ html, tag }) => {
-        document.open();
-        console.debug(tag);  // eslint-disable-line no-console
-        document.write(html);
-        document.close();
-      }, { html, tag }));
-      await Promise.all([contentPromise, lifecyclePromise]);
-      return null;
-    }).finally(() => {
-      this._page.frameManager._consoleMessageTags.delete(tag);
-    });
+
+          await this.raceNavigationAction(progress, async () => {
+            const waitUntil = options.waitUntil === void 0 ? "load" : options.waitUntil;
+            progress.log(`setting frame content, waiting until "${waitUntil}"`);
+            const lifecyclePromise = new Promise((resolve, reject) => {
+              this._onClearLifecycle();
+              this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
+            });
+            const setContentPromise = this._page.delegate._mainFrameSession._client.send("Page.setDocumentContent", {
+              frameId: this._id,
+              html
+            });
+            await Promise.all([setContentPromise, lifecyclePromise]);
+
+            return null;
+          });
+        
   }
 
   name(): string {
@@ -1093,50 +1173,13 @@
     selector: string,
     strict: boolean | undefined,
     performActionPreChecks: boolean,
-    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>): Promise<R> {
-    progress.log(`waiting for ${this._asLocator(selector)}`);
-    return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecks)
-        await this._page.performActionPreChecks(progress);
+    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>, returnAction: boolean | undefined): Promise<R> {
 
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, { strict }));
-      if (!resolved)
-        return continuePolling;
-      const result = await progress.race(resolved.injected.evaluateHandle((injected, { info, callId }) => {
-        const elements = injected.querySelectorAll(info.parsed, document);
-        if (callId)
-          injected.markTargetElements(new Set(elements), callId);
-        const element = elements[0] as Element | undefined;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
-            throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${injected.previewNode(element)}`;
-        }
-        return { log, success: !!element, element };
-      }, { info: resolved.info, callId: progress.metadata.id }));
-      const { log, success } = await progress.race(result.evaluate(r => ({ log: r.log, success: r.success })));
-      if (log)
-        progress.log(log);
-      if (!success) {
-        result.dispose();
-        return continuePolling;
-      }
-      const element = await progress.race(result.evaluateHandle(r => r.element)) as dom.ElementHandle<Element>;
-      result.dispose();
-      try {
-        const result = await action(element);
-        if (result === 'error:notconnected') {
-          progress.log('element was detached from the DOM, retrying');
-          return continuePolling;
-        }
-        return result;
-      } finally {
-        element?.dispose();
-      }
-    });
+          progress.log("waiting for " + this._asLocator(selector));
+          return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
+            return this._retryWithoutProgress(progress, selector, strict, performActionPreChecks, action, returnAction, continuePolling);
+          });
+        
   }
 
   async rafrafTimeoutScreenshotElementWithProgress(progress: Progress, selector: string, timeout: number, options: ScreenshotOptions): Promise<Buffer> {
@@ -1289,20 +1332,61 @@
   }
 
   async isVisibleInternal(progress: Progress, selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {
-    try {
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved)
-        return false;
-      return await progress.race(resolved.injected.evaluate((injected, { info, root }) => {
-        const element = injected.querySelector(info.parsed, root || document, info.strict);
-        const state = element ? injected.elementState(element, 'visible') : { matches: false, received: 'error:notconnected' };
-        return state.matches;
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined }));
-    } catch (e) {
-      if (this.isNonRetriableError(e))
-        throw e;
-      return false;
-    }
+
+          try {
+            const metadata = { internal: false, log: [], method: "isVisible" };
+            const progress = {
+              log: message => metadata.log.push(message),
+              metadata,
+              race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+            }
+            progress.log("waiting for " + this._asLocator(selector));
+            if (selector === ":scope") {
+              const scopeParentNode = scope.parentNode || scope;
+              if (scopeParentNode.constructor.name == "ElementHandle") {
+                return await scopeParentNode.evaluateInUtility(([injected, node, { scope: handle2 }]) => {
+                  const state = handle2 ? injected.elementState(handle2, "visible") : {
+                    matches: false,
+                    received: "error:notconnected"
+                  };
+                  return state.matches;
+                }, { scope });
+              } else {
+                return await scopeParentNode.evaluate((injected, node, { scope: handle2 }) => {
+                  const state = handle2 ? injected.elementState(handle2, "visible") : {
+                    matches: false,
+                    received: "error:notconnected"
+                  };
+                  return state.matches;
+                }, { scope });
+              }
+            } else {
+              return await this._retryWithoutProgress(progress, selector, options.strict, false, async (handle) => {
+                if (!handle) return false;
+                if (handle.parentNode.constructor.name == "ElementHandle") {
+                  return await handle.parentNode.evaluateInUtility(([injected, node, { handle: handle2 }]) => {
+                    const state = handle2 ? injected.elementState(handle2, "visible") : {
+                      matches: false,
+                      received: "error:notconnected"
+                    };
+                    return state.matches;
+                  }, { handle });
+                } else {
+                  return await handle.parentNode.evaluate((injected, { handle: handle2 }) => {
+                    const state = handle2 ? injected.elementState(handle2, "visible") : {
+                      matches: false,
+                      received: "error:notconnected"
+                    };
+                    return state.matches;
+                  }, { handle });
+                }
+              }, "returnOnNotResolved", null);
+            }
+          } catch (e) {
+            if (this.isNonRetriableError(e)) throw e;
+            return false;
+          }
+        
   }
 
   async isHidden(progress: Progress, selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {
@@ -1423,45 +1507,76 @@
   }
 
   private async _expectInternal(progress: Progress, selector: string | undefined, options: FrameExpectParams, lastIntermediateResult: { received?: any, isSet: boolean, errorMessage?: string }, noAbort: boolean) {
-    // The first expect check, a.k.a. one-shot, always finishes - even when progress is aborted.
-    const race = <T>(p: Promise<T>) => noAbort ? p : progress.race(p);
-    const selectorInFrame = selector ? await race(this.selectors.resolveFrameForSelector(selector, { strict: true })) : undefined;
-
-    const { frame, info } = selectorInFrame || { frame: this, info: undefined };
-    const world = options.expression === 'to.have.property' ? 'main' : (info?.world ?? 'utility');
-    const context = await race(frame._context(world));
-    const injected = await race(context.injectedScript());
-
-    const { log, matches, received, missingReceived } = await race(injected.evaluate(async (injected, { info, options, callId }) => {
-      const elements = info ? injected.querySelectorAll(info.parsed, document) : [];
-      if (callId)
-        injected.markTargetElements(new Set(elements), callId);
-      const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
-      let log = '';
-      if (isArray)
-        log = `  locator resolved to ${elements.length} element${elements.length === 1 ? '' : 's'}`;
-      else if (elements.length > 1)
-        throw injected.strictModeViolationError(info!.parsed, elements);
-      else if (elements.length)
-        log = `  locator resolved to ${injected.previewNode(elements[0])}`;
-      return { log, ...await injected.expect(elements[0], options, elements) };
-    }, { info, options, callId: progress.metadata.id }));
-
-    if (log)
-      progress.log(log);
-    // Note: missingReceived avoids `unexpected value "undefined"` when element was not found.
-    if (matches === options.isNot) {
-      if (missingReceived) {
-        lastIntermediateResult.errorMessage = 'Error: element(s) not found';
-      } else {
-        lastIntermediateResult.errorMessage = undefined;
-        lastIntermediateResult.received = received;
-      }
-      lastIntermediateResult.isSet = true;
-      if (!missingReceived && !Array.isArray(received))
-        progress.log(`  unexpected value "${renderUnexpectedValue(options.expression, received)}"`);
-    }
-    return { matches, received };
+
+          // The first expect check, a.k.a. one-shot, always finishes - even when progress is aborted.
+          const race = (p) => noAbort ? p : progress.race(p);
+          const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
+          var log, matches, received, missingReceived;
+          if (selector) {
+            const { frame, info } = await race(this.selectors.resolveFrameForSelector(selector, { strict: true }));
+            const action = async result => {
+              if (!result) {
+                if (options.expectedNumber === 0)
+                  return { matches: true };
+                // expect(locator).toBeHidden() passes when there is no element.
+                if (!options.isNot && options.expression === 'to.be.hidden')
+                  return { matches: true };
+                // expect(locator).not.toBeVisible() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.visible')
+                  return { matches: false };
+                // expect(locator).toBeAttached({ attached: false }) passes when there is no element.
+                if (!options.isNot && options.expression === 'to.be.detached')
+                  return { matches: true };
+                // expect(locator).not.toBeAttached() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.attached')
+                  return { matches: false };
+                // expect(locator).not.toBeInViewport() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.in.viewport')
+                  return { matches: false };
+                // When none of the above applies, expect does not match.
+                return { matches: options.isNot, missingReceived: true };
+              }
+
+              const handle = result[0];
+              const handles = result[1];
+
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                return await handle.parentNode.evaluateInUtility(async ([injected, node, { handle, options, handles }]) => {
+                  return await injected.expect(handle, options, handles);
+                }, { handle, options, handles });
+              } else {
+                return await handle.parentNode.evaluate(async (injected, { handle, options, handles }) => {
+                  return await injected.expect(handle, options, handles);
+                }, { handle, options, handles });
+              }
+            }
+
+            if (noAbort) {
+              var { log, matches, received, missingReceived } = await this._retryWithoutProgress(progress, selector, !isArray, false, action, 'returnAll', null);
+            } else {
+              var { log, matches, received, missingReceived } = await race(this._retryWithProgressIfNotConnected(progress, selector, !isArray, false, action, 'returnAll'));
+            }
+          } else {
+            const world = options.expression === 'to.have.property' ? 'main' : 'utility';
+            const context = await race(this._context(world));
+            const injected = await race(context.injectedScript());
+            var { matches, received, missingReceived } = await race(injected.evaluate(async (injected, { options, callId }) => {
+              return { ...await injected.expect(undefined, options, []) };
+            }, { options, callId: progress.metadata.id }));
+          }
+
+
+          if (log)
+            progress.log(log);
+          // Note: missingReceived avoids `unexpected value "undefined"` when element was not found.
+          if (matches === options.isNot) {
+            lastIntermediateResult.received = missingReceived ? '<element(s) not found>' : received;
+            lastIntermediateResult.isSet = true;
+            if (!missingReceived && !Array.isArray(received))
+              progress.log(`  unexpected value "${renderUnexpectedValue(options.expression, received)}"`);
+          }
+          return { matches, received };
+        
   }
 
   async waitForFunctionExpression<R>(progress: Progress, expression: string, isFunction: boolean | undefined, arg: any, options: { pollingInterval?: number }, world: types.World = 'main'): Promise<js.SmartHandle<R>> {
@@ -1577,29 +1692,58 @@
   }
 
   private async _callOnElementOnceMatches<T, R>(progress: Progress, selector: string, body: ElementCallback<T, R>, taskData: T, options: types.StrictOptions & { mainWorld?: boolean }, scope?: dom.ElementHandle): Promise<R> {
-    const callbackText = body.toString();
-    progress.log(`waiting for ${this._asLocator(selector)}`);
-    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved)
-        return continuePolling;
-      const { log, success, value } = await progress.race(resolved.injected.evaluate((injected, { info, callbackText, taskData, callId, root }) => {
-        const callback = injected.eval(callbackText) as ElementCallback<T, R>;
-        const element = injected.querySelector(info.parsed, root || document, info.strict);
-        if (!element)
-          return { success: false };
-        const log = `  locator resolved to ${injected.previewNode(element)}`;
-        if (callId)
-          injected.markTargetElements(new Set([element]), callId);
-        return { log, success: true, value: callback(injected, element, taskData as T) };
-      }, { info: resolved.info, callbackText, taskData, callId: progress.metadata.id, root: resolved.frame === this ? scope : undefined }));
-      if (log)
-        progress.log(log);
-      if (!success)
-        return continuePolling;
-      return value!;
-    });
-    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+
+          const callbackText = body.toString();
+          progress.log("waiting for "+ this._asLocator(selector));
+          var promise;
+          if (selector === ":scope") {
+            const scopeParentNode = scope.parentNode || scope;
+            if (scopeParentNode.constructor.name == "ElementHandle") {
+              promise = scopeParentNode.evaluateInUtility(([injected, node, { callbackText: callbackText2, scope: handle2, taskData: taskData2 }]) => {
+                const callback = injected.eval(callbackText2);
+                const haha = callback(injected, handle2, taskData2);
+                return haha;
+              }, {
+                callbackText,
+                scope,
+                taskData
+              });
+            } else {
+              promise = scopeParentNode.evaluate((injected, { callbackText: callbackText2, scope: handle2, taskData: taskData2 }) => {
+                const callback = injected.eval(callbackText2);
+                return callback(injected, handle2, taskData2);
+              }, {
+                callbackText,
+                scope,
+                taskData
+              });
+            }
+          } else {
+            promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, false, async (handle) => {
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                return await handle.parentNode.evaluateInUtility(([injected, node, { callbackText: callbackText2, handle: handle2, taskData: taskData2 }]) => {
+                  const callback = injected.eval(callbackText2);
+                  const haha = callback(injected, handle2, taskData2);
+                  return haha;
+                }, {
+                  callbackText,
+                  handle,
+                  taskData
+                });
+              } else {
+                return await handle.parentNode.evaluate((injected, { callbackText: callbackText2, handle: handle2, taskData: taskData2 }) => {
+                  const callback = injected.eval(callbackText2);
+                  return callback(injected, handle2, taskData2);
+                }, {
+                  callbackText,
+                  handle,
+                  taskData
+                });
+              }
+            })
+          }
+          return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+        
   }
 
   private _setContext(world: types.World, context: dom.FrameExecutionContext | null) {
@@ -1666,6 +1810,257 @@
   private _asLocator(selector: string) {
     return asLocator(this._page.browserContext._browser.sdkLanguage(), selector);
   }
+
+  _isolatedWorld: dom.FrameExecutionContext;
+  _mainWorld: dom.FrameExecutionContext;
+  _iframeWorld: dom.FrameExecutionContext;
+
+  async _getFrameMainFrameContextId(client): Promise<number> {
+
+          try {
+            var globalDocument = await client._sendMayFail("DOM.getFrameOwner", {frameId: this._id,});
+            if (globalDocument && globalDocument.nodeId) {
+              var describedNode = await client._sendMayFail("DOM.describeNode", {
+                backendNodeId: globalDocument.backendNodeId,
+              });
+              if (describedNode) {
+                var resolvedNode = await client._sendMayFail("DOM.resolveNode", {
+                  nodeId: describedNode.node.contentDocument.nodeId,
+                });
+                var _executionContextId = parseInt(resolvedNode.object.objectId.split(".")[1], 10);
+                return _executionContextId;
+              }
+            }
+          } catch (e) {}
+          return 0;
+        
+  }
+
+  async _retryWithoutProgress(progress, selector, strict, performActionPreChecks, action, returnAction, continuePolling) {
+
+          if (performActionPreChecks) await this._page.performActionPreChecks(progress);
+          const resolved = await this.selectors.resolveInjectedForSelector(selector, { strict });
+          if (!resolved) {
+            if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') {
+              const result = await action(null);
+              return result === "internal:continuepolling" ? continuePolling : result;
+            }
+            return continuePolling;
+          }
+
+          try {
+            var client = this._page.delegate._sessionForFrame(resolved.frame)._client;
+          } catch (e) {
+            var client = this._page.delegate._mainFrameSession._client;
+          }
+          var utilityContext = await resolved.frame._utilityContext();
+          var mainContext = await resolved.frame._mainContext();
+          const documentNode = await client._sendMayFail('Runtime.evaluate', {
+            expression: "document",
+            serializationOptions: {
+              serialization: "idOnly"
+            },
+            contextId: utilityContext.delegate._contextId,
+          });
+          if (!documentNode) return continuePolling;
+          const documentScope = new dom.ElementHandle(utilityContext, documentNode.result.objectId);
+
+          let currentScopingElements;
+          try {
+            currentScopingElements = await this._customFindElementsByParsed(resolved, client, mainContext, documentScope, progress, resolved.info.parsed);
+          } catch (e) {
+            if ("JSHandles can be evaluated only in the context they were created!" === e.message) return continuePolling3;
+            await progress.race(resolved.injected.evaluateHandle((injected, { error }) => { throw error }, { error: e }));
+          }
+
+          if (currentScopingElements.length == 0) {
+            // TODO: Dispose?
+            if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') {
+            const result = await action(null);
+            return result === "internal:continuepolling" ? continuePolling2 : result;
+          }
+            return continuePolling;
+          }
+          const resultElement = currentScopingElements[0];
+          if (currentScopingElements.length > 1) {
+            if (resolved.info.strict) {
+              await progress.race(resolved.injected.evaluateHandle((injected, {
+                info,
+                elements
+              }) => {
+                throw injected.strictModeViolationError(info.parsed, elements);
+              }, {
+                info: resolved.info,
+                elements: currentScopingElements
+              }));
+            }
+            progress.log("  locator resolved to " + currentScopingElements.length + " elements. Proceeding with the first one: " + resultElement.preview());
+          } else if (resultElement) {
+            progress.log("  locator resolved to " + resultElement.preview());
+          }
+
+          try {
+            var result = null;
+            if (returnAction === 'returnAll') {
+              result = await action([resultElement, currentScopingElements]);
+            } else {
+              result = await action(resultElement);
+            }
+            if (result === 'error:notconnected') {
+              progress.log('element was detached from the DOM, retrying');
+              return continuePolling;
+            } else if (result === 'internal:continuepolling') {
+              return continuePolling;
+            }
+            return result;
+          } finally {}
+        
+  }
+
+  async _customFindElementsByParsed(resolved, client, context, documentScope, progress, parsed) {
+
+          var parsedEdits = { ...parsed };
+          // Note: We start scoping at document level
+          var currentScopingElements = [documentScope];
+          while (parsed.parts.length > 0) {
+            var part = parsed.parts.shift();
+            parsedEdits.parts = [part];
+            // Getting All Elements
+            var elements = [];
+            var elementsIndexes = [];
+
+            if (part.name == "nth") {
+              const partNth = Number(part.body);
+              // Check if any Elements are currently scoped, else return empty array to continue polling
+              if (currentScopingElements.length == 0) return [];
+              // Check if the partNth is within the bounds of currentScopingElements
+              if (partNth > currentScopingElements.length-1 || partNth < -(currentScopingElements.length-1)) {
+                if (parsed.capture !== undefined) throw new Error("Can't query n-th element in a request with the capture.");
+                return [];
+              } else {
+                currentScopingElements = [currentScopingElements.at(partNth)];
+                continue;
+              }
+            } else if (part.name == "internal:or") {
+              var orredElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+              elements = currentScopingElements.concat(orredElements);
+            } else if (part.name == "internal:and") {
+              var andedElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+              const backendNodeIds = new Set(andedElements.map(item => item.backendNodeId));
+              elements = currentScopingElements.filter(item => backendNodeIds.has(item.backendNodeId));
+            } else {
+              for (const scope of currentScopingElements) {
+                const describedScope = await client.send('DOM.describeNode', {
+                  objectId: scope._objectId,
+                  depth: -1,
+                  pierce: true
+                });
+
+                // Elements Queryed in the "current round"
+                var queryingElements = [];
+                function findClosedShadowRoots(node, results = []) {
+                  if (!node || typeof node !== 'object') return results;
+                  if (node.shadowRoots && Array.isArray(node.shadowRoots)) {
+                    for (const shadowRoot of node.shadowRoots) {
+                      if (shadowRoot.shadowRootType === 'closed' && shadowRoot.backendNodeId) {
+                        results.push(shadowRoot.backendNodeId);
+                      }
+                      findClosedShadowRoots(shadowRoot, results);
+                    }
+                  }
+                  if (node.nodeName !== 'IFRAME' && node.children && Array.isArray(node.children)) {
+                    for (const child of node.children) {
+                      findClosedShadowRoots(child, results);
+                    }
+                  }
+                  return results;
+                }
+
+                var shadowRootBackendIds = findClosedShadowRoots(describedScope.node);
+                var shadowRoots = [];
+                for (var shadowRootBackendId of shadowRootBackendIds) {
+                  var resolvedShadowRoot = await client.send('DOM.resolveNode', {
+                    backendNodeId: shadowRootBackendId,
+                    contextId: context.delegate._contextId
+                  });
+                  shadowRoots.push(new dom.ElementHandle(context, resolvedShadowRoot.object.objectId));
+                }
+
+                for (var shadowRoot of shadowRoots) {
+                  const shadowElements = await shadowRoot.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+                   const elements = injected.querySelectorAll(parsed, node);
+                    if (callId) injected.markTargetElements(new Set(elements), callId);
+                    return elements
+                  }, {
+                    parsed: parsedEdits,
+                    callId: progress.metadata.id
+                  });
+
+                  const shadowElementsAmount = await shadowElements.getProperty("length");
+                  queryingElements.push([shadowElements, shadowElementsAmount, shadowRoot]);
+                }
+
+                // Document Root Elements (not in CSR)
+                const rootElements = await scope.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+                  const elements = injected.querySelectorAll(parsed, node);
+                  if (callId) injected.markTargetElements(new Set(elements), callId);
+                  return elements
+                }, {
+                  parsed: parsedEdits,
+                  callId: progress.metadata.id
+                });
+                const rootElementsAmount = await rootElements.getProperty("length");
+                queryingElements.push([rootElements, rootElementsAmount, scope]);
+
+                // Querying and Sorting the elements by their backendNodeId
+                for (var queryedElement of queryingElements) {
+                  var elementsToCheck = queryedElement[0];
+                  var elementsAmount = await queryedElement[1].jsonValue();
+                  var parentNode = queryedElement[2];
+                  for (var i = 0; i < elementsAmount; i++) {
+                    if (parentNode.constructor.name == "ElementHandle") {
+                      var elementToCheck = await parentNode.evaluateHandleInUtility(([injected, node, { index, elementsToCheck }]) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+                    } else {
+                      var elementToCheck = await parentNode.evaluateHandle((injected, { index, elementsToCheck }) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+                    }
+                    // For other Functions/Utilities
+                    elementToCheck.parentNode = parentNode;
+                    var resolvedElement = await client.send('DOM.describeNode', {
+                      objectId: elementToCheck._objectId,
+                      depth: -1,
+                    });
+                    // Note: Possible Bug, Maybe well actually have to check the Documents Node Position instead of using the backendNodeId
+                    elementToCheck.backendNodeId = resolvedElement.node.backendNodeId;
+                    elementToCheck.nodePosition = this.selectors._findElementPositionInDomTree(elementToCheck, describedScope.node, context, "");
+                    elements.push(elementToCheck);
+                  }
+                }
+              }
+            }
+
+            // Sorting elements by their nodePosition, which is a index to the Element in the DOM tree
+            const getParts = (pos) => (pos || '').split('').map(Number);
+            elements.sort((a, b) => {
+              const partA = getParts(a.nodePosition);
+              const partB = getParts(b.nodePosition);
+              const maxLength = Math.max(partA.length, partB.length);
+
+              for (let i = 0; i < maxLength; i++) {
+                const aVal = partA[i] ?? -1;
+                const bVal = partB[i] ?? -1;
+                if (aVal !== bVal) return aVal - bVal;
+              }
+              return 0;
+            });
+
+            // Remove duplicates by backendNodeId, keeping the first occurrence
+            currentScopingElements = Array.from(
+              new Map(elements.map((e) => [e.backendNodeId, e])).values()
+            );
+          }
+          return currentScopingElements;
+        
+  }
 }
 
 class SignalBarrier {
diff -ruN playwright/node_modules/playwright-core/src/server/javascript.ts patchright/node_modules/playwright-core/src/server/javascript.ts
---
+++
@@ -149,17 +149,37 @@
     return evaluate(this._context, false /* returnByValue */, pageFunction, this, arg);
   }
 
-  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any) {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: true }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean) {
 
-  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any): Promise<JSHandle<any>> {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: false }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+          let context = this._context;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: true }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
+
+  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean): Promise<JSHandle<any>> {
+
+          let context = this._context;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = this._context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: false }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
 
   async getProperty(propertyName: string): Promise<JSHandle> {
     const objectHandle = await this.evaluateHandle((object: any, propertyName) => {
diff -ruN playwright/node_modules/playwright-core/src/server/page.ts patchright/node_modules/playwright-core/src/server/page.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import { createPageBindingScript, deliverBindingResult, takeBindingHandle } from './pageBinding';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -303,30 +305,25 @@
   }
 
   async exposeBinding(progress: Progress, name: string, needsHandle: boolean, playwrightBinding: frames.FunctionWithSource): Promise<PageBinding> {
-    if (this._pageBindings.has(name))
-      throw new Error(`Function "${name}" has been already registered`);
-    if (this.browserContext._pageBindings.has(name))
-      throw new Error(`Function "${name}" has been already registered in the browser context`);
-    await progress.race(this.browserContext.exposePlaywrightBindingIfNeeded());
-    const binding = new PageBinding(name, playwrightBinding, needsHandle);
-    this._pageBindings.set(name, binding);
-    try {
-      await progress.race(this.delegate.addInitScript(binding.initScript));
-      await progress.race(this.safeNonStallingEvaluateInAllFrames(binding.initScript.source, 'main'));
-      return binding;
-    } catch (error) {
-      this._pageBindings.delete(name);
-      throw error;
-    }
+
+          if (this._pageBindings.has(name))
+            throw new Error(`Function "${name}" has been already registered`);
+          if (this.browserContext._pageBindings.has(name))
+            throw new Error(`Function "${name}" has been already registered in the browser context`);
+          const binding = new PageBinding(name, playwrightBinding, needsHandle);
+          this._pageBindings.set(name, binding);
+          await this.delegate.exposeBinding(binding);
+        
   }
 
   async removeExposedBindings(bindings: PageBinding[]) {
-    bindings = bindings.filter(binding => this._pageBindings.get(binding.name) === binding);
-    for (const binding of bindings)
-      this._pageBindings.delete(binding.name);
-    await this.delegate.removeInitScripts(bindings.map(binding => binding.initScript));
-    const cleanup = bindings.map(binding => `{ ${binding.cleanupScript} };\n`).join('');
-    await this.safeNonStallingEvaluateInAllFrames(cleanup, 'main');
+
+          for (const key of this._pageBindings.keys()) {
+            if (!key.startsWith('__pw'))
+              this._pageBindings.delete(key);
+          }
+          await this.delegate.removeExposedBindings();
+        
   }
 
   async setExtraHTTPHeaders(progress: Progress, headers: types.HeadersArray) {
@@ -612,9 +609,10 @@
   }
 
   async removeInitScripts(initScripts: InitScript[]) {
-    const set = new Set(initScripts);
-    this.initScripts = this.initScripts.filter(script => !set.has(script));
-    await this.delegate.removeInitScripts(initScripts);
+
+          this.initScripts.splice(0, this.initScripts.length);
+          await this.delegate.removeInitScripts();
+        
   }
 
   needsRequestInterception(): boolean {
@@ -816,13 +814,6 @@
       this.browserContext.addVisitedOrigin(origin);
   }
 
-  allInitScripts() {
-    const bindings = [...this.browserContext._pageBindings.values(), ...this._pageBindings.values()].map(binding => binding.initScript);
-    if (this.browserContext.bindingsInitScript)
-      bindings.unshift(this.browserContext.bindingsInitScript);
-    return [...bindings, ...this.browserContext.initScripts, ...this.initScripts];
-  }
-
   getBinding(name: string) {
     return this._pageBindings.get(name) || this.browserContext._pageBindings.get(name);
   }
@@ -860,6 +851,12 @@
     const snapshot = await snapshotFrameForAI(progress, this.mainFrame(), options);
     return { full: snapshot.full.join('\n'), incremental: snapshot.incremental?.join('\n') };
   }
+
+  allBindings() {
+
+          return [...this.browserContext._pageBindings.values(), ...this._pageBindings.values()];
+        
+  }
 }
 
 export class Worker extends SdkObject {
@@ -898,77 +895,82 @@
     this.openScope.close(new Error('Worker closed'));
   }
 
-  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: true, isFunction }, arg);
-  }
+  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
 
-  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: false, isFunction }, arg);
-  }
-}
+          let context = await this._executionContextPromise;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      return js.evaluateExpression(context, expression, { returnByValue: true, isFunction }, arg);
+    }
 
-export class PageBinding {
-  private static kController = '__playwright__binding__controller__';
-  static kBindingName = '__playwright__binding__';
-
-  static createInitScript() {
-    return new InitScript(`
-      (() => {
-        const module = {};
-        ${rawBindingsControllerSource.source}
-        const property = '${PageBinding.kController}';
-        if (!globalThis[property])
-          globalThis[property] = new (module.exports.BindingsController())(globalThis, '${PageBinding.kBindingName}');
-      })();
-    `);
-  }
-
-  readonly name: string;
-  readonly playwrightFunction: frames.FunctionWithSource;
-  readonly initScript: InitScript;
-  readonly needsHandle: boolean;
-  readonly cleanupScript: string;
-  forClient?: unknown;
-
-  constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean) {
-    this.name = name;
-    this.playwrightFunction = playwrightFunction;
-    this.initScript = new InitScript(`globalThis['${PageBinding.kController}'].addBinding(${JSON.stringify(name)}, ${needsHandle})`);
-    this.needsHandle = needsHandle;
-    this.cleanupScript = `globalThis['${PageBinding.kController}'].removeBinding(${JSON.stringify(name)})`;
-  }
+  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
 
-  static async dispatch(page: Page, payload: string, context: dom.FrameExecutionContext) {
-    const { name, seq, serializedArgs } = JSON.parse(payload) as BindingPayload;
-    try {
-      assert(context.world);
-      const binding = page.getBinding(name);
-      if (!binding)
-        throw new Error(`Function "${name}" is not exposed`);
-      let result: any;
-      if (binding.needsHandle) {
-        const handle = await context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].takeBindingHandle(arg)`, { isFunction: true }, { name, seq }).catch(e => null);
-        result = await binding.playwrightFunction({ frame: context.frame, page, context: page.browserContext }, handle);
-      } else {
-        if (!Array.isArray(serializedArgs))
-          throw new Error(`serializedArgs is not an array. This can happen when Array.prototype.toJSON is defined incorrectly`);
-        const args = serializedArgs!.map(a => parseEvaluationResultValue(a));
-        result = await binding.playwrightFunction({ frame: context.frame, page, context: page.browserContext }, ...args);
-      }
-      context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq, result }).catch(e => debugLogger.log('error', e));
-    } catch (error) {
-      context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq, error }).catch(e => debugLogger.log('error', e));
+          let context = await this._executionContextPromise;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = this._context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      return js.evaluateExpression(context, expression, { returnByValue: false, isFunction }, arg);
     }
-  }
 }
 
+
+      export class PageBinding {
+        readonly source: string;
+        readonly name: string;
+        readonly playwrightFunction: frames.FunctionWithSource;
+        readonly needsHandle: boolean;
+        readonly internal: boolean;
+
+        constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean) {
+          this.name = name;
+          this.playwrightFunction = playwrightFunction;
+          this.source = createPageBindingScript(name, needsHandle);
+          this.needsHandle = needsHandle;
+        }
+
+        static async dispatch(page: Page, payload: string, context: dom.FrameExecutionContext) {
+          const { name, seq, serializedArgs } = JSON.parse(payload) as BindingPayload;
+          try {
+            assert(context.world);
+            const binding = page.getBinding(name);
+            if (!binding)
+              throw new Error(`Function "${name}" is not exposed`);
+            let result: any;
+            if (binding.needsHandle) {
+              const handle = await context.evaluateHandle(takeBindingHandle, { name, seq }).catch(e => null);
+              result = await binding.playwrightFunction({ frame: context.frame, page, context: page._browserContext }, handle);
+            } else {
+              if (!Array.isArray(serializedArgs))
+                throw new Error(`serializedArgs is not an array. This can happen when Array.prototype.toJSON is defined incorrectly`);
+              const args = serializedArgs!.map(a => parseEvaluationResultValue(a));
+              result = await binding.playwrightFunction({ frame: context.frame, page, context: page._browserContext }, ...args);
+            }
+            context.evaluate(deliverBindingResult, { name, seq, result }).catch(e => debugLogger.log('error', e));
+          } catch (error) {
+            context.evaluate(deliverBindingResult, { name, seq, error }).catch(e => debugLogger.log('error', e));
+          }
+        }
+      }
+    
+
 export class InitScript {
   readonly source: string;
 
   constructor(source: string) {
-    this.source = `(() => {
-      ${source}
-    })();`;
+    
+            this.source = `(() => { ${source} })();`;
+          
   }
 }
 
diff -ruN playwright/node_modules/playwright-core/src/server/pageBinding.ts patchright/node_modules/playwright-core/src/server/pageBinding.ts
---
+++
@@ -0,0 +1,91 @@
+
+      /**
+       * Copyright (c) Microsoft Corporation.
+       *
+       * Licensed under the Apache License, Version 2.0 (the "License");
+       * you may not use this file except in compliance with the License.
+       * You may obtain a copy of the License at
+       *
+       * http://www.apache.org/licenses/LICENSE-2.0
+       *
+       * Unless required by applicable law or agreed to in writing, software
+       * distributed under the License is distributed on an "AS IS" BASIS,
+       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+       * See the License for the specific language governing permissions and
+       * limitations under the License.
+       */
+      import { source } from '../utils/isomorphic/oldUtilityScriptSerializers';
+
+      import type { SerializedValue } from '../utils/isomorphic/oldUtilityScriptSerializers';
+
+      export type BindingPayload = {
+        name: string;
+        seq: number;
+        serializedArgs?: SerializedValue[],
+      };
+
+      function addPageBinding(bindingName: string, needsHandle: boolean, utilityScriptSerializersFactory: typeof source) {
+        const { serializeAsCallArgument } = utilityScriptSerializersFactory;
+        // eslint-disable-next-line no-restricted-globals
+        const binding = (globalThis as any)[bindingName];
+        if (!binding || binding.toString().startsWith("(...args) => {")) return
+        // eslint-disable-next-line no-restricted-globals
+        (globalThis as any)[bindingName] = (...args: any[]) => {
+        // eslint-disable-next-line no-restricted-globals
+          const me = (globalThis as any)[bindingName];
+          if (needsHandle && args.slice(1).some(arg => arg !== undefined))
+            throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
+          let callbacks = me['callbacks'];
+          if (!callbacks) {
+            callbacks = new Map();
+            me['callbacks'] = callbacks;
+          }
+          const seq: number = (me['lastSeq'] || 0) + 1;
+          me['lastSeq'] = seq;
+          let handles = me['handles'];
+          if (!handles) {
+            handles = new Map();
+            me['handles'] = handles;
+          }
+          const promise = new Promise((resolve, reject) => callbacks.set(seq, { resolve, reject }));
+          let payload: BindingPayload;
+          if (needsHandle) {
+            handles.set(seq, args[0]);
+            payload = { name: bindingName, seq };
+          } else {
+            const serializedArgs = [];
+            for (let i = 0; i < args.length; i++) {
+              serializedArgs[i] = serializeAsCallArgument(args[i], v => {
+                return { fallThrough: v };
+              });
+            }
+            payload = { name: bindingName, seq, serializedArgs };
+          }
+          binding(JSON.stringify(payload));
+          return promise;
+        };
+        // eslint-disable-next-line no-restricted-globals
+      }
+
+      export function takeBindingHandle(arg: { name: string, seq: number }) {
+        // eslint-disable-next-line no-restricted-globals
+        const handles = (globalThis as any)[arg.name]['handles'];
+        const handle = handles.get(arg.seq);
+        handles.delete(arg.seq);
+        return handle;
+      }
+
+      export function deliverBindingResult(arg: { name: string, seq: number, result?: any, error?: any }) {
+        // eslint-disable-next-line no-restricted-globals
+        const callbacks = (globalThis as any)[arg.name]['callbacks'];
+        if ('error' in arg)
+          callbacks.get(arg.seq).reject(arg.error);
+        else
+          callbacks.get(arg.seq).resolve(arg.result);
+        callbacks.delete(arg.seq);
+      }
+
+      export function createPageBindingScript(name: string, needsHandle: boolean) {
+        return `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle}, (${source})())`;
+      }
+    
\ No newline at end of file
diff -ruN playwright/node_modules/playwright-core/src/server/registry/index.ts patchright/node_modules/playwright-core/src/server/registry/index.ts
---
+++
@@ -1457,7 +1457,7 @@
       return `pwsh bin/Debug/netX/playwright.ps1 ${parameters}`;
     default: {
       const packageManagerCommand = getPackageManagerExecCommand();
-      return `${packageManagerCommand} playwright ${parameters}`;
+      return `${packageManagerCommand} patchright ${parameters}`;
     }
   }
 }
diff -ruN playwright/node_modules/playwright-core/src/utils/isomorphic/oldUtilityScriptSerializers.ts patchright/node_modules/playwright-core/src/utils/isomorphic/oldUtilityScriptSerializers.ts
---
+++
@@ -0,0 +1,292 @@
+
+      /**
+       * Copyright (c) Microsoft Corporation.
+       *
+       * Licensed under the Apache License, Version 2.0 (the "License");
+       * you may not use this file except in compliance with the License.
+       * You may obtain a copy of the License at
+       *
+       * http://www.apache.org/licenses/LICENSE-2.0
+       *
+       * Unless required by applicable law or agreed to in writing, software
+       * distributed under the License is distributed on an "AS IS" BASIS,
+       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+       * See the License for the specific language governing permissions and
+       * limitations under the License.
+       */
+
+      type TypedArrayKind = 'i8' | 'ui8' | 'ui8c' | 'i16' | 'ui16' | 'i32' | 'ui32' | 'f32' | 'f64' | 'bi64' | 'bui64';
+
+      export type SerializedValue =
+          undefined | boolean | number | string |
+          { v: 'null' | 'undefined' | 'NaN' | 'Infinity' | '-Infinity' | '-0' } |
+          { d: string } |
+          { u: string } |
+          { bi: string } |
+          { e: { n: string, m: string, s: string } } |
+          { r: { p: string, f: string } } |
+          { a: SerializedValue[], id: number } |
+          { o: { k: string, v: SerializedValue }[], id: number } |
+          { ref: number } |
+          { h: number } |
+          { ta: { b: string, k: TypedArrayKind } };
+
+      type HandleOrValue = { h: number } | { fallThrough: any };
+
+      type VisitorInfo = {
+        visited: Map<object, number>;
+        lastId: number;
+      };
+
+      export function source() {
+
+        function isRegExp(obj: any): obj is RegExp {
+          try {
+            return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isDate(obj: any): obj is Date {
+          try {
+            return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isURL(obj: any): obj is URL {
+          try {
+            return obj instanceof URL || Object.prototype.toString.call(obj) === '[object URL]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isError(obj: any): obj is Error {
+          try {
+            return obj instanceof Error || (obj && Object.getPrototypeOf(obj)?.name === 'Error');
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isTypedArray(obj: any, constructor: Function): boolean {
+          try {
+            return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;
+          } catch (error) {
+            return false;
+          }
+        }
+
+        const typedArrayConstructors: Record<TypedArrayKind, Function> = {
+          i8: Int8Array,
+          ui8: Uint8Array,
+          ui8c: Uint8ClampedArray,
+          i16: Int16Array,
+          ui16: Uint16Array,
+          i32: Int32Array,
+          ui32: Uint32Array,
+          // TODO: add Float16Array once it's in baseline
+          f32: Float32Array,
+          f64: Float64Array,
+          bi64: BigInt64Array,
+          bui64: BigUint64Array,
+        };
+
+        function typedArrayToBase64(array: any) {
+          /**
+           * Firefox does not support iterating over typed arrays, so we use `.toBase64`.
+           * Error: 'Accessing TypedArray data over Xrays is slow, and forbidden in order to encourage performant code. To copy TypedArrays across origin boundaries, consider using Components.utils.cloneInto().'
+           */
+          if ('toBase64' in array)
+            return array.toBase64();
+          const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map(b => String.fromCharCode(b)).join('');
+          return btoa(binary);
+        }
+
+        function base64ToTypedArray(base64: string, TypedArrayConstructor: any) {
+          const binary = atob(base64);
+          const bytes = new Uint8Array(binary.length);
+          for (let i = 0; i < binary.length; i++)
+            bytes[i] = binary.charCodeAt(i);
+          return new TypedArrayConstructor(bytes.buffer);
+        }
+
+        function parseEvaluationResultValue(value: SerializedValue, handles: any[] = [], refs: Map<number, object> = new Map()): any {
+          if (Object.is(value, undefined))
+            return undefined;
+          if (typeof value === 'object' && value) {
+            if ('ref' in value)
+              return refs.get(value.ref);
+            if ('v' in value) {
+              if (value.v === 'undefined')
+                return undefined;
+              if (value.v === 'null')
+                return null;
+              if (value.v === 'NaN')
+                return NaN;
+              if (value.v === 'Infinity')
+                return Infinity;
+              if (value.v === '-Infinity')
+                return -Infinity;
+              if (value.v === '-0')
+                return -0;
+              return undefined;
+            }
+            if ('d' in value)
+              return new Date(value.d);
+            if ('u' in value)
+              return new URL(value.u);
+            if ('bi' in value)
+              return BigInt(value.bi);
+            if ('e' in value) {
+              const error = new Error(value.e.m);
+              error.name = value.e.n;
+              error.stack = value.e.s;
+              return error;
+            }
+            if ('r' in value)
+              return new RegExp(value.r.p, value.r.f);
+            if ('a' in value) {
+              const result: any[] = [];
+              refs.set(value.id, result);
+              for (const a of value.a)
+                result.push(parseEvaluationResultValue(a, handles, refs));
+              return result;
+            }
+            if ('o' in value) {
+              const result: any = {};
+              refs.set(value.id, result);
+              for (const { k, v } of value.o)
+                result[k] = parseEvaluationResultValue(v, handles, refs);
+              return result;
+            }
+            if ('h' in value)
+              return handles[value.h];
+            if ('ta' in value)
+              return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);
+          }
+          return value;
+        }
+
+        function serializeAsCallArgument(value: any, handleSerializer: (value: any) => HandleOrValue): SerializedValue {
+          return serialize(value, handleSerializer, { visited: new Map(), lastId: 0 });
+        }
+
+        function serialize(value: any, handleSerializer: (value: any) => HandleOrValue, visitorInfo: VisitorInfo): SerializedValue {
+          if (value && typeof value === 'object') {
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Window === 'function' && value instanceof globalThis.Window)
+              return 'ref: <Window>';
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Document === 'function' && value instanceof globalThis.Document)
+              return 'ref: <Document>';
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Node === 'function' && value instanceof globalThis.Node)
+              return 'ref: <Node>';
+          }
+          return innerSerialize(value, handleSerializer, visitorInfo);
+        }
+
+        function innerSerialize(value: any, handleSerializer: (value: any) => HandleOrValue, visitorInfo: VisitorInfo): SerializedValue {
+          const result = handleSerializer(value);
+          if ('fallThrough' in result)
+            value = result.fallThrough;
+          else
+            return result;
+
+          if (typeof value === 'symbol')
+            return { v: 'undefined' };
+          if (Object.is(value, undefined))
+            return { v: 'undefined' };
+          if (Object.is(value, null))
+            return { v: 'null' };
+          if (Object.is(value, NaN))
+            return { v: 'NaN' };
+          if (Object.is(value, Infinity))
+            return { v: 'Infinity' };
+          if (Object.is(value, -Infinity))
+            return { v: '-Infinity' };
+          if (Object.is(value, -0))
+            return { v: '-0' };
+
+          if (typeof value === 'boolean')
+            return value;
+          if (typeof value === 'number')
+            return value;
+          if (typeof value === 'string')
+            return value;
+          if (typeof value === 'bigint')
+            return { bi: value.toString() };
+
+          if (isError(value)) {
+            let stack;
+            if (value.stack?.startsWith(value.name + ': ' + value.message)) {
+              // v8
+              stack = value.stack;
+            } else {
+              stack = `${value.name}: ${value.message}
+${value.stack}`;
+            }
+            return { e: { n: value.name, m: value.message, s: stack } };
+          }
+          if (isDate(value))
+            return { d: value.toJSON() };
+          if (isURL(value))
+            return { u: value.toJSON() };
+          if (isRegExp(value))
+            return { r: { p: value.source, f: value.flags } };
+          for (const [k, ctor] of Object.entries(typedArrayConstructors) as [TypedArrayKind, Function][]) {
+            if (isTypedArray(value, ctor))
+              return { ta: { b: typedArrayToBase64(value), k } };
+          }
+
+          const id = visitorInfo.visited.get(value);
+          if (id)
+            return { ref: id };
+
+          if (Array.isArray(value)) {
+            const a = [];
+            const id = ++visitorInfo.lastId;
+            visitorInfo.visited.set(value, id);
+            for (let i = 0; i < value.length; ++i)
+              a.push(serialize(value[i], handleSerializer, visitorInfo));
+            return { a, id };
+          }
+
+          if (typeof value === 'object') {
+            const o: { k: string, v: SerializedValue }[] = [];
+            const id = ++visitorInfo.lastId;
+            visitorInfo.visited.set(value, id);
+            for (const name of Object.keys(value)) {
+              let item;
+              try {
+                item = value[name];
+              } catch (e) {
+                continue;  // native bindings will throw sometimes
+              }
+              if (name === 'toJSON' && typeof item === 'function')
+                o.push({ k: name, v: { o: [], id: 0 } });
+              else
+                o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });
+            }
+
+            let jsonWrapper;
+            try {
+              // If Object.keys().length === 0 we fall back to toJSON if it exists
+              if (o.length === 0 && value.toJSON && typeof value.toJSON === 'function')
+                jsonWrapper = { value: value.toJSON() };
+            } catch (e) {
+            }
+            if (jsonWrapper)
+              return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);
+
+            return { o, id };
+          }
+        }
+
+        return { parseEvaluationResultValue, serializeAsCallArgument };
+      }
+    
\ No newline at end of file
diff -ruN playwright/node_modules/recorder/src/recorder.tsx patchright/node_modules/recorder/src/recorder.tsx
---
+++
@@ -56,7 +56,7 @@
   window.playwrightSelectSource = selectedSourceId => setSelectedFileId(selectedSourceId);
 
   React.useEffect(() => {
-    window.dispatch({ event: 'setAutoExpect', params: { autoExpect } });
+    try { window.dispatch({ event: 'setAutoExpect', params: { autoExpect } }); } catch {}
   }, [autoExpect]);
 
   const source = React.useMemo(() => {
diff -ruN playwright/packages/injected/src/xpathSelectorEngine.ts patchright/packages/injected/src/xpathSelectorEngine.ts
---
+++
@@ -18,6 +18,43 @@
 
 export const XPathEngine: SelectorEngine = {
   queryAll(root: SelectorRoot, selector: string): Element[] {
+
+          if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
+            const result: Element[] = [];
+            // Custom ClosedShadowRoot XPath Engine
+            const parser = new DOMParser();
+            // Function to (recursively) get all elements in the shadowRoot
+            function getAllChildElements(node) {
+              const elements = [];
+              const traverse = (currentNode) => {
+                if (currentNode.nodeType === Node.ELEMENT_NODE) elements.push(currentNode);
+                currentNode.childNodes?.forEach(traverse);
+              };
+              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE) {
+                traverse(node);
+              }
+              return elements;
+            }
+            // Setting innerHTMl and childElements (all, recursive) to avoid race conditions
+            const csrHTMLContent = root.innerHTML;
+            const csrChildElements = getAllChildElements(root);
+            const htmlDoc = parser.parseFromString(csrHTMLContent, 'text/html');
+            const rootDiv = htmlDoc.body
+            const rootDivChildElements = getAllChildElements(rootDiv);
+            // Use the namespace prefix in the XPath expression
+            const it = htmlDoc.evaluate(selector, htmlDoc, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
+            for (let node = it.iterateNext(); node; node = it.iterateNext()) {
+              // -1 for the body element
+              const nodeIndex = rootDivChildElements.indexOf(node) - 1;
+              if (nodeIndex >= 0) {
+                const originalNode = csrChildElements[nodeIndex];
+                if (originalNode.nodeType === Node.ELEMENT_NODE)
+                  result.push(originalNode as Element);
+              }
+            }
+            return result;
+          }
+        
     if (selector.startsWith('/') && root.nodeType !== Node.DOCUMENT_NODE)
       selector = '.' + selector;
     const result: Element[] = [];
diff -ruN playwright/packages/playwright-core/src/server/browserContext.ts patchright/packages/playwright-core/src/server/browserContext.ts
---
+++
@@ -146,7 +146,7 @@
       `);
     }
     if (this._options.serviceWorkers === 'block')
-      await this.addInitScript(undefined, `\nif (navigator.serviceWorker) navigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };\n`);
+      await this.addInitScript(undefined, `navigator.serviceWorker.register = async () => { };`);
 
     if (this._options.permissions)
       await this.grantPermissions(this._options.permissions);
@@ -326,27 +326,19 @@
       if (page.getBinding(name))
         throw new Error(`Function "${name}" has been already registered in one of the pages`);
     }
-    await progress.race(this.exposePlaywrightBindingIfNeeded());
     const binding = new PageBinding(name, playwrightBinding, needsHandle);
     binding.forClient = forClient;
     this._pageBindings.set(name, binding);
-    try {
-      await progress.race(this.doAddInitScript(binding.initScript));
-      await progress.race(this.safeNonStallingEvaluateInAllFrames(binding.initScript.source, 'main'));
-      return binding;
-    } catch (error) {
-      this._pageBindings.delete(name);
-      throw error;
-    }
+    await this.doExposeBinding(binding);
   }
 
   async removeExposedBindings(bindings: PageBinding[]) {
-    bindings = bindings.filter(binding => this._pageBindings.get(binding.name) === binding);
-    for (const binding of bindings)
-      this._pageBindings.delete(binding.name);
-    await this.doRemoveInitScripts(bindings.map(binding => binding.initScript));
-    const cleanup = bindings.map(binding => `{ ${binding.cleanupScript} };\n`).join('');
-    await this.safeNonStallingEvaluateInAllFrames(cleanup, 'main');
+
+          for (const key of this._pageBindings.keys()) {
+            if (!key.startsWith('__pw')) this._pageBindings.delete(key);
+          }
+          await this.doRemoveExposedBindings();
+        
   }
 
   async grantPermissions(permissions: string[], origin?: string) {
@@ -463,9 +455,10 @@
   }
 
   async removeInitScripts(initScripts: InitScript[]) {
-    const set = new Set(initScripts);
-    this.initScripts = this.initScripts.filter(script => !set.has(script));
-    await this.doRemoveInitScripts(initScripts);
+
+          this.initScripts.splice(0, this.initScripts.length);
+          await this.doRemoveInitScripts();
+          
   }
 
   async addRequestInterceptor(progress: Progress, handler: network.RouteHandler): Promise<void> {
@@ -815,4 +808,5 @@
   strictSelectors: false,
   serviceWorkers: 'allow',
   locale: 'en-US',
+  focusControl: false
 };
diff -ruN playwright/packages/playwright-core/src/server/chromium/chromiumSwitches.ts patchright/packages/playwright-core/src/server/chromium/chromiumSwitches.ts
---
+++
@@ -51,26 +51,16 @@
   '--disable-field-trial-config', // https://source.chromium.org/chromium/chromium/src/+/main:testing/variations/README.md
   '--disable-background-networking',
   '--disable-background-timer-throttling',
-  '--disable-backgrounding-occluded-windows',
-  '--disable-back-forward-cache', // Avoids surprises like main request not being intercepted during page.goBack().
-  '--disable-breakpad',
-  '--disable-client-side-phishing-detection',
-  '--disable-component-extensions-with-background-pages',
-  '--disable-component-update', // Avoids unneeded network activity after startup.
+  '--disable-backgrounding-occluded-windows', // Avoids surprises like main request not being intercepted during page.goBack().
+  '--disable-breakpad', // Avoids unneeded network activity after startup.
   '--no-default-browser-check',
-  '--disable-default-apps',
   '--disable-dev-shm-usage',
-  '--disable-extensions',
   '--disable-features=' + disabledFeatures(assistantMode).join(','),
   process.env.PLAYWRIGHT_LEGACY_SCREENSHOT ? '' : '--enable-features=CDPScreenshotNewSurface',
-  '--allow-pre-commit-input',
   '--disable-hang-monitor',
-  '--disable-ipc-flooding-protection',
-  '--disable-popup-blocking',
   '--disable-prompt-on-repost',
   '--disable-renderer-backgrounding',
   '--force-color-profile=srgb',
-  '--metrics-recording-only',
   '--no-first-run',
   '--password-store=basic',
   '--use-mock-keychain',
@@ -79,11 +69,8 @@
   '--export-tagged-pdf',
   // https://chromium-review.googlesource.com/c/chromium/src/+/4853540
   '--disable-search-engine-choice-screen',
-  // https://issues.chromium.org/41491762
-  '--unsafely-disable-devtools-self-xss-warnings',
   // Edge can potentially restart on Windows (msRelaunchNoCompatLayer) which looses its file descriptors (stdout/stderr) and CDP (3/4). Disable until fixed upstream.
   '--edge-skip-compat-layer-relaunch',
-  assistantMode ? '' : '--enable-automation',
   // This disables Chrome for Testing infobar that is visible in the persistent context.
   // The switch is ignored everywhere else, including Chromium/Chrome/Edge.
   '--disable-infobars',
@@ -91,4 +78,5 @@
   '--disable-search-engine-choice-screen',
   // Prevents the "three dots" menu crash in IdentityManager::HasPrimaryAccount for ephemeral contexts.
   android ? '' : '--disable-sync',
+  '--disable-blink-features=AutomationControlled'
 ].filter(Boolean);
diff -ruN playwright/packages/playwright-core/src/server/chromium/crBrowser.ts patchright/packages/playwright-core/src/server/chromium/crBrowser.ts
---
+++
@@ -501,8 +501,9 @@
   }
 
   async doRemoveInitScripts(initScripts: InitScript[]) {
-    for (const page of this.pages())
-      await (page.delegate as CRPage).removeInitScripts(initScripts);
+
+          for (const page of this.pages()) await (page.delegate as CRPage).removeInitScripts();
+        
   }
 
   async doUpdateRequestInterception(): Promise<void> {
@@ -595,4 +596,16 @@
     const rootSession = await this._browser._clientRootSession();
     return rootSession.attachToTarget(targetId);
   }
+
+  async doExposeBinding(binding: PageBinding) {
+
+          for (const page of this.pages()) await (page.delegate as CRPage).exposeBinding(binding);
+        
+  }
+
+  async doRemoveExposedBindings() {
+
+          for (const page of this.pages()) await (page.delegate as CRPage).removeExposedBindings();
+        
+  }
 }
diff -ruN playwright/packages/playwright-core/src/server/chromium/crDevTools.ts patchright/packages/playwright-core/src/server/chromium/crDevTools.ts
---
+++
@@ -67,7 +67,6 @@
       }).catch(e => null);
     });
     Promise.all([
-      session.send('Runtime.enable'),
       session.send('Runtime.addBinding', { name: kBindingName }),
       session.send('Page.enable'),
       session.send('Page.addScriptToEvaluateOnNewDocument', { source: `
diff -ruN playwright/packages/playwright-core/src/server/chromium/crNetworkManager.ts patchright/packages/playwright-core/src/server/chromium/crNetworkManager.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -156,7 +158,7 @@
     const enabled = this._protocolRequestInterceptionEnabled;
     if (initial && !enabled)
       return;
-    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: enabled });
+    const cachePromise = info.session.send('Network.setCacheDisabled', { cacheDisabled: false });
     let fetchPromise = Promise.resolve<any>(undefined);
     if (!info.workerFrame) {
       if (enabled)
@@ -238,6 +240,7 @@
   }
 
   _onRequestPaused(sessionInfo: SessionInfo, event: Protocol.Fetch.requestPausedPayload) {
+    if (this._alreadyTrackedNetworkIds.has(event.networkId)) return;
     if (!event.networkId) {
       // Fetch without networkId means that request was not recognized by inspector, and
       // it will never receive Network.requestWillBeSent. Continue the request to not affect it.
@@ -276,6 +279,7 @@
   }
 
   _onRequest(requestWillBeSentSessionInfo: SessionInfo, requestWillBeSentEvent: Protocol.Network.requestWillBeSentPayload, requestPausedSessionInfo: SessionInfo | undefined, requestPausedEvent: Protocol.Fetch.requestPausedPayload | undefined) {
+    if (this._alreadyTrackedNetworkIds.has(requestWillBeSentEvent.initiator.requestId)) return;
     if (requestWillBeSentEvent.request.url.startsWith('data:'))
       return;
     let redirectedFrom: InterceptableRequest | null = null;
@@ -342,7 +346,7 @@
         headersOverride = redirectedFrom?._originalRequestRoute?._alreadyContinuedParams?.headers;
         requestPausedSessionInfo!.session._sendMayFail('Fetch.continueRequest', { requestId: requestPausedEvent.requestId, headers: headersOverride });
       } else {
-        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId);
+        route = new RouteImpl(requestPausedSessionInfo!.session, requestPausedEvent.requestId, this._page, requestPausedEvent.networkId, this);
       }
     }
     const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === 'Document';
@@ -553,6 +557,8 @@
     if (request.session !== sessionInfo.session && !sessionInfo.isMain && (request._documentId === request._requestId || sessionInfo.workerFrame))
       request.session = sessionInfo.session;
   }
+
+  _alreadyTrackedNetworkIds: Set<string> = new Set();
 }
 
 class InterceptableRequest {
@@ -612,38 +618,189 @@
   _alreadyContinuedParams: Protocol.Fetch.continueRequestParameters | undefined;
   _fulfilled: boolean = false;
 
-  constructor(session: CRSession, interceptionId: string) {
+  constructor(session: CRSession, interceptionId: string, page, networkId, sessionManager) {
+    this._sessionManager = void 0;
+    this._networkId = void 0;
+    this._page = void 0;
     this._session = session;
     this._interceptionId = interceptionId;
+    this._page = page;
+    this._networkId = networkId;
+    this._sessionManager = sessionManager;
+    eventsHelper.addEventListener(this._session, 'Fetch.requestPaused', async e => await this._networkRequestIntercepted(e));
   }
 
   async continue(overrides: types.NormalizedContinueOverrides): Promise<void> {
-    this._alreadyContinuedParams = {
-      requestId: this._interceptionId!,
-      url: overrides.url,
-      headers: overrides.headers,
-      method: overrides.method,
-      postData: overrides.postData ? overrides.postData.toString('base64') : undefined
-    };
-    await catchDisallowedErrors(async () => {
-      await this._session.send('Fetch.continueRequest', this._alreadyContinuedParams);
-    });
+
+          this._alreadyContinuedParams = {
+            requestId: this._interceptionId,
+            url: overrides.url,
+            headers: overrides.headers,
+            method: overrides.method,
+            postData: overrides.postData ? overrides.postData.toString('base64') : undefined,
+          };
+          if (overrides.url && (overrides.url === 'http://patchright-init-script-inject.internal/' || overrides.url === 'https://patchright-init-script-inject.internal/')) {
+            await catchDisallowedErrors(async () => {
+              this._sessionManager._alreadyTrackedNetworkIds.add(this._networkId);
+              this._session._sendMayFail('Fetch.continueRequest', { requestId: this._interceptionId, interceptResponse: true });
+            });
+          } else {
+            await catchDisallowedErrors(async () => {
+              await this._session._sendMayFail('Fetch.continueRequest', this._alreadyContinuedParams);
+            });
+          }
+        
   }
 
   async fulfill(response: types.NormalizedFulfillResponse) {
-    this._fulfilled = true;
-    const body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');
 
-    const responseHeaders = splitSetCookieHeader(response.headers);
-    await catchDisallowedErrors(async () => {
-      await this._session.send('Fetch.fulfillRequest', {
-        requestId: this._interceptionId!,
-        responseCode: response.status,
-        responsePhrase: network.statusText(response.status),
-        responseHeaders,
-        body,
-      });
-    });
+          const isTextHtml = response.headers.some((header) => header.name.toLowerCase() === "content-type" && header.value.includes("text/html"));
+          var allInjections = [...this._page.delegate._mainFrameSession._evaluateOnNewDocumentScripts];
+          for (const binding of this._page.delegate._browserContext._pageBindings.values()) {
+            if (!allInjections.includes(binding)) allInjections.push(binding);
+          }
+          if (isTextHtml && allInjections.length) {
+            let useNonce = false;
+            let scriptNonce = null;
+            // Decode body if needed
+            if (response.isBase64) {
+              response.isBase64 = false;
+              response.body = Buffer.from(response.body, "base64").toString("utf-8");
+            }
+            // === CSP Detection and Fixing ===
+            const cspHeaderNames = ["content-security-policy", "content-security-policy-report-only"];
+            // Fix CSP in headers
+            for (let i = 0; i < response.headers.length; i++) {
+              const headerName = response.headers[i].name.toLowerCase();
+              if (cspHeaderNames.includes(headerName)) {
+                const originalCsp = response.headers[i].value || "";
+                // Extract nonce if present
+                if (!useNonce) {
+                  const nonceMatch = originalCsp.match(/script-src[^;]*'nonce-([^'"\s;]+)'/i);
+                  if (nonceMatch && nonceMatch[1]) {
+                    scriptNonce = nonceMatch[1];
+                    useNonce = true;
+                  }
+                }
+                
+                const fixedCsp = this._fixCSP(originalCsp, scriptNonce);
+                response.headers[i].value = fixedCsp;
+              }
+            }
+            
+            // Fix CSP in meta tags
+            if (typeof response.body === "string" && response.body.length) {
+              response.body = response.body.replace(
+                /<meta[^>]*http-equiv=(?:"|')?Content-Security-Policy(?:"|')?[^>]*>/gi,
+                (match) => {
+                  const contentMatch = match.match(/content=(?:"|')([^"']*)(?:"|')/i);
+                  if (contentMatch && contentMatch[1]) {
+                    let originalCsp = contentMatch[1];
+                    
+                    // Decode HTML entities
+                    originalCsp = originalCsp.replace(/&amp;/g, '&')  // Must be first!
+                        .replace(/&lt;/g, '<')
+                        .replace(/&gt;/g, '>')
+                        .replace(/&quot;/g, '"')
+                        .replace(/&#x27;/g, "'")
+                        .replace(/&#x22;/g, '"')
+                        .replace(/&nbsp;/g, ' ')
+                        .replace(/&#(d+);/g, (match, dec) => String.fromCharCode(dec))
+                        .replace(/&#x([0-9a-fA-F]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)));
+                    
+                    // Extract nonce if not already found
+                    if (!useNonce) {
+                      const nonceMatch = originalCsp.match(/script-src[^;]*'nonce-([^'"\s;]+)'/i);
+                      if (nonceMatch && nonceMatch[1]) {
+                        scriptNonce = nonceMatch[1];
+                        useNonce = true;
+                      }
+                    }
+                    
+                    const fixedCsp = this._fixCSP(originalCsp, scriptNonce);
+                    // Re-encode for HTML
+                    const encodedCsp = fixedCsp.replace(/'/g, '&#x27;').replace(/"/g, '&#x22;');
+                    return match.replace(contentMatch[1], encodedCsp);
+                  }
+                  return match;
+                }
+              );
+            }
+            
+            // Build injection HTML - only use nonce if one was found in existing CSP
+            let injectionHTML = "";
+            allInjections.forEach((script) => {
+              let scriptId = crypto.randomBytes(22).toString("hex");
+              let scriptSource = script.source || script;
+              const nonceAttr = useNonce ? `nonce="${scriptNonce}"` : '';
+              injectionHTML += `<script class="${this._page.delegate.initScriptTag}" ${nonceAttr} id="${scriptId}" type="text/javascript">document.getElementById("${scriptId}")?.remove();${scriptSource}</script>`;
+            });
+
+            // Inject at END of <head>
+            const lower = response.body.toLowerCase();
+            const headStartIndex = lower.indexOf("<head");
+            if (headStartIndex !== -1) {
+              const headEndTagIndex = lower.indexOf("</head>", headStartIndex);
+              if (headEndTagIndex !== -1) {
+                // Find the head opening tag end
+                const headOpenEnd = response.body.indexOf(">", headStartIndex) + 1;
+                const headContent = response.body.slice(headOpenEnd, headEndTagIndex);
+                const headContentLower = headContent.toLowerCase();
+                
+                // Look for the first <script> tag in the head content
+                const firstScriptIndex = headContentLower.indexOf("<script");
+                
+                if (firstScriptIndex !== -1) {
+                  // Inject before the first script tag
+                  const insertPosition = headOpenEnd + firstScriptIndex;
+                  response.body =
+                    response.body.slice(0, insertPosition) +
+                    injectionHTML +
+                    response.body.slice(insertPosition);
+                } else {
+                  // No script tags found, inject at the end of head content (before </head>)
+                  response.body =
+                    response.body.slice(0, headEndTagIndex) +
+                    injectionHTML +
+                    response.body.slice(headEndTagIndex);
+                }
+              } else {
+                const headStartTagEnd = response.body.indexOf(">", headStartIndex) + 1;
+                response.body =
+                  response.body.slice(0, headStartTagEnd) +
+                  injectionHTML +
+                  response.body.slice(headStartTagEnd);
+              }
+            } else {
+              const doctypeIndex = lower.indexOf("<!doctype");
+              if (doctypeIndex === 0) {
+                const doctypeEnd = response.body.indexOf(">", doctypeIndex) + 1;
+                response.body = response.body.slice(0, doctypeEnd) + injectionHTML + response.body.slice(doctypeEnd);
+              } else {
+                const htmlIndex = lower.indexOf("<html");
+                if (htmlIndex !== -1) {
+                  const htmlTagEnd = response.body.indexOf(">", htmlIndex) + 1;
+                  response.body =
+                    response.body.slice(0, htmlTagEnd) + `<head>${injectionHTML}</head>` + response.body.slice(htmlTagEnd);
+                } else {
+                  response.body = injectionHTML + response.body;
+                }
+              }
+            }
+          }
+          this._fulfilled = true;
+          const body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
+          const responseHeaders = splitSetCookieHeader(response.headers);
+          await catchDisallowedErrors(async () => {
+            await this._session.send("Fetch.fulfillRequest", {
+              requestId: response.interceptionId ? response.interceptionId : this._interceptionId,
+              responseCode: response.status,
+              responsePhrase: network.statusText(response.status),
+              responseHeaders,
+              body
+            });
+          });
+        
   }
 
   async abort(errorCode: string = 'failed') {
@@ -656,6 +813,155 @@
       });
     });
   }
+
+  _fixCSP(csp, scriptNonce) {
+
+          if (!csp || typeof csp !== 'string') return csp;
+
+          // Split by semicolons and clean up
+          const directives = csp.split(';')
+            .map(d => d.trim())
+            .filter(d => d && d.length > 0);
+
+          const fixedDirectives = [];
+          let hasScriptSrc = false;
+
+          for (let directive of directives) {
+            // Skip empty directives
+            if (!directive.trim()) continue;
+
+            // Improved directive parsing to handle more edge cases
+            const directiveMatch = directive.match(/^([a-zA-Z-]+)\s+(.*)$/);
+            if (!directiveMatch) {
+              fixedDirectives.push(directive);
+              continue;
+            }
+
+            const directiveName = directiveMatch[1].toLowerCase();
+            const directiveValues = directiveMatch[2].split(/\s+/).filter(v => v.length > 0);
+
+            switch (directiveName) {
+              case 'script-src':
+                hasScriptSrc = true;
+                let values = [...directiveValues];
+
+                // Add nonce if we have one and it's not already present
+                if (scriptNonce && !values.some(v => v.includes(`nonce-${scriptNonce}`))) {
+                  values.push(`'nonce-${scriptNonce}'`);
+                }
+
+                // Add 'unsafe-eval' if not present
+                if (!values.includes("'unsafe-eval'")) {
+                  values.push("'unsafe-eval'");
+                }
+
+                // Add unsafe-inline if not present and no nonce is being used
+                if (!values.includes("'unsafe-inline'") && !scriptNonce) {
+                  values.push("'unsafe-inline'");
+                }
+
+                // Add wildcard for external scripts if not already present
+                if (!values.includes("*") && !values.includes("'self'") && !values.some(v => v.includes("https:"))) {
+                  values.push("*");
+                }
+
+                fixedDirectives.push(`script-src ${values.join(' ')}`);
+                break;
+
+              case 'style-src':
+                let styleValues = [...directiveValues];
+                // Add 'unsafe-inline' for styles if not present
+                if (!styleValues.includes("'unsafe-inline'")) {
+                  styleValues.push("'unsafe-inline'");
+                }
+                fixedDirectives.push(`style-src ${styleValues.join(' ')}`);
+                break;
+
+              case 'img-src':
+                let imgValues = [...directiveValues];
+                // Allow data: URLs for images if not already allowed
+                if (!imgValues.includes("data:") && !imgValues.includes("*")) {
+                  imgValues.push("data:");
+                }
+                fixedDirectives.push(`img-src ${imgValues.join(' ')}`);
+                break;
+
+              case 'font-src':
+                let fontValues = [...directiveValues];
+                // Allow data: URLs for fonts if not already allowed
+                if (!fontValues.includes("data:") && !fontValues.includes("*")) {
+                  fontValues.push("data:");
+                }
+                fixedDirectives.push(`font-src ${fontValues.join(' ')}`);
+                break;
+
+              case 'connect-src':
+                let connectValues = [...directiveValues];
+                // Allow WebSocket connections if not already allowed
+                const hasWs = connectValues.some(v => v.includes("ws:") || v.includes("wss:") || v === "*");
+                if (!hasWs) {
+                  connectValues.push("ws:", "wss:");
+                }
+                fixedDirectives.push(`connect-src ${connectValues.join(' ')}`);
+                break;
+
+              case 'frame-ancestors':
+                let frameAncestorValues = [...directiveValues];
+                // If completely blocked with 'none', allow 'self' at least
+                if (frameAncestorValues.includes("'none'")) {
+                  frameAncestorValues = ["'self'"];
+                }
+                fixedDirectives.push(`frame-ancestors ${frameAncestorValues.join(' ')}`);
+                break;
+
+              default:
+                // Keep other directives as-is
+                fixedDirectives.push(directive);
+                break;
+            }
+          }
+
+          // Add script-src if it doesn't exist (for our injected scripts)
+          if (!hasScriptSrc) {
+            if (scriptNonce) {
+              fixedDirectives.push(`script-src 'self' 'unsafe-eval' 'nonce-${scriptNonce}' *`);
+            } else {
+              fixedDirectives.push(`script-src 'self' 'unsafe-eval' 'unsafe-inline' *`);
+            }
+          }
+
+          return fixedDirectives.join('; ');
+        
+  }
+
+  async _networkRequestIntercepted(event) {
+
+          if (event.resourceType !== 'Document') {
+            /*await catchDisallowedErrors(async () => {
+              await this._session.send('Fetch.continueRequest', { requestId: event.requestId });
+            });*/
+            return;
+          }
+          if (this._networkId != event.networkId || !this._sessionManager._alreadyTrackedNetworkIds.has(event.networkId)) return;
+          try {
+            if (event.responseStatusCode >= 301 && event.responseStatusCode <= 308  || (event.redirectedRequestId && !event.responseStatusCode)) {
+              await this._session.send('Fetch.continueRequest', { requestId: event.requestId, interceptResponse: true });
+            } else {
+              const responseBody = await this._session.send('Fetch.getResponseBody', { requestId: event.requestId });
+              await this.fulfill({
+                headers: event.responseHeaders,
+                isBase64: true,
+                body: responseBody.body,
+                status: event.responseStatusCode,
+                interceptionId: event.requestId,
+                resourceType: event.resourceType,
+              })
+            }
+          } catch (error) {
+            await this._session._sendMayFail('Fetch.continueRequest', { requestId: event.requestId });
+          }
+        
+  }
 }
 
 // In certain cases, protocol will return error if the request was already canceled
diff -ruN playwright/packages/playwright-core/src/server/chromium/crPage.ts patchright/packages/playwright-core/src/server/chromium/crPage.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -99,7 +101,8 @@
     this.updateOffline();
     this.updateExtraHTTPHeaders();
     this.updateHttpCredentials();
-    this.updateRequestInterception();
+    this._networkManager.setRequestInterception(true);
+        this.initScriptTag = crypto.randomBytes(20).toString('hex');
     this._mainFrameSession = new FrameSession(this, client, targetId, null);
     this._sessions.set(targetId, this._mainFrameSession);
     if (opener && !browserContext._options.noDefaultViewport) {
@@ -228,6 +231,7 @@
   }
 
   async addInitScript(initScript: InitScript, world: types.World = 'main'): Promise<void> {
+    this._page.initScripts.push(initScript);
     await this._forAllFrameSessions(frame => frame._evaluateOnNewDocument(initScript, world));
   }
 
@@ -361,6 +365,19 @@
   shouldToggleStyleSheetToSyncAnimations(): boolean {
     return false;
   }
+
+  async exposeBinding(binding) {
+
+          await this._forAllFrameSessions(frame => frame._initBinding(binding));
+          await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(binding.source).catch(e => {})));
+        
+  }
+
+  async removeExposedBindings() {
+
+          await this._forAllFrameSessions(frame => frame._removeExposedBindings());
+        
+  }
 }
 
 class FrameSession {
@@ -488,17 +505,6 @@
         this._bufferedAttachedToTargetEvents = undefined;
         for (const event of attachedToTargetEvents)
           this._onAttachedToTarget(event);
-
-        const localFrames = this._isMainFrame() ? this._page.frames() : [this._page.frameManager.frame(this._targetId)!];
-        for (const frame of localFrames) {
-          // Note: frames might be removed before we send these.
-          this._client._sendMayFail('Page.createIsolatedWorld', {
-            frameId: frame._id,
-            grantUniveralAccess: true,
-            worldName: this._crPage.utilityWorldName,
-          });
-        }
-
         const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ':';
         if (isInitialEmptyPage) {
           // Ignore lifecycle events, worlds and bindings for the initial empty page. It is never the final page
@@ -508,13 +514,22 @@
             this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
           });
         } else {
+
+                  const localFrames = this._isMainFrame() ? this._page.frames() : [this._page.frameManager.frame(this._targetId)!];
+                    for (const frame of localFrames) {
+                      this._page.frameManager.frame(frame._id)._context("utility");
+                      for (const binding of this._crPage._browserContext._pageBindings.values())
+                        frame.evaluateExpression(binding.source).catch(e => {});
+                      for (const source of this._crPage._browserContext.initScripts)
+                        frame.evaluateExpression(source).catch(e => {});
+                    }
+                  
           this._firstNonInitialNavigationCommittedFulfill();
           this._eventListeners.push(eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
         }
       }),
       this._client.send('Log.enable', {}),
       lifecycleEventsEnabled = this._client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
-      this._client.send('Runtime.enable', {}),
       this._client.send('Page.addScriptToEvaluateOnNewDocument', {
         source: '',
         worldName: this._crPage.utilityWorldName,
@@ -525,8 +540,10 @@
     if (!this._page.isStorageStatePage) {
       if (this._crPage._browserContext.needsPlaywrightBinding())
         promises.push(this.exposePlaywrightBinding());
-      if (this._isMainFrame())
-        promises.push(this._client.send('Emulation.setFocusEmulationEnabled', { enabled: true }));
+      
+              if (this._isMainFrame() && this._crPage._browserContext._options.focusControl)
+                  promises.push(this._client.send("Emulation.setFocusEmulationEnabled", { enabled: true }));
+              
       const options = this._crPage._browserContext._options;
       if (options.bypassCSP)
         promises.push(this._client.send('Page.setBypassCSP', { enabled: true }));
@@ -549,14 +566,24 @@
       promises.push(this._updateGeolocation(true));
       promises.push(this._updateEmulateMedia());
       promises.push(this._updateFileChooserInterception(true));
-      for (const initScript of this._crPage._page.allInitScripts())
-        promises.push(this._evaluateOnNewDocument(initScript, 'main', true /* runImmediately */));
+      
+                    for (const binding of this._crPage._page.allBindings()) promises.push(this._initBinding(binding));
+                    for (const initScript of this._crPage._browserContext.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+                    for (const initScript of this._crPage._page.initScripts) promises.push(this._evaluateOnNewDocument(initScript, 'main'));
+                  
       if (screencastOptions)
         promises.push(this._startVideoRecording(screencastOptions));
     }
-    promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
+    
+            if (!(this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size))
+              promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
+          
     promises.push(this._firstNonInitialNavigationCommittedPromise);
     await Promise.all(promises);
+
+            if (this._crPage._page._pageBindings.size || this._crPage._browserContext._pageBindings.size)
+              await this._client.send('Runtime.runIfWaitingForDebugger');
+          
   }
 
   dispose() {
@@ -580,13 +607,25 @@
     return { newDocumentId: response.loaderId };
   }
 
-  _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
+  async _onLifecycleEvent(event: Protocol.Page.lifecycleEventPayload) {
     if (this._eventBelongsToStaleFrame(event.frameId))
       return;
     if (event.name === 'load')
       this._page.frameManager.frameLifecycleEvent(event.frameId, 'load');
     else if (event.name === 'DOMContentLoaded')
       this._page.frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded');
+    await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          var document = await this._client._sendMayFail("DOM.getDocument");
+          if (!document) return
+          var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+            nodeId: document.root.nodeId,
+            selector: "[class=" + this._crPage.initScriptTag + "]"
+          });
+          if (!query) return
+          for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+          await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          // ensuring execution context
+          try { await this._page.frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _handleFrameTree(frameTree: Protocol.Page.FrameTree) {
@@ -633,12 +672,24 @@
     this._page.frameManager.frameAttached(frameId, parentFrameId);
   }
 
-  _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
+  async _onFrameNavigated(framePayload: Protocol.Page.Frame, initial: boolean) {
     if (this._eventBelongsToStaleFrame(framePayload.id))
       return;
     this._page.frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ''), framePayload.name || '', framePayload.loaderId, initial);
     if (!initial)
       this._firstNonInitialNavigationCommittedFulfill();
+    await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          var document = await this._client._sendMayFail("DOM.getDocument");
+          if (!document) return
+          var query = await this._client._sendMayFail("DOM.querySelectorAll", {
+            nodeId: document.root.nodeId,
+            selector: "[class=" + this._crPage.initScriptTag + "]"
+          });
+          if (!query) return
+          for (const nodeId of query.nodeIds) await this._client._sendMayFail("DOM.removeNode", { nodeId: nodeId });
+          await this._client._sendMayFail('Runtime.runIfWaitingForDebugger');
+          // ensuring execution context
+          try { await this._page.frameManager.frame(this._targetId)._context("utility") } catch { };
   }
 
   _onFrameRequestedNavigation(payload: Protocol.Page.frameRequestedNavigationPayload) {
@@ -675,19 +726,31 @@
   }
 
   _onExecutionContextCreated(contextPayload: Protocol.Runtime.ExecutionContextDescription) {
+
+          for (const name of this._exposedBindingNames)
+            this._client._sendMayFail('Runtime.addBinding', { name: name, executionContextId: contextPayload.id });
+        
     const frame = contextPayload.auxData ? this._page.frameManager.frame(contextPayload.auxData.frameId) : null;
+
+          if (contextPayload.auxData.type == "worker") throw new Error("ExecutionContext is worker");
+        
     if (!frame || this._eventBelongsToStaleFrame(frame._id))
       return;
     const delegate = new CRExecutionContext(this._client, contextPayload);
-    let worldName: types.World|null = null;
-    if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
-      worldName = 'main';
-    else if (contextPayload.name === this._crPage.utilityWorldName)
-      worldName = 'utility';
+    let worldName = contextPayload.name;
     const context = new dom.FrameExecutionContext(delegate, frame, worldName);
     if (worldName)
       frame._contextCreated(worldName, context);
     this._contextIdToContext.set(contextPayload.id, context);
+
+          for (const source of this._exposedBindingScripts) {
+            this._client._sendMayFail("Runtime.evaluate", {
+              expression: source,
+              contextId: contextPayload.id,
+              awaitPromise: true,
+            })
+          }
+        
   }
 
   _onExecutionContextDestroyed(executionContextId: number) {
@@ -703,7 +766,7 @@
       this._onExecutionContextDestroyed(contextId);
   }
 
-  _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
+  async _onAttachedToTarget(event: Protocol.Target.attachedToTargetPayload) {
     if (this._bufferedAttachedToTargetEvents) {
       this._bufferedAttachedToTargetEvents.push(event);
       return;
@@ -745,12 +808,22 @@
     session.once('Runtime.executionContextCreated', async event => {
       worker.createExecutionContext(new CRExecutionContext(session, event.context));
     });
+
+          var globalThis = await session._sendMayFail('Runtime.evaluate', {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          });
+          if (globalThis && globalThis.result) {
+            var globalThisObjId = globalThis.result.objectId;
+            var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+            worker.createExecutionContext(new CRExecutionContext(session, { id: executionContextId }));
+          }
+        
     if (this._crPage._browserContext._browser.majorVersion() >= 143)
       session.on('Inspector.workerScriptLoaded', () => worker.workerScriptLoaded());
     else
       worker.workerScriptLoaded();
     // This might fail if the target is closed before we initialize.
-    session._sendMayFail('Runtime.enable');
     // TODO: attribute workers to the right frame.
     this._crPage._networkManager.addSession(session, this._page.frameManager.frame(this._targetId) ?? undefined).catch(() => {});
     session._sendMayFail('Runtime.runIfWaitingForDebugger');
@@ -1076,20 +1149,11 @@
   }
 
   async _evaluateOnNewDocument(initScript: InitScript, world: types.World, runImmediately?: boolean): Promise<void> {
-    const worldName = world === 'utility' ? this._crPage.utilityWorldName : undefined;
-    const { identifier } = await this._client.send('Page.addScriptToEvaluateOnNewDocument', { source: initScript.source, worldName, runImmediately });
-    this._initScriptIds.set(initScript, identifier);
+    this._evaluateOnNewDocumentScripts.push(initScript)
   }
 
   async _removeEvaluatesOnNewDocument(initScripts: InitScript[]): Promise<void> {
-    const ids: string[] = [];
-    for (const script of initScripts) {
-      const id = this._initScriptIds.get(script);
-      if (id)
-        ids.push(id);
-      this._initScriptIds.delete(script);
-    }
-    await Promise.all(ids.map(identifier => this._client.send('Page.removeScriptToEvaluateOnNewDocument', { identifier }).catch(() => {}))); // target can be closed
+    this._evaluateOnNewDocumentScripts = [];
   }
 
   async exposePlaywrightBinding() {
@@ -1200,6 +1264,49 @@
       throw new Error(dom.kUnableToAdoptErrorMessage);
     return createHandle(to, result.object).asElement()!;
   }
+
+  _exposedBindingNames: string[] = [];
+  _evaluateOnNewDocumentScripts: string[] = [];
+  _parsedExecutionContextIds: number[] = [];
+  _exposedBindingScripts: string[] = [];
+
+  async _initBinding(binding = PageBinding) {
+
+          var result = await this._client._sendMayFail('Page.createIsolatedWorld', {
+            frameId: this._targetId, grantUniveralAccess: true, worldName: "utility"
+          });
+          if (!result) return
+          var isolatedContextId = result.executionContextId
+
+          var globalThis = await this._client._sendMayFail('Runtime.evaluate', {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          });
+          if (!globalThis) return
+          var globalThisObjId = globalThis["result"]['objectId']
+          var mainContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+          await Promise.all([
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name }),
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: mainContextId }),
+            this._client._sendMayFail('Runtime.addBinding', { name: binding.name, executionContextId: isolatedContextId }),
+            // this._client._sendMayFail("Runtime.evaluate", { expression: binding.source, contextId: mainContextId, awaitPromise: true })
+          ]);
+          this._exposedBindingNames.push(binding.name);
+          this._exposedBindingScripts.push(binding.source);
+          await this._crPage.addInitScript(binding.source);
+          //this._client._sendMayFail('Runtime.runIfWaitingForDebugger')
+  }
+
+  async _removeExposedBindings() {
+    const toRetain: string[] = [];
+          const toRemove: string[] = [];
+          for (const name of this._exposedBindingNames)
+            (name.startsWith('__pw_') ? toRetain : toRemove).push(name);
+          this._exposedBindingNames = toRetain;
+          await Promise.all(toRemove.map(name => this._client.send('Runtime.removeBinding', { name })));
+        
+  }
 }
 
 async function emulateLocale(session: CRSession, locale: string) {
diff -ruN playwright/packages/playwright-core/src/server/chromium/crServiceWorker.ts patchright/packages/playwright-core/src/server/chromium/crServiceWorker.ts
---
+++
@@ -58,13 +58,23 @@
       const message = new ConsoleMessage(null, this, event.type, undefined, args, toConsoleMessageLocation(event.stackTrace));
       this.browserContext.emit(BrowserContext.Events.Console, message);
     });
-
-    session.send('Runtime.enable', {}).catch(e => { });
     session.send('Runtime.runIfWaitingForDebugger').catch(e => { });
     session.on('Inspector.targetReloadedAfterCrash', () => {
       // Resume service worker after restart.
       session._sendMayFail('Runtime.runIfWaitingForDebugger', {});
     });
+
+          session._sendMayFail("Runtime.evaluate", {
+            expression: "globalThis",
+            serializationOptions: { serialization: "idOnly" }
+          }).then(globalThis => {
+            if (globalThis && globalThis.result) {
+              var globalThisObjId = globalThis.result.objectId;
+              var executionContextId = parseInt(globalThisObjId.split(".")[1], 10);
+              this.createExecutionContext(new CRExecutionContext(session, { id: executionContextId }));
+            }
+          });
+        
   }
 
   override didClose() {
diff -ruN playwright/packages/playwright-core/src/server/clock.ts patchright/packages/playwright-core/src/server/clock.ts
---
+++
@@ -106,6 +106,16 @@
   }
 
   private async _evaluateInFrames(script: string) {
+
+          // Dont ask me why this works
+          await Promise.all(this._browserContext.pages().map(async page => {
+            await Promise.all(page.frames().map(async frame => {
+              try {
+                await frame.evaluateExpression("");
+              } catch (e) {}
+            }));
+          }));
+        
     await this._browserContext.safeNonStallingEvaluateInAllFrames(script, 'main', { throwOnJSErrors: true });
   }
 }
diff -ruN playwright/packages/playwright-core/src/server/dispatchers/frameDispatcher.ts patchright/packages/playwright-core/src/server/dispatchers/frameDispatcher.ts
---
+++
@@ -84,11 +84,15 @@
   }
 
   async evaluateExpression(params: channels.FrameEvaluateExpressionParams, progress: Progress): Promise<channels.FrameEvaluateExpressionResult> {
-    return { value: serializeResult(await progress.race(this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)))) };
+
+          return { value: serializeResult(await progress.race(this._frame.evaluateExpression(params.expression, { isFunction: params.isFunction, world: params.isolatedContext ? 'utility': 'main' }, parseArgument(params.arg)))) };
+        
   }
 
   async evaluateExpressionHandle(params: channels.FrameEvaluateExpressionHandleParams, progress: Progress): Promise<channels.FrameEvaluateExpressionHandleResult> {
-    return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this, await progress.race(this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction }, parseArgument(params.arg)))) };
+
+          return { handle: ElementHandleDispatcher.fromJSOrElementHandle(this, await progress.race(this._frame.evaluateExpressionHandle(params.expression, { isFunction: params.isFunction, world: params.isolatedContext ? 'utility': 'main' }, parseArgument(params.arg)))) };
+        
   }
 
   async waitForSelector(params: channels.FrameWaitForSelectorParams, progress: Progress): Promise<channels.FrameWaitForSelectorResult> {
@@ -104,7 +108,9 @@
   }
 
   async evalOnSelectorAll(params: channels.FrameEvalOnSelectorAllParams, progress: Progress): Promise<channels.FrameEvalOnSelectorAllResult> {
-    return { value: serializeResult(await progress.race(this._frame.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg)))) };
+
+          return { value: serializeResult(await this._frame.evalOnSelectorAll(params.selector, params.expression, params.isFunction, parseArgument(params.arg), null, params.isolatedContext)) };
+        
   }
 
   async querySelector(params: channels.FrameQuerySelectorParams, progress: Progress): Promise<channels.FrameQuerySelectorResult> {
diff -ruN playwright/packages/playwright-core/src/server/frameSelectors.ts patchright/packages/playwright-core/src/server/frameSelectors.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import { ElementHandle } from './dom';
 /**
  * Copyright (c) Microsoft Corporation.
  *
@@ -65,8 +67,8 @@
     return adoptIfNeeded(elementHandle, await resolved.frame._mainContext());
   }
 
-  async queryArrayInMainWorld(selector: string, scope?: ElementHandle): Promise<JSHandle<Element[]>> {
-    const resolved = await this.resolveInjectedForSelector(selector, { mainWorld: true }, scope);
+  async queryArrayInMainWorld(selector: string, scope?: ElementHandle, isolatedContext?: boolean): Promise<JSHandle<Element[]>> {
+    const resolved = await this.resolveInjectedForSelector(selector, { mainWorld: !isolatedContext }, scope);
     // Be careful, |this.frame| can be different from |resolved.frame|.
     if (!resolved)
       throw new Error(`Failed to find frame for selector "${selector}"`);
@@ -150,9 +152,31 @@
           throw injected.createStacklessError(`Selector "${selectorString}" resolved to ${injected.previewNode(element)}, <iframe> was expected`);
         return element;
       }, { info, scope: i === 0 ? scope : undefined, selectorString: stringifySelector(info.parsed) });
-      const element = handle.asElement() as ElementHandle<Element> | null;
-      if (!element)
-        return null;
+      let element = handle.asElement() as ElementHandle<Element> | null;
+      
+            if (!element) {
+              try {
+                var client = frame._page.delegate._sessionForFrame(frame)._client;
+              } catch (e) {
+                var client = frame._page.delegate._mainFrameSession._client;
+              }
+              var mainContext = await frame._context("main");
+              const documentNode = await client.send("Runtime.evaluate", {
+                expression: "document",
+                serializationOptions: {
+                  serialization: "idOnly"
+                },
+                contextId: mainContext.delegate._contextId
+              });
+              const documentScope = new ElementHandle(mainContext, documentNode.result.objectId);
+              var check = await this._customFindFramesByParsed(injectedScript, client, mainContext, documentScope, info.parsed);
+              if (check.length > 0) {
+                element = check[0];
+              } else {
+                return null;
+              }
+            }
+          
       const maybeFrame = await frame._page.delegate.getContentFrame(element);
       element.dispose();
       if (!maybeFrame)
@@ -176,6 +200,162 @@
     const injected = await context.injectedScript();
     return { injected, info: resolved.info, frame: resolved.frame, scope: resolved.scope };
   }
+
+  async _customFindFramesByParsed(injected, client, context, documentScope, parsed) {
+
+          var parsedEdits = { ...parsed };
+          var currentScopingElements = [documentScope];
+          while (parsed.parts.length > 0) {
+            var part = parsed.parts.shift();
+            parsedEdits.parts = [part];
+            var elements = [];
+            var elementsIndexes = [];
+            if (part.name == "nth") {
+              const partNth = Number(part.body);
+              if (partNth > currentScopingElements.length || partNth < -currentScopingElements.length) {
+                return continuePolling;
+              } else {
+                currentScopingElements = [currentScopingElements.at(partNth)];
+                continue;
+              }
+            } else if (part.name == "internal:or") {
+              var orredElements = await this._customFindFramesByParsed(injected, client, context, documentScope, part.body.parsed);
+              elements = currentScopingElements.concat(orredElements);
+            } else if (part.name == "internal:and") {
+              var andedElements = await this._customFindFramesByParsed(injected, client, context, documentScope, part.body.parsed);
+              const backendNodeIds = new Set(andedElements.map((item) => item.backendNodeId));
+              elements = currentScopingElements.filter((item) => backendNodeIds.has(item.backendNodeId));
+            } else {
+              for (const scope of currentScopingElements) {
+                const describedScope = await client.send("DOM.describeNode", {
+                  objectId: scope._objectId,
+                  depth: -1,
+                  pierce: true
+                });
+                var queryingElements = [];
+                let findClosedShadowRoots2 = function(node, results = []) {
+                  if (!node || typeof node !== "object") return results;
+                  if (node.shadowRoots && Array.isArray(node.shadowRoots)) {
+                    for (const shadowRoot2 of node.shadowRoots) {
+                      if (shadowRoot2.shadowRootType === "closed" && shadowRoot2.backendNodeId) {
+                        results.push(shadowRoot2.backendNodeId);
+                      }
+                      findClosedShadowRoots2(shadowRoot2, results);
+                    }
+                  }
+                  if (node.nodeName !== "IFRAME" && node.children && Array.isArray(node.children)) {
+                    for (const child of node.children) {
+                      findClosedShadowRoots2(child, results);
+                    }
+                  }
+                  return results;
+                };
+                var findClosedShadowRoots = findClosedShadowRoots2;
+                var shadowRootBackendIds = findClosedShadowRoots2(describedScope.node);
+                var shadowRoots = [];
+                for (var shadowRootBackendId of shadowRootBackendIds) {
+                  var resolvedShadowRoot = await client.send("DOM.resolveNode", {
+                    backendNodeId: shadowRootBackendId,
+                    contextId: context.delegate._contextId
+                  });
+                  shadowRoots.push(new ElementHandle(context, resolvedShadowRoot.object.objectId));
+                }
+                for (var shadowRoot of shadowRoots) {
+                  const shadowElements = await shadowRoot.evaluateHandleInUtility(([injected, node, { parsed: parsed2 }]) => {
+                    const elements2 = injected.querySelectorAll(parsed2, node);
+                    return elements2;
+                  }, {
+                    parsed: parsedEdits,
+                  });
+                  const shadowElementsAmount = await shadowElements.getProperty("length");
+                  queryingElements.push([shadowElements, shadowElementsAmount, shadowRoot]);
+                }
+                const rootElements = await scope.evaluateHandleInUtility(([injected, node, { parsed: parsed2 }]) => {
+                  const elements2 = injected.querySelectorAll(parsed2, node);
+                  return elements2;
+                }, {
+                  parsed: parsedEdits
+                });
+                const rootElementsAmount = await rootElements.getProperty("length");
+                queryingElements.push([rootElements, rootElementsAmount, injected]);
+                for (var queryedElement of queryingElements) {
+                  var elementsToCheck = queryedElement[0];
+                  var elementsAmount = await queryedElement[1].jsonValue();
+                  var parentNode = queryedElement[2];
+                  for (var i = 0; i < elementsAmount; i++) {
+                    if (parentNode.constructor.name == "ElementHandle") {
+                      var elementToCheck = await parentNode.evaluateHandleInUtility(([injected, node, { index, elementsToCheck: elementsToCheck2 }]) => {
+                        return elementsToCheck2[index];
+                      }, { index: i, elementsToCheck });
+                    } else {
+                      var elementToCheck = await parentNode.evaluateHandle((injected, { index, elementsToCheck: elementsToCheck2 }) => {
+                        return elementsToCheck2[index];
+                      }, { index: i, elementsToCheck });
+                    }
+                    elementToCheck.parentNode = parentNode;
+                    var resolvedElement = await client.send("DOM.describeNode", {
+                      objectId: elementToCheck._objectId,
+                      depth: -1
+                    });
+                    elementToCheck.backendNodeId = resolvedElement.node.backendNodeId;
+                    elementToCheck.nodePosition = this._findElementPositionInDomTree(elementToCheck, describedScope.node, context, "");
+                    elements.push(elementToCheck);
+                  }
+                }
+              }
+            }
+            // Sorting elements by their nodePosition, which is a index to the Element in the DOM tree
+            const getParts = (pos) => (pos?.match(/../g) || []).map(Number);
+            elements.sort((a, b) => {
+              const partA = getParts(a.nodePosition);
+              const partB = getParts(b.nodePosition);
+              const maxLength = Math.max(partA.length, partB.length);
+
+              for (let i = 0; i < maxLength; i++) {
+                const aVal = partA[i] ?? -1;
+                const bVal = partB[i] ?? -1;
+                if (aVal !== bVal) return aVal - bVal;
+              }
+              return 0;
+            });
+
+            // Remove duplicates by nodePosition, keeping the first occurrence
+            currentScopingElements = Array.from(
+              new Map(elements.map(e => [e.nodePosition, e])).values()
+            );
+          }
+          return currentScopingElements;
+        
+  }
+
+  _findElementPositionInDomTree(element, queryingElement, documentScope, currentIndex) {
+
+          // Get Element Position in DOM Tree by Indexing it via their children indexes, like a search tree index
+          // Check if backendNodeId matches, if so, return currentIndex
+          if (element.backendNodeId === queryingElement.backendNodeId) {
+            return currentIndex;
+          }
+          // Iterating through children of queryingElement
+          for (const child of queryingElement.children || []) {
+            // Getting index of child in queryingElement's children
+            const childrenNodeIndex = queryingElement.children.indexOf(child);
+            // Further querying the child recursively and appending the children index to the currentIndex
+            const childIndex = this._findElementPositionInDomTree(element, child, documentScope, currentIndex + childrenNodeIndex.toString());
+            if (childIndex !== null) return childIndex;
+          }
+          if (queryingElement.shadowRoots && Array.isArray(queryingElement.shadowRoots)) {
+            // Basically same for CSRs, but we dont have to append its index because patchright treats CSRs like they dont exist
+            for (const shadowRoot of queryingElement.shadowRoots) {
+              if (shadowRoot.shadowRootType === "closed" && shadowRoot.backendNodeId) {
+                const shadowRootHandle = new ElementHandle(documentScope, shadowRoot.backendNodeId);
+                const childIndex = this._findElementPositionInDomTree(element, shadowRootHandle, documentScope, currentIndex);
+                if (childIndex !== null) return childIndex;
+              }
+            }
+          }
+          return null;
+        
+  }
 }
 
 async function adoptIfNeeded<T extends Node>(handle: ElementHandle<T>, context: FrameExecutionContext): Promise<ElementHandle<T>> {
diff -ruN playwright/packages/playwright-core/src/server/frames.ts patchright/packages/playwright-core/src/server/frames.ts
---
+++
@@ -1,3 +1,7 @@
+// patchright - custom imports
+import { CRExecutionContext } from './chromium/crExecutionContext';
+import { FrameExecutionContext } from './dom';
+import crypto from 'crypto';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -506,6 +510,9 @@
   }
 
   _onClearLifecycle() {
+    this._isolatedWorld = undefined;
+    this._mainWorld = undefined;
+    this._iframeWorld = undefined;
     for (const event of this._firedLifecycleEvents)
       this.emit(Frame.Events.RemoveLifecycle, event);
     this._firedLifecycleEvents.clear();
@@ -714,12 +721,69 @@
     return this._page.delegate.getFrameElement(this);
   }
 
-  _context(world: types.World): Promise<dom.FrameExecutionContext> {
-    return this._contextData.get(world)!.contextPromise.then(contextOrDestroyedReason => {
-      if (contextOrDestroyedReason instanceof js.ExecutionContext)
-        return contextOrDestroyedReason;
-      throw new Error(contextOrDestroyedReason.destroyedReason);
-    });
+  async _context(world: types.World): Promise<dom.FrameExecutionContext> {
+
+          /* await this._page.delegate._mainFrameSession._client._sendMayFail('DOM.enable');
+          var globalDoc = await this._page.delegate._mainFrameSession._client._sendMayFail('DOM.getFrameOwner', { frameId: this._id });
+          if (globalDoc) {
+            await this._page.delegate._mainFrameSession._client._sendMayFail("DOM.resolveNode", { nodeId: globalDoc.nodeId })
+          } */
+
+          if (this.isDetached()) throw new Error('Frame was detached');
+          try {
+            var client = this._page.delegate._sessionForFrame(this)._client
+          } catch (e) { var client = this._page.delegate._mainFrameSession._client }
+          var iframeExecutionContextId = await this._getFrameMainFrameContextId(client)
+
+          if (world == "main") {
+            // Iframe Only
+            if (this != this._page.mainFrame() && iframeExecutionContextId && this._iframeWorld == undefined) {
+              var executionContextId = iframeExecutionContextId
+              var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+              this._iframeWorld = new FrameExecutionContext(crContext, this, world)
+              this._page.delegate._mainFrameSession._onExecutionContextCreated({
+                id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+              })
+            } else if (this._mainWorld == undefined) {
+              var globalThis = await client._sendMayFail('Runtime.evaluate', {
+                expression: "globalThis",
+                serializationOptions: { serialization: "idOnly" }
+              });
+              if (!globalThis) { return }
+              var globalThisObjId = globalThis["result"]['objectId']
+              var executionContextId = parseInt(globalThisObjId.split('.')[1], 10);
+
+              var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+              this._mainWorld = new FrameExecutionContext(crContext, this, world)
+              this._page.delegate._mainFrameSession._onExecutionContextCreated({
+                id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+              })
+            }
+          }
+          if (world != "main" && this._isolatedWorld == undefined) {
+            world = "utility"
+            var result = await client._sendMayFail('Page.createIsolatedWorld', {
+              frameId: this._id, grantUniveralAccess: true, worldName: world
+            });
+            if (!result) {
+              // if (this.isDetached()) throw new Error("Frame was detached");
+              return
+            }
+            var executionContextId = result.executionContextId
+            var crContext = new CRExecutionContext(client, { id: executionContextId }, this._id)
+            this._isolatedWorld = new FrameExecutionContext(crContext, this, world)
+            this._page.delegate._mainFrameSession._onExecutionContextCreated({
+              id: executionContextId, origin: world, name: world, auxData: { isDefault: this === this._page.mainFrame(), type: 'isolated', frameId: this._id }
+            })
+          }
+
+          if (world != "main") {
+            return this._isolatedWorld;
+          } else if (this != this._page.mainFrame() && iframeExecutionContextId) {
+            return this._iframeWorld;
+          } else {
+            return this._mainWorld;
+          }
   }
 
   _mainContext(): Promise<dom.FrameExecutionContext> {
@@ -741,78 +805,73 @@
   }
 
   async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean, world?: types.World } = {}, arg?: any): Promise<js.JSHandle<any>> {
-    const context = await this._context(options.world ?? 'main');
-    const value = await context.evaluateExpressionHandle(expression, options, arg);
-    return value;
+
+          const context = await this._context(options.world ?? "utility");
+          const value = await context.evaluateExpressionHandle(expression, options, arg);
+          return value;
+        
   }
 
   async querySelector(selector: string, options: types.StrictOptions): Promise<dom.ElementHandle<Element> | null> {
-    debugLogger.log('api', `    finding element using the selector "${selector}"`);
-    return this.selectors.query(selector, options);
+
+          return this.querySelectorAll(selector, options).then((handles) => {
+            if (handles.length === 0)
+              return null;
+            if (handles.length > 1 && options?.strict)
+              throw new Error(`Strict mode: expected one element matching selector "${selector}", found ${handles.length}`);
+            return handles[0];
+          });
+        
   }
 
   async waitForSelector(progress: Progress, selector: string, performActionPreChecksAndLog: boolean, options: types.WaitForElementOptions, scope?: dom.ElementHandle): Promise<dom.ElementHandle<Element> | null> {
-    if ((options as any).visibility)
-      throw new Error('options.visibility is not supported, did you mean options.state?');
-    if ((options as any).waitFor && (options as any).waitFor !== 'visible')
-      throw new Error('options.waitFor is not supported, did you mean options.state?');
-    const { state = 'visible' } = options;
-    if (!['attached', 'detached', 'visible', 'hidden'].includes(state))
-      throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
-    if (performActionPreChecksAndLog)
-      progress.log(`waiting for ${this._asLocator(selector)}${state === 'attached' ? '' : ' to be ' + state}`);
-    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecksAndLog)
-        await this._page.performActionPreChecks(progress);
 
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved) {
-        if (state === 'hidden' || state === 'detached')
-          return null;
-        return continuePolling;
-      }
-      const result = await progress.race(resolved.injected.evaluateHandle((injected, { info, root }) => {
-        if (root && !root.isConnected)
-          throw injected.createStacklessError('Element is not attached to the DOM');
-        const elements = injected.querySelectorAll(info.parsed, root || document);
-        const element: Element | undefined  = elements[0];
-        const visible = element ? injected.utils.isElementVisible(element) : false;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
-            throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewNode(element)}`;
-        }
-        return { log, element, visible, attached: !!element };
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined }));
-      const { log, visible, attached } = await progress.race(result.evaluate(r => ({ log: r.log, visible: r.visible, attached: r.attached })));
-      if (log)
-        progress.log(log);
-      const success = { attached, detached: !attached, visible, hidden: !visible }[state];
-      if (!success) {
-        result.dispose();
-        return continuePolling;
-      }
-      if (options.omitReturnValue) {
-        result.dispose();
-        return null;
-      }
-      const element = state === 'attached' || state === 'visible' ? await progress.race(result.evaluateHandle(r => r.element)) : null;
-      result.dispose();
-      if (!element)
-        return null;
-      if ((options as any).__testHookBeforeAdoptNode)
-        await progress.race((options as any).__testHookBeforeAdoptNode());
-      try {
-        const mainContext = await progress.race(resolved.frame._mainContext());
-        return await progress.race(element._adoptTo(mainContext));
-      } catch (e) {
-        return continuePolling;
-      }
-    });
-    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+          if ((options as any).visibility)
+            throw new Error('options.visibility is not supported, did you mean options.state?');
+          if ((options as any).waitFor && (options as any).waitFor !== 'visible')
+            throw new Error('options.waitFor is not supported, did you mean options.state?');
+          const { state = 'visible' } = options;
+          if (!['attached', 'detached', 'visible', 'hidden'].includes(state))
+            throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
+          if (performActionPreChecksAndLog)
+            progress.log(`waiting for ${this._asLocator(selector)}${state === 'attached' ? '' : ' to be ' + state}`);
+
+          const promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, true, async handle => {
+            const attached = !!handle;
+            var visible = false;
+            if (attached) {
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                visible = await handle.parentNode.evaluateInUtility(([injected, node, { handle }]) => {
+                  return handle ? injected.utils.isElementVisible(handle) : false;
+                }, { handle });
+              } else {
+                visible = await handle.parentNode.evaluate((injected, { handle }) => {
+                  return handle ? injected.utils.isElementVisible(handle) : false;
+                }, { handle });
+              }
+            }
+
+            const success = {
+              attached,
+              detached: !attached,
+              visible,
+              hidden: !visible
+            }[state];
+            if (!success) return "internal:continuepolling";
+            if (options.omitReturnValue) return null;
+
+            const element = state === 'attached' || state === 'visible' ? handle : null;
+            if (!element) return null;
+            if (options.__testHookBeforeAdoptNode) await options.__testHookBeforeAdoptNode();
+            try {
+              return element;
+            } catch (e) {
+              return "internal:continuepolling";
+            }
+          }, "returnOnNotResolved");
+
+          return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+        
   }
 
   async dispatchEvent(progress: Progress, selector: string, type: string, eventInit: Object = {}, options: types.QueryOnSelectorOptions, scope?: dom.ElementHandle): Promise<void> {
@@ -823,18 +882,27 @@
 
   async evalOnSelector(selector: string, strict: boolean, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any> {
     const handle = await this.selectors.query(selector, { strict }, scope);
-    if (!handle)
-      throw new Error(`Failed to find element matching selector "${selector}"`);
-    const result = await handle.evaluateExpression(expression, { isFunction }, arg);
-    handle.dispose();
-    return result;
+            if (!handle)
+              throw new Error('Failed to find element matching selector ' + selector);
+            const result = await handle.evaluateExpression(expression, { isFunction }, arg, true);
+            handle.dispose();
+            return result;
   }
 
-  async evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle): Promise<any> {
-    const arrayHandle = await this.selectors.queryArrayInMainWorld(selector, scope);
-    const result = await arrayHandle.evaluateExpression(expression, { isFunction }, arg);
-    arrayHandle.dispose();
-    return result;
+  async evalOnSelectorAll(selector: string, expression: string, isFunction: boolean | undefined, arg: any, scope?: dom.ElementHandle, isolatedContext?: boolean): Promise<any> {
+
+          try {
+            isolatedContext = this.selectors._parseSelector(selector, { strict: false }).world !== "main" && isolatedContext;
+            const arrayHandle = await this.selectors.queryArrayInMainWorld(selector, scope, isolatedContext);
+            const result = await arrayHandle.evaluateExpression(expression, { isFunction }, arg, isolatedContext);
+            arrayHandle.dispose();
+            return result;
+          } catch (e) {
+            // Do i look like i know whats going on here?
+            if ("JSHandles can be evaluated only in the context they were created!" === e.message) return await this.evalOnSelectorAll(selector, expression, isFunction, arg, scope, isolatedContext);
+            throw e;
+          }
+        
   }
 
   async maskSelectors(selectors: ParsedSelector[], color: string): Promise<void> {
@@ -846,17 +914,35 @@
   }
 
   async querySelectorAll(selector: string): Promise<dom.ElementHandle<Element>[]> {
-    return this.selectors.queryAll(selector);
+
+          const metadata = { internal: false, log: [], method: "querySelectorAll" };
+          const progress = {
+            log: message => metadata.log.push(message),
+            metadata,
+            race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+          }
+          return await this._retryWithoutProgress(progress, selector, null, false, async (result) => {
+            if (!result || !result[0]) return [];
+            return result[1];
+          }, 'returnAll', null);
+        
   }
 
   async queryCount(selector: string, options: any): Promise<number> {
-    try {
-      return await this.selectors.queryCount(selector, options);
-    } catch (e) {
-      if (this.isNonRetriableError(e))
-        throw e;
-      return 0;
-    }
+
+          const metadata = { internal: false, log: [], method: "queryCount" };
+          const progress = {
+            log: message => metadata.log.push(message),
+            metadata,
+            race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+          }
+          return await this._retryWithoutProgress(progress, selector, null, false, async (result) => {
+            if (!result) return 0;
+            const handle = result[0];
+            const handles = result[1];
+            return handle ? handles.length : 0;
+          }, 'returnAll', null);
+        
   }
 
   async content(): Promise<string> {
@@ -878,29 +964,23 @@
   }
 
   async setContent(progress: Progress, html: string, options: types.NavigateOptions): Promise<void> {
-    const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
-    await this.raceNavigationAction(progress, async () => {
-      const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;
-      progress.log(`setting frame content, waiting until "${waitUntil}"`);
-      const context = await progress.race(this._utilityContext());
-      const tagPromise = new ManualPromise<void>();
-      this._page.frameManager._consoleMessageTags.set(tag, () => {
-        // Clear lifecycle right after document.open() - see 'tag' below.
-        this._onClearLifecycle();
-        tagPromise.resolve();
-      });
-      const lifecyclePromise = progress.race(tagPromise).then(() => this._waitForLoadState(progress, waitUntil));
-      const contentPromise = progress.race(context.evaluate(({ html, tag }) => {
-        document.open();
-        console.debug(tag);  // eslint-disable-line no-console
-        document.write(html);
-        document.close();
-      }, { html, tag }));
-      await Promise.all([contentPromise, lifecyclePromise]);
-      return null;
-    }).finally(() => {
-      this._page.frameManager._consoleMessageTags.delete(tag);
-    });
+
+          await this.raceNavigationAction(progress, async () => {
+            const waitUntil = options.waitUntil === void 0 ? "load" : options.waitUntil;
+            progress.log(`setting frame content, waiting until "${waitUntil}"`);
+            const lifecyclePromise = new Promise((resolve, reject) => {
+              this._onClearLifecycle();
+              this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
+            });
+            const setContentPromise = this._page.delegate._mainFrameSession._client.send("Page.setDocumentContent", {
+              frameId: this._id,
+              html
+            });
+            await Promise.all([setContentPromise, lifecyclePromise]);
+
+            return null;
+          });
+        
   }
 
   name(): string {
@@ -1093,50 +1173,13 @@
     selector: string,
     strict: boolean | undefined,
     performActionPreChecks: boolean,
-    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>): Promise<R> {
-    progress.log(`waiting for ${this._asLocator(selector)}`);
-    return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      if (performActionPreChecks)
-        await this._page.performActionPreChecks(progress);
+    action: (handle: dom.ElementHandle<Element>) => Promise<R | 'error:notconnected'>, returnAction: boolean | undefined): Promise<R> {
 
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, { strict }));
-      if (!resolved)
-        return continuePolling;
-      const result = await progress.race(resolved.injected.evaluateHandle((injected, { info, callId }) => {
-        const elements = injected.querySelectorAll(info.parsed, document);
-        if (callId)
-          injected.markTargetElements(new Set(elements), callId);
-        const element = elements[0] as Element | undefined;
-        let log = '';
-        if (elements.length > 1) {
-          if (info.strict)
-            throw injected.strictModeViolationError(info.parsed, elements);
-          log = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
-        } else if (element) {
-          log = `  locator resolved to ${injected.previewNode(element)}`;
-        }
-        return { log, success: !!element, element };
-      }, { info: resolved.info, callId: progress.metadata.id }));
-      const { log, success } = await progress.race(result.evaluate(r => ({ log: r.log, success: r.success })));
-      if (log)
-        progress.log(log);
-      if (!success) {
-        result.dispose();
-        return continuePolling;
-      }
-      const element = await progress.race(result.evaluateHandle(r => r.element)) as dom.ElementHandle<Element>;
-      result.dispose();
-      try {
-        const result = await action(element);
-        if (result === 'error:notconnected') {
-          progress.log('element was detached from the DOM, retrying');
-          return continuePolling;
-        }
-        return result;
-      } finally {
-        element?.dispose();
-      }
-    });
+          progress.log("waiting for " + this._asLocator(selector));
+          return this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
+            return this._retryWithoutProgress(progress, selector, strict, performActionPreChecks, action, returnAction, continuePolling);
+          });
+        
   }
 
   async rafrafTimeoutScreenshotElementWithProgress(progress: Progress, selector: string, timeout: number, options: ScreenshotOptions): Promise<Buffer> {
@@ -1289,20 +1332,61 @@
   }
 
   async isVisibleInternal(progress: Progress, selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {
-    try {
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved)
-        return false;
-      return await progress.race(resolved.injected.evaluate((injected, { info, root }) => {
-        const element = injected.querySelector(info.parsed, root || document, info.strict);
-        const state = element ? injected.elementState(element, 'visible') : { matches: false, received: 'error:notconnected' };
-        return state.matches;
-      }, { info: resolved.info, root: resolved.frame === this ? scope : undefined }));
-    } catch (e) {
-      if (this.isNonRetriableError(e))
-        throw e;
-      return false;
-    }
+
+          try {
+            const metadata = { internal: false, log: [], method: "isVisible" };
+            const progress = {
+              log: message => metadata.log.push(message),
+              metadata,
+              race: (promise) => Promise.race(Array.isArray(promise) ? promise : [promise])
+            }
+            progress.log("waiting for " + this._asLocator(selector));
+            if (selector === ":scope") {
+              const scopeParentNode = scope.parentNode || scope;
+              if (scopeParentNode.constructor.name == "ElementHandle") {
+                return await scopeParentNode.evaluateInUtility(([injected, node, { scope: handle2 }]) => {
+                  const state = handle2 ? injected.elementState(handle2, "visible") : {
+                    matches: false,
+                    received: "error:notconnected"
+                  };
+                  return state.matches;
+                }, { scope });
+              } else {
+                return await scopeParentNode.evaluate((injected, node, { scope: handle2 }) => {
+                  const state = handle2 ? injected.elementState(handle2, "visible") : {
+                    matches: false,
+                    received: "error:notconnected"
+                  };
+                  return state.matches;
+                }, { scope });
+              }
+            } else {
+              return await this._retryWithoutProgress(progress, selector, options.strict, false, async (handle) => {
+                if (!handle) return false;
+                if (handle.parentNode.constructor.name == "ElementHandle") {
+                  return await handle.parentNode.evaluateInUtility(([injected, node, { handle: handle2 }]) => {
+                    const state = handle2 ? injected.elementState(handle2, "visible") : {
+                      matches: false,
+                      received: "error:notconnected"
+                    };
+                    return state.matches;
+                  }, { handle });
+                } else {
+                  return await handle.parentNode.evaluate((injected, { handle: handle2 }) => {
+                    const state = handle2 ? injected.elementState(handle2, "visible") : {
+                      matches: false,
+                      received: "error:notconnected"
+                    };
+                    return state.matches;
+                  }, { handle });
+                }
+              }, "returnOnNotResolved", null);
+            }
+          } catch (e) {
+            if (this.isNonRetriableError(e)) throw e;
+            return false;
+          }
+        
   }
 
   async isHidden(progress: Progress, selector: string, options: types.StrictOptions = {}, scope?: dom.ElementHandle): Promise<boolean> {
@@ -1423,45 +1507,76 @@
   }
 
   private async _expectInternal(progress: Progress, selector: string | undefined, options: FrameExpectParams, lastIntermediateResult: { received?: any, isSet: boolean, errorMessage?: string }, noAbort: boolean) {
-    // The first expect check, a.k.a. one-shot, always finishes - even when progress is aborted.
-    const race = <T>(p: Promise<T>) => noAbort ? p : progress.race(p);
-    const selectorInFrame = selector ? await race(this.selectors.resolveFrameForSelector(selector, { strict: true })) : undefined;
-
-    const { frame, info } = selectorInFrame || { frame: this, info: undefined };
-    const world = options.expression === 'to.have.property' ? 'main' : (info?.world ?? 'utility');
-    const context = await race(frame._context(world));
-    const injected = await race(context.injectedScript());
-
-    const { log, matches, received, missingReceived } = await race(injected.evaluate(async (injected, { info, options, callId }) => {
-      const elements = info ? injected.querySelectorAll(info.parsed, document) : [];
-      if (callId)
-        injected.markTargetElements(new Set(elements), callId);
-      const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
-      let log = '';
-      if (isArray)
-        log = `  locator resolved to ${elements.length} element${elements.length === 1 ? '' : 's'}`;
-      else if (elements.length > 1)
-        throw injected.strictModeViolationError(info!.parsed, elements);
-      else if (elements.length)
-        log = `  locator resolved to ${injected.previewNode(elements[0])}`;
-      return { log, ...await injected.expect(elements[0], options, elements) };
-    }, { info, options, callId: progress.metadata.id }));
-
-    if (log)
-      progress.log(log);
-    // Note: missingReceived avoids `unexpected value "undefined"` when element was not found.
-    if (matches === options.isNot) {
-      if (missingReceived) {
-        lastIntermediateResult.errorMessage = 'Error: element(s) not found';
-      } else {
-        lastIntermediateResult.errorMessage = undefined;
-        lastIntermediateResult.received = received;
-      }
-      lastIntermediateResult.isSet = true;
-      if (!missingReceived && !Array.isArray(received))
-        progress.log(`  unexpected value "${renderUnexpectedValue(options.expression, received)}"`);
-    }
-    return { matches, received };
+
+          // The first expect check, a.k.a. one-shot, always finishes - even when progress is aborted.
+          const race = (p) => noAbort ? p : progress.race(p);
+          const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
+          var log, matches, received, missingReceived;
+          if (selector) {
+            const { frame, info } = await race(this.selectors.resolveFrameForSelector(selector, { strict: true }));
+            const action = async result => {
+              if (!result) {
+                if (options.expectedNumber === 0)
+                  return { matches: true };
+                // expect(locator).toBeHidden() passes when there is no element.
+                if (!options.isNot && options.expression === 'to.be.hidden')
+                  return { matches: true };
+                // expect(locator).not.toBeVisible() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.visible')
+                  return { matches: false };
+                // expect(locator).toBeAttached({ attached: false }) passes when there is no element.
+                if (!options.isNot && options.expression === 'to.be.detached')
+                  return { matches: true };
+                // expect(locator).not.toBeAttached() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.attached')
+                  return { matches: false };
+                // expect(locator).not.toBeInViewport() passes when there is no element.
+                if (options.isNot && options.expression === 'to.be.in.viewport')
+                  return { matches: false };
+                // When none of the above applies, expect does not match.
+                return { matches: options.isNot, missingReceived: true };
+              }
+
+              const handle = result[0];
+              const handles = result[1];
+
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                return await handle.parentNode.evaluateInUtility(async ([injected, node, { handle, options, handles }]) => {
+                  return await injected.expect(handle, options, handles);
+                }, { handle, options, handles });
+              } else {
+                return await handle.parentNode.evaluate(async (injected, { handle, options, handles }) => {
+                  return await injected.expect(handle, options, handles);
+                }, { handle, options, handles });
+              }
+            }
+
+            if (noAbort) {
+              var { log, matches, received, missingReceived } = await this._retryWithoutProgress(progress, selector, !isArray, false, action, 'returnAll', null);
+            } else {
+              var { log, matches, received, missingReceived } = await race(this._retryWithProgressIfNotConnected(progress, selector, !isArray, false, action, 'returnAll'));
+            }
+          } else {
+            const world = options.expression === 'to.have.property' ? 'main' : 'utility';
+            const context = await race(this._context(world));
+            const injected = await race(context.injectedScript());
+            var { matches, received, missingReceived } = await race(injected.evaluate(async (injected, { options, callId }) => {
+              return { ...await injected.expect(undefined, options, []) };
+            }, { options, callId: progress.metadata.id }));
+          }
+
+
+          if (log)
+            progress.log(log);
+          // Note: missingReceived avoids `unexpected value "undefined"` when element was not found.
+          if (matches === options.isNot) {
+            lastIntermediateResult.received = missingReceived ? '<element(s) not found>' : received;
+            lastIntermediateResult.isSet = true;
+            if (!missingReceived && !Array.isArray(received))
+              progress.log(`  unexpected value "${renderUnexpectedValue(options.expression, received)}"`);
+          }
+          return { matches, received };
+        
   }
 
   async waitForFunctionExpression<R>(progress: Progress, expression: string, isFunction: boolean | undefined, arg: any, options: { pollingInterval?: number }, world: types.World = 'main'): Promise<js.SmartHandle<R>> {
@@ -1577,29 +1692,58 @@
   }
 
   private async _callOnElementOnceMatches<T, R>(progress: Progress, selector: string, body: ElementCallback<T, R>, taskData: T, options: types.StrictOptions & { mainWorld?: boolean }, scope?: dom.ElementHandle): Promise<R> {
-    const callbackText = body.toString();
-    progress.log(`waiting for ${this._asLocator(selector)}`);
-    const promise = this.retryWithProgressAndTimeouts(progress, [0, 20, 50, 100, 100, 500], async continuePolling => {
-      const resolved = await progress.race(this.selectors.resolveInjectedForSelector(selector, options, scope));
-      if (!resolved)
-        return continuePolling;
-      const { log, success, value } = await progress.race(resolved.injected.evaluate((injected, { info, callbackText, taskData, callId, root }) => {
-        const callback = injected.eval(callbackText) as ElementCallback<T, R>;
-        const element = injected.querySelector(info.parsed, root || document, info.strict);
-        if (!element)
-          return { success: false };
-        const log = `  locator resolved to ${injected.previewNode(element)}`;
-        if (callId)
-          injected.markTargetElements(new Set([element]), callId);
-        return { log, success: true, value: callback(injected, element, taskData as T) };
-      }, { info: resolved.info, callbackText, taskData, callId: progress.metadata.id, root: resolved.frame === this ? scope : undefined }));
-      if (log)
-        progress.log(log);
-      if (!success)
-        return continuePolling;
-      return value!;
-    });
-    return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+
+          const callbackText = body.toString();
+          progress.log("waiting for "+ this._asLocator(selector));
+          var promise;
+          if (selector === ":scope") {
+            const scopeParentNode = scope.parentNode || scope;
+            if (scopeParentNode.constructor.name == "ElementHandle") {
+              promise = scopeParentNode.evaluateInUtility(([injected, node, { callbackText: callbackText2, scope: handle2, taskData: taskData2 }]) => {
+                const callback = injected.eval(callbackText2);
+                const haha = callback(injected, handle2, taskData2);
+                return haha;
+              }, {
+                callbackText,
+                scope,
+                taskData
+              });
+            } else {
+              promise = scopeParentNode.evaluate((injected, { callbackText: callbackText2, scope: handle2, taskData: taskData2 }) => {
+                const callback = injected.eval(callbackText2);
+                return callback(injected, handle2, taskData2);
+              }, {
+                callbackText,
+                scope,
+                taskData
+              });
+            }
+          } else {
+            promise = this._retryWithProgressIfNotConnected(progress, selector, options.strict, false, async (handle) => {
+              if (handle.parentNode.constructor.name == "ElementHandle") {
+                return await handle.parentNode.evaluateInUtility(([injected, node, { callbackText: callbackText2, handle: handle2, taskData: taskData2 }]) => {
+                  const callback = injected.eval(callbackText2);
+                  const haha = callback(injected, handle2, taskData2);
+                  return haha;
+                }, {
+                  callbackText,
+                  handle,
+                  taskData
+                });
+              } else {
+                return await handle.parentNode.evaluate((injected, { callbackText: callbackText2, handle: handle2, taskData: taskData2 }) => {
+                  const callback = injected.eval(callbackText2);
+                  return callback(injected, handle2, taskData2);
+                }, {
+                  callbackText,
+                  handle,
+                  taskData
+                });
+              }
+            })
+          }
+          return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
+        
   }
 
   private _setContext(world: types.World, context: dom.FrameExecutionContext | null) {
@@ -1666,6 +1810,257 @@
   private _asLocator(selector: string) {
     return asLocator(this._page.browserContext._browser.sdkLanguage(), selector);
   }
+
+  _isolatedWorld: dom.FrameExecutionContext;
+  _mainWorld: dom.FrameExecutionContext;
+  _iframeWorld: dom.FrameExecutionContext;
+
+  async _getFrameMainFrameContextId(client): Promise<number> {
+
+          try {
+            var globalDocument = await client._sendMayFail("DOM.getFrameOwner", {frameId: this._id,});
+            if (globalDocument && globalDocument.nodeId) {
+              var describedNode = await client._sendMayFail("DOM.describeNode", {
+                backendNodeId: globalDocument.backendNodeId,
+              });
+              if (describedNode) {
+                var resolvedNode = await client._sendMayFail("DOM.resolveNode", {
+                  nodeId: describedNode.node.contentDocument.nodeId,
+                });
+                var _executionContextId = parseInt(resolvedNode.object.objectId.split(".")[1], 10);
+                return _executionContextId;
+              }
+            }
+          } catch (e) {}
+          return 0;
+        
+  }
+
+  async _retryWithoutProgress(progress, selector, strict, performActionPreChecks, action, returnAction, continuePolling) {
+
+          if (performActionPreChecks) await this._page.performActionPreChecks(progress);
+          const resolved = await this.selectors.resolveInjectedForSelector(selector, { strict });
+          if (!resolved) {
+            if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') {
+              const result = await action(null);
+              return result === "internal:continuepolling" ? continuePolling : result;
+            }
+            return continuePolling;
+          }
+
+          try {
+            var client = this._page.delegate._sessionForFrame(resolved.frame)._client;
+          } catch (e) {
+            var client = this._page.delegate._mainFrameSession._client;
+          }
+          var utilityContext = await resolved.frame._utilityContext();
+          var mainContext = await resolved.frame._mainContext();
+          const documentNode = await client._sendMayFail('Runtime.evaluate', {
+            expression: "document",
+            serializationOptions: {
+              serialization: "idOnly"
+            },
+            contextId: utilityContext.delegate._contextId,
+          });
+          if (!documentNode) return continuePolling;
+          const documentScope = new dom.ElementHandle(utilityContext, documentNode.result.objectId);
+
+          let currentScopingElements;
+          try {
+            currentScopingElements = await this._customFindElementsByParsed(resolved, client, mainContext, documentScope, progress, resolved.info.parsed);
+          } catch (e) {
+            if ("JSHandles can be evaluated only in the context they were created!" === e.message) return continuePolling3;
+            await progress.race(resolved.injected.evaluateHandle((injected, { error }) => { throw error }, { error: e }));
+          }
+
+          if (currentScopingElements.length == 0) {
+            // TODO: Dispose?
+            if (returnAction === 'returnOnNotResolved' || returnAction === 'returnAll') {
+            const result = await action(null);
+            return result === "internal:continuepolling" ? continuePolling2 : result;
+          }
+            return continuePolling;
+          }
+          const resultElement = currentScopingElements[0];
+          if (currentScopingElements.length > 1) {
+            if (resolved.info.strict) {
+              await progress.race(resolved.injected.evaluateHandle((injected, {
+                info,
+                elements
+              }) => {
+                throw injected.strictModeViolationError(info.parsed, elements);
+              }, {
+                info: resolved.info,
+                elements: currentScopingElements
+              }));
+            }
+            progress.log("  locator resolved to " + currentScopingElements.length + " elements. Proceeding with the first one: " + resultElement.preview());
+          } else if (resultElement) {
+            progress.log("  locator resolved to " + resultElement.preview());
+          }
+
+          try {
+            var result = null;
+            if (returnAction === 'returnAll') {
+              result = await action([resultElement, currentScopingElements]);
+            } else {
+              result = await action(resultElement);
+            }
+            if (result === 'error:notconnected') {
+              progress.log('element was detached from the DOM, retrying');
+              return continuePolling;
+            } else if (result === 'internal:continuepolling') {
+              return continuePolling;
+            }
+            return result;
+          } finally {}
+        
+  }
+
+  async _customFindElementsByParsed(resolved, client, context, documentScope, progress, parsed) {
+
+          var parsedEdits = { ...parsed };
+          // Note: We start scoping at document level
+          var currentScopingElements = [documentScope];
+          while (parsed.parts.length > 0) {
+            var part = parsed.parts.shift();
+            parsedEdits.parts = [part];
+            // Getting All Elements
+            var elements = [];
+            var elementsIndexes = [];
+
+            if (part.name == "nth") {
+              const partNth = Number(part.body);
+              // Check if any Elements are currently scoped, else return empty array to continue polling
+              if (currentScopingElements.length == 0) return [];
+              // Check if the partNth is within the bounds of currentScopingElements
+              if (partNth > currentScopingElements.length-1 || partNth < -(currentScopingElements.length-1)) {
+                if (parsed.capture !== undefined) throw new Error("Can't query n-th element in a request with the capture.");
+                return [];
+              } else {
+                currentScopingElements = [currentScopingElements.at(partNth)];
+                continue;
+              }
+            } else if (part.name == "internal:or") {
+              var orredElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+              elements = currentScopingElements.concat(orredElements);
+            } else if (part.name == "internal:and") {
+              var andedElements = await this._customFindElementsByParsed(resolved, client, context, documentScope, progress, part.body.parsed);
+              const backendNodeIds = new Set(andedElements.map(item => item.backendNodeId));
+              elements = currentScopingElements.filter(item => backendNodeIds.has(item.backendNodeId));
+            } else {
+              for (const scope of currentScopingElements) {
+                const describedScope = await client.send('DOM.describeNode', {
+                  objectId: scope._objectId,
+                  depth: -1,
+                  pierce: true
+                });
+
+                // Elements Queryed in the "current round"
+                var queryingElements = [];
+                function findClosedShadowRoots(node, results = []) {
+                  if (!node || typeof node !== 'object') return results;
+                  if (node.shadowRoots && Array.isArray(node.shadowRoots)) {
+                    for (const shadowRoot of node.shadowRoots) {
+                      if (shadowRoot.shadowRootType === 'closed' && shadowRoot.backendNodeId) {
+                        results.push(shadowRoot.backendNodeId);
+                      }
+                      findClosedShadowRoots(shadowRoot, results);
+                    }
+                  }
+                  if (node.nodeName !== 'IFRAME' && node.children && Array.isArray(node.children)) {
+                    for (const child of node.children) {
+                      findClosedShadowRoots(child, results);
+                    }
+                  }
+                  return results;
+                }
+
+                var shadowRootBackendIds = findClosedShadowRoots(describedScope.node);
+                var shadowRoots = [];
+                for (var shadowRootBackendId of shadowRootBackendIds) {
+                  var resolvedShadowRoot = await client.send('DOM.resolveNode', {
+                    backendNodeId: shadowRootBackendId,
+                    contextId: context.delegate._contextId
+                  });
+                  shadowRoots.push(new dom.ElementHandle(context, resolvedShadowRoot.object.objectId));
+                }
+
+                for (var shadowRoot of shadowRoots) {
+                  const shadowElements = await shadowRoot.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+                   const elements = injected.querySelectorAll(parsed, node);
+                    if (callId) injected.markTargetElements(new Set(elements), callId);
+                    return elements
+                  }, {
+                    parsed: parsedEdits,
+                    callId: progress.metadata.id
+                  });
+
+                  const shadowElementsAmount = await shadowElements.getProperty("length");
+                  queryingElements.push([shadowElements, shadowElementsAmount, shadowRoot]);
+                }
+
+                // Document Root Elements (not in CSR)
+                const rootElements = await scope.evaluateHandleInUtility(([injected, node, { parsed, callId }]) => {
+                  const elements = injected.querySelectorAll(parsed, node);
+                  if (callId) injected.markTargetElements(new Set(elements), callId);
+                  return elements
+                }, {
+                  parsed: parsedEdits,
+                  callId: progress.metadata.id
+                });
+                const rootElementsAmount = await rootElements.getProperty("length");
+                queryingElements.push([rootElements, rootElementsAmount, scope]);
+
+                // Querying and Sorting the elements by their backendNodeId
+                for (var queryedElement of queryingElements) {
+                  var elementsToCheck = queryedElement[0];
+                  var elementsAmount = await queryedElement[1].jsonValue();
+                  var parentNode = queryedElement[2];
+                  for (var i = 0; i < elementsAmount; i++) {
+                    if (parentNode.constructor.name == "ElementHandle") {
+                      var elementToCheck = await parentNode.evaluateHandleInUtility(([injected, node, { index, elementsToCheck }]) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+                    } else {
+                      var elementToCheck = await parentNode.evaluateHandle((injected, { index, elementsToCheck }) => { return elementsToCheck[index]; }, { index: i, elementsToCheck: elementsToCheck });
+                    }
+                    // For other Functions/Utilities
+                    elementToCheck.parentNode = parentNode;
+                    var resolvedElement = await client.send('DOM.describeNode', {
+                      objectId: elementToCheck._objectId,
+                      depth: -1,
+                    });
+                    // Note: Possible Bug, Maybe well actually have to check the Documents Node Position instead of using the backendNodeId
+                    elementToCheck.backendNodeId = resolvedElement.node.backendNodeId;
+                    elementToCheck.nodePosition = this.selectors._findElementPositionInDomTree(elementToCheck, describedScope.node, context, "");
+                    elements.push(elementToCheck);
+                  }
+                }
+              }
+            }
+
+            // Sorting elements by their nodePosition, which is a index to the Element in the DOM tree
+            const getParts = (pos) => (pos || '').split('').map(Number);
+            elements.sort((a, b) => {
+              const partA = getParts(a.nodePosition);
+              const partB = getParts(b.nodePosition);
+              const maxLength = Math.max(partA.length, partB.length);
+
+              for (let i = 0; i < maxLength; i++) {
+                const aVal = partA[i] ?? -1;
+                const bVal = partB[i] ?? -1;
+                if (aVal !== bVal) return aVal - bVal;
+              }
+              return 0;
+            });
+
+            // Remove duplicates by backendNodeId, keeping the first occurrence
+            currentScopingElements = Array.from(
+              new Map(elements.map((e) => [e.backendNodeId, e])).values()
+            );
+          }
+          return currentScopingElements;
+        
+  }
 }
 
 class SignalBarrier {
diff -ruN playwright/packages/playwright-core/src/server/javascript.ts patchright/packages/playwright-core/src/server/javascript.ts
---
+++
@@ -149,17 +149,37 @@
     return evaluate(this._context, false /* returnByValue */, pageFunction, this, arg);
   }
 
-  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any) {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: true }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+  async evaluateExpression(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean) {
 
-  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any): Promise<JSHandle<any>> {
-    const value = await evaluateExpression(this._context, expression, { ...options, returnByValue: false }, this, arg);
-    await this._context.doSlowMo();
-    return value;
-  }
+          let context = this._context;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: true }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
+
+  async evaluateExpressionHandle(expression: string, options: { isFunction?: boolean }, arg: any, isolatedContext?: boolean): Promise<JSHandle<any>> {
+
+          let context = this._context;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = this._context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      const value = await evaluateExpression(context, expression, { ...options, returnByValue: false }, this, arg);
+      await context.doSlowMo();
+      return value;
+    }
 
   async getProperty(propertyName: string): Promise<JSHandle> {
     const objectHandle = await this.evaluateHandle((object: any, propertyName) => {
diff -ruN playwright/packages/playwright-core/src/server/page.ts patchright/packages/playwright-core/src/server/page.ts
---
+++
@@ -1,3 +1,5 @@
+// patchright - custom imports
+import { createPageBindingScript, deliverBindingResult, takeBindingHandle } from './pageBinding';
 /**
  * Copyright 2017 Google Inc. All rights reserved.
  * Modifications copyright (c) Microsoft Corporation.
@@ -303,30 +305,25 @@
   }
 
   async exposeBinding(progress: Progress, name: string, needsHandle: boolean, playwrightBinding: frames.FunctionWithSource): Promise<PageBinding> {
-    if (this._pageBindings.has(name))
-      throw new Error(`Function "${name}" has been already registered`);
-    if (this.browserContext._pageBindings.has(name))
-      throw new Error(`Function "${name}" has been already registered in the browser context`);
-    await progress.race(this.browserContext.exposePlaywrightBindingIfNeeded());
-    const binding = new PageBinding(name, playwrightBinding, needsHandle);
-    this._pageBindings.set(name, binding);
-    try {
-      await progress.race(this.delegate.addInitScript(binding.initScript));
-      await progress.race(this.safeNonStallingEvaluateInAllFrames(binding.initScript.source, 'main'));
-      return binding;
-    } catch (error) {
-      this._pageBindings.delete(name);
-      throw error;
-    }
+
+          if (this._pageBindings.has(name))
+            throw new Error(`Function "${name}" has been already registered`);
+          if (this.browserContext._pageBindings.has(name))
+            throw new Error(`Function "${name}" has been already registered in the browser context`);
+          const binding = new PageBinding(name, playwrightBinding, needsHandle);
+          this._pageBindings.set(name, binding);
+          await this.delegate.exposeBinding(binding);
+        
   }
 
   async removeExposedBindings(bindings: PageBinding[]) {
-    bindings = bindings.filter(binding => this._pageBindings.get(binding.name) === binding);
-    for (const binding of bindings)
-      this._pageBindings.delete(binding.name);
-    await this.delegate.removeInitScripts(bindings.map(binding => binding.initScript));
-    const cleanup = bindings.map(binding => `{ ${binding.cleanupScript} };\n`).join('');
-    await this.safeNonStallingEvaluateInAllFrames(cleanup, 'main');
+
+          for (const key of this._pageBindings.keys()) {
+            if (!key.startsWith('__pw'))
+              this._pageBindings.delete(key);
+          }
+          await this.delegate.removeExposedBindings();
+        
   }
 
   async setExtraHTTPHeaders(progress: Progress, headers: types.HeadersArray) {
@@ -612,9 +609,10 @@
   }
 
   async removeInitScripts(initScripts: InitScript[]) {
-    const set = new Set(initScripts);
-    this.initScripts = this.initScripts.filter(script => !set.has(script));
-    await this.delegate.removeInitScripts(initScripts);
+
+          this.initScripts.splice(0, this.initScripts.length);
+          await this.delegate.removeInitScripts();
+        
   }
 
   needsRequestInterception(): boolean {
@@ -816,13 +814,6 @@
       this.browserContext.addVisitedOrigin(origin);
   }
 
-  allInitScripts() {
-    const bindings = [...this.browserContext._pageBindings.values(), ...this._pageBindings.values()].map(binding => binding.initScript);
-    if (this.browserContext.bindingsInitScript)
-      bindings.unshift(this.browserContext.bindingsInitScript);
-    return [...bindings, ...this.browserContext.initScripts, ...this.initScripts];
-  }
-
   getBinding(name: string) {
     return this._pageBindings.get(name) || this.browserContext._pageBindings.get(name);
   }
@@ -860,6 +851,12 @@
     const snapshot = await snapshotFrameForAI(progress, this.mainFrame(), options);
     return { full: snapshot.full.join('\n'), incremental: snapshot.incremental?.join('\n') };
   }
+
+  allBindings() {
+
+          return [...this.browserContext._pageBindings.values(), ...this._pageBindings.values()];
+        
+  }
 }
 
 export class Worker extends SdkObject {
@@ -898,77 +895,82 @@
     this.openScope.close(new Error('Worker closed'));
   }
 
-  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: true, isFunction }, arg);
-  }
+  async evaluateExpression(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
 
-  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any): Promise<any> {
-    return js.evaluateExpression(await this._executionContextPromise, expression, { returnByValue: false, isFunction }, arg);
-  }
-}
+          let context = await this._executionContextPromise;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      return js.evaluateExpression(context, expression, { returnByValue: true, isFunction }, arg);
+    }
 
-export class PageBinding {
-  private static kController = '__playwright__binding__controller__';
-  static kBindingName = '__playwright__binding__';
-
-  static createInitScript() {
-    return new InitScript(`
-      (() => {
-        const module = {};
-        ${rawBindingsControllerSource.source}
-        const property = '${PageBinding.kController}';
-        if (!globalThis[property])
-          globalThis[property] = new (module.exports.BindingsController())(globalThis, '${PageBinding.kBindingName}');
-      })();
-    `);
-  }
-
-  readonly name: string;
-  readonly playwrightFunction: frames.FunctionWithSource;
-  readonly initScript: InitScript;
-  readonly needsHandle: boolean;
-  readonly cleanupScript: string;
-  forClient?: unknown;
-
-  constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean) {
-    this.name = name;
-    this.playwrightFunction = playwrightFunction;
-    this.initScript = new InitScript(`globalThis['${PageBinding.kController}'].addBinding(${JSON.stringify(name)}, ${needsHandle})`);
-    this.needsHandle = needsHandle;
-    this.cleanupScript = `globalThis['${PageBinding.kController}'].removeBinding(${JSON.stringify(name)})`;
-  }
+  async evaluateExpressionHandle(expression: string, isFunction: boolean | undefined, arg: any, isolatedContext?: boolean): Promise<any> {
 
-  static async dispatch(page: Page, payload: string, context: dom.FrameExecutionContext) {
-    const { name, seq, serializedArgs } = JSON.parse(payload) as BindingPayload;
-    try {
-      assert(context.world);
-      const binding = page.getBinding(name);
-      if (!binding)
-        throw new Error(`Function "${name}" is not exposed`);
-      let result: any;
-      if (binding.needsHandle) {
-        const handle = await context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].takeBindingHandle(arg)`, { isFunction: true }, { name, seq }).catch(e => null);
-        result = await binding.playwrightFunction({ frame: context.frame, page, context: page.browserContext }, handle);
-      } else {
-        if (!Array.isArray(serializedArgs))
-          throw new Error(`serializedArgs is not an array. This can happen when Array.prototype.toJSON is defined incorrectly`);
-        const args = serializedArgs!.map(a => parseEvaluationResultValue(a));
-        result = await binding.playwrightFunction({ frame: context.frame, page, context: page.browserContext }, ...args);
-      }
-      context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq, result }).catch(e => debugLogger.log('error', e));
-    } catch (error) {
-      context.evaluateExpressionHandle(`arg => globalThis['${PageBinding.kController}'].deliverBindingResult(arg)`, { isFunction: true }, { name, seq, error }).catch(e => debugLogger.log('error', e));
+          let context = await this._executionContextPromise;
+          if (context.constructor.name === "FrameExecutionContext") {
+              const frame = this._context.frame;
+              if (frame) {
+                  if (isolatedContext) context = await frame._utilityContext();
+                  else if (!isolatedContext) context = await frame._mainContext();
+              }
+          }
+        
+      return js.evaluateExpression(context, expression, { returnByValue: false, isFunction }, arg);
     }
-  }
 }
 
+
+      export class PageBinding {
+        readonly source: string;
+        readonly name: string;
+        readonly playwrightFunction: frames.FunctionWithSource;
+        readonly needsHandle: boolean;
+        readonly internal: boolean;
+
+        constructor(name: string, playwrightFunction: frames.FunctionWithSource, needsHandle: boolean) {
+          this.name = name;
+          this.playwrightFunction = playwrightFunction;
+          this.source = createPageBindingScript(name, needsHandle);
+          this.needsHandle = needsHandle;
+        }
+
+        static async dispatch(page: Page, payload: string, context: dom.FrameExecutionContext) {
+          const { name, seq, serializedArgs } = JSON.parse(payload) as BindingPayload;
+          try {
+            assert(context.world);
+            const binding = page.getBinding(name);
+            if (!binding)
+              throw new Error(`Function "${name}" is not exposed`);
+            let result: any;
+            if (binding.needsHandle) {
+              const handle = await context.evaluateHandle(takeBindingHandle, { name, seq }).catch(e => null);
+              result = await binding.playwrightFunction({ frame: context.frame, page, context: page._browserContext }, handle);
+            } else {
+              if (!Array.isArray(serializedArgs))
+                throw new Error(`serializedArgs is not an array. This can happen when Array.prototype.toJSON is defined incorrectly`);
+              const args = serializedArgs!.map(a => parseEvaluationResultValue(a));
+              result = await binding.playwrightFunction({ frame: context.frame, page, context: page._browserContext }, ...args);
+            }
+            context.evaluate(deliverBindingResult, { name, seq, result }).catch(e => debugLogger.log('error', e));
+          } catch (error) {
+            context.evaluate(deliverBindingResult, { name, seq, error }).catch(e => debugLogger.log('error', e));
+          }
+        }
+      }
+    
+
 export class InitScript {
   readonly source: string;
 
   constructor(source: string) {
-    this.source = `(() => {
-      ${source}
-    })();`;
+    
+            this.source = `(() => { ${source} })();`;
+          
   }
 }
 
diff -ruN playwright/packages/playwright-core/src/server/pageBinding.ts patchright/packages/playwright-core/src/server/pageBinding.ts
---
+++
@@ -0,0 +1,91 @@
+
+      /**
+       * Copyright (c) Microsoft Corporation.
+       *
+       * Licensed under the Apache License, Version 2.0 (the "License");
+       * you may not use this file except in compliance with the License.
+       * You may obtain a copy of the License at
+       *
+       * http://www.apache.org/licenses/LICENSE-2.0
+       *
+       * Unless required by applicable law or agreed to in writing, software
+       * distributed under the License is distributed on an "AS IS" BASIS,
+       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+       * See the License for the specific language governing permissions and
+       * limitations under the License.
+       */
+      import { source } from '../utils/isomorphic/oldUtilityScriptSerializers';
+
+      import type { SerializedValue } from '../utils/isomorphic/oldUtilityScriptSerializers';
+
+      export type BindingPayload = {
+        name: string;
+        seq: number;
+        serializedArgs?: SerializedValue[],
+      };
+
+      function addPageBinding(bindingName: string, needsHandle: boolean, utilityScriptSerializersFactory: typeof source) {
+        const { serializeAsCallArgument } = utilityScriptSerializersFactory;
+        // eslint-disable-next-line no-restricted-globals
+        const binding = (globalThis as any)[bindingName];
+        if (!binding || binding.toString().startsWith("(...args) => {")) return
+        // eslint-disable-next-line no-restricted-globals
+        (globalThis as any)[bindingName] = (...args: any[]) => {
+        // eslint-disable-next-line no-restricted-globals
+          const me = (globalThis as any)[bindingName];
+          if (needsHandle && args.slice(1).some(arg => arg !== undefined))
+            throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
+          let callbacks = me['callbacks'];
+          if (!callbacks) {
+            callbacks = new Map();
+            me['callbacks'] = callbacks;
+          }
+          const seq: number = (me['lastSeq'] || 0) + 1;
+          me['lastSeq'] = seq;
+          let handles = me['handles'];
+          if (!handles) {
+            handles = new Map();
+            me['handles'] = handles;
+          }
+          const promise = new Promise((resolve, reject) => callbacks.set(seq, { resolve, reject }));
+          let payload: BindingPayload;
+          if (needsHandle) {
+            handles.set(seq, args[0]);
+            payload = { name: bindingName, seq };
+          } else {
+            const serializedArgs = [];
+            for (let i = 0; i < args.length; i++) {
+              serializedArgs[i] = serializeAsCallArgument(args[i], v => {
+                return { fallThrough: v };
+              });
+            }
+            payload = { name: bindingName, seq, serializedArgs };
+          }
+          binding(JSON.stringify(payload));
+          return promise;
+        };
+        // eslint-disable-next-line no-restricted-globals
+      }
+
+      export function takeBindingHandle(arg: { name: string, seq: number }) {
+        // eslint-disable-next-line no-restricted-globals
+        const handles = (globalThis as any)[arg.name]['handles'];
+        const handle = handles.get(arg.seq);
+        handles.delete(arg.seq);
+        return handle;
+      }
+
+      export function deliverBindingResult(arg: { name: string, seq: number, result?: any, error?: any }) {
+        // eslint-disable-next-line no-restricted-globals
+        const callbacks = (globalThis as any)[arg.name]['callbacks'];
+        if ('error' in arg)
+          callbacks.get(arg.seq).reject(arg.error);
+        else
+          callbacks.get(arg.seq).resolve(arg.result);
+        callbacks.delete(arg.seq);
+      }
+
+      export function createPageBindingScript(name: string, needsHandle: boolean) {
+        return `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle}, (${source})())`;
+      }
+    
\ No newline at end of file
diff -ruN playwright/packages/playwright-core/src/server/registry/index.ts patchright/packages/playwright-core/src/server/registry/index.ts
---
+++
@@ -1457,7 +1457,7 @@
       return `pwsh bin/Debug/netX/playwright.ps1 ${parameters}`;
     default: {
       const packageManagerCommand = getPackageManagerExecCommand();
-      return `${packageManagerCommand} playwright ${parameters}`;
+      return `${packageManagerCommand} patchright ${parameters}`;
     }
   }
 }
diff -ruN playwright/packages/playwright-core/src/utils/isomorphic/oldUtilityScriptSerializers.ts patchright/packages/playwright-core/src/utils/isomorphic/oldUtilityScriptSerializers.ts
---
+++
@@ -0,0 +1,292 @@
+
+      /**
+       * Copyright (c) Microsoft Corporation.
+       *
+       * Licensed under the Apache License, Version 2.0 (the "License");
+       * you may not use this file except in compliance with the License.
+       * You may obtain a copy of the License at
+       *
+       * http://www.apache.org/licenses/LICENSE-2.0
+       *
+       * Unless required by applicable law or agreed to in writing, software
+       * distributed under the License is distributed on an "AS IS" BASIS,
+       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+       * See the License for the specific language governing permissions and
+       * limitations under the License.
+       */
+
+      type TypedArrayKind = 'i8' | 'ui8' | 'ui8c' | 'i16' | 'ui16' | 'i32' | 'ui32' | 'f32' | 'f64' | 'bi64' | 'bui64';
+
+      export type SerializedValue =
+          undefined | boolean | number | string |
+          { v: 'null' | 'undefined' | 'NaN' | 'Infinity' | '-Infinity' | '-0' } |
+          { d: string } |
+          { u: string } |
+          { bi: string } |
+          { e: { n: string, m: string, s: string } } |
+          { r: { p: string, f: string } } |
+          { a: SerializedValue[], id: number } |
+          { o: { k: string, v: SerializedValue }[], id: number } |
+          { ref: number } |
+          { h: number } |
+          { ta: { b: string, k: TypedArrayKind } };
+
+      type HandleOrValue = { h: number } | { fallThrough: any };
+
+      type VisitorInfo = {
+        visited: Map<object, number>;
+        lastId: number;
+      };
+
+      export function source() {
+
+        function isRegExp(obj: any): obj is RegExp {
+          try {
+            return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isDate(obj: any): obj is Date {
+          try {
+            return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isURL(obj: any): obj is URL {
+          try {
+            return obj instanceof URL || Object.prototype.toString.call(obj) === '[object URL]';
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isError(obj: any): obj is Error {
+          try {
+            return obj instanceof Error || (obj && Object.getPrototypeOf(obj)?.name === 'Error');
+          } catch (error) {
+            return false;
+          }
+        }
+
+        function isTypedArray(obj: any, constructor: Function): boolean {
+          try {
+            return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;
+          } catch (error) {
+            return false;
+          }
+        }
+
+        const typedArrayConstructors: Record<TypedArrayKind, Function> = {
+          i8: Int8Array,
+          ui8: Uint8Array,
+          ui8c: Uint8ClampedArray,
+          i16: Int16Array,
+          ui16: Uint16Array,
+          i32: Int32Array,
+          ui32: Uint32Array,
+          // TODO: add Float16Array once it's in baseline
+          f32: Float32Array,
+          f64: Float64Array,
+          bi64: BigInt64Array,
+          bui64: BigUint64Array,
+        };
+
+        function typedArrayToBase64(array: any) {
+          /**
+           * Firefox does not support iterating over typed arrays, so we use `.toBase64`.
+           * Error: 'Accessing TypedArray data over Xrays is slow, and forbidden in order to encourage performant code. To copy TypedArrays across origin boundaries, consider using Components.utils.cloneInto().'
+           */
+          if ('toBase64' in array)
+            return array.toBase64();
+          const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map(b => String.fromCharCode(b)).join('');
+          return btoa(binary);
+        }
+
+        function base64ToTypedArray(base64: string, TypedArrayConstructor: any) {
+          const binary = atob(base64);
+          const bytes = new Uint8Array(binary.length);
+          for (let i = 0; i < binary.length; i++)
+            bytes[i] = binary.charCodeAt(i);
+          return new TypedArrayConstructor(bytes.buffer);
+        }
+
+        function parseEvaluationResultValue(value: SerializedValue, handles: any[] = [], refs: Map<number, object> = new Map()): any {
+          if (Object.is(value, undefined))
+            return undefined;
+          if (typeof value === 'object' && value) {
+            if ('ref' in value)
+              return refs.get(value.ref);
+            if ('v' in value) {
+              if (value.v === 'undefined')
+                return undefined;
+              if (value.v === 'null')
+                return null;
+              if (value.v === 'NaN')
+                return NaN;
+              if (value.v === 'Infinity')
+                return Infinity;
+              if (value.v === '-Infinity')
+                return -Infinity;
+              if (value.v === '-0')
+                return -0;
+              return undefined;
+            }
+            if ('d' in value)
+              return new Date(value.d);
+            if ('u' in value)
+              return new URL(value.u);
+            if ('bi' in value)
+              return BigInt(value.bi);
+            if ('e' in value) {
+              const error = new Error(value.e.m);
+              error.name = value.e.n;
+              error.stack = value.e.s;
+              return error;
+            }
+            if ('r' in value)
+              return new RegExp(value.r.p, value.r.f);
+            if ('a' in value) {
+              const result: any[] = [];
+              refs.set(value.id, result);
+              for (const a of value.a)
+                result.push(parseEvaluationResultValue(a, handles, refs));
+              return result;
+            }
+            if ('o' in value) {
+              const result: any = {};
+              refs.set(value.id, result);
+              for (const { k, v } of value.o)
+                result[k] = parseEvaluationResultValue(v, handles, refs);
+              return result;
+            }
+            if ('h' in value)
+              return handles[value.h];
+            if ('ta' in value)
+              return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);
+          }
+          return value;
+        }
+
+        function serializeAsCallArgument(value: any, handleSerializer: (value: any) => HandleOrValue): SerializedValue {
+          return serialize(value, handleSerializer, { visited: new Map(), lastId: 0 });
+        }
+
+        function serialize(value: any, handleSerializer: (value: any) => HandleOrValue, visitorInfo: VisitorInfo): SerializedValue {
+          if (value && typeof value === 'object') {
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Window === 'function' && value instanceof globalThis.Window)
+              return 'ref: <Window>';
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Document === 'function' && value instanceof globalThis.Document)
+              return 'ref: <Document>';
+            // eslint-disable-next-line no-restricted-globals
+            if (typeof globalThis.Node === 'function' && value instanceof globalThis.Node)
+              return 'ref: <Node>';
+          }
+          return innerSerialize(value, handleSerializer, visitorInfo);
+        }
+
+        function innerSerialize(value: any, handleSerializer: (value: any) => HandleOrValue, visitorInfo: VisitorInfo): SerializedValue {
+          const result = handleSerializer(value);
+          if ('fallThrough' in result)
+            value = result.fallThrough;
+          else
+            return result;
+
+          if (typeof value === 'symbol')
+            return { v: 'undefined' };
+          if (Object.is(value, undefined))
+            return { v: 'undefined' };
+          if (Object.is(value, null))
+            return { v: 'null' };
+          if (Object.is(value, NaN))
+            return { v: 'NaN' };
+          if (Object.is(value, Infinity))
+            return { v: 'Infinity' };
+          if (Object.is(value, -Infinity))
+            return { v: '-Infinity' };
+          if (Object.is(value, -0))
+            return { v: '-0' };
+
+          if (typeof value === 'boolean')
+            return value;
+          if (typeof value === 'number')
+            return value;
+          if (typeof value === 'string')
+            return value;
+          if (typeof value === 'bigint')
+            return { bi: value.toString() };
+
+          if (isError(value)) {
+            let stack;
+            if (value.stack?.startsWith(value.name + ': ' + value.message)) {
+              // v8
+              stack = value.stack;
+            } else {
+              stack = `${value.name}: ${value.message}
+${value.stack}`;
+            }
+            return { e: { n: value.name, m: value.message, s: stack } };
+          }
+          if (isDate(value))
+            return { d: value.toJSON() };
+          if (isURL(value))
+            return { u: value.toJSON() };
+          if (isRegExp(value))
+            return { r: { p: value.source, f: value.flags } };
+          for (const [k, ctor] of Object.entries(typedArrayConstructors) as [TypedArrayKind, Function][]) {
+            if (isTypedArray(value, ctor))
+              return { ta: { b: typedArrayToBase64(value), k } };
+          }
+
+          const id = visitorInfo.visited.get(value);
+          if (id)
+            return { ref: id };
+
+          if (Array.isArray(value)) {
+            const a = [];
+            const id = ++visitorInfo.lastId;
+            visitorInfo.visited.set(value, id);
+            for (let i = 0; i < value.length; ++i)
+              a.push(serialize(value[i], handleSerializer, visitorInfo));
+            return { a, id };
+          }
+
+          if (typeof value === 'object') {
+            const o: { k: string, v: SerializedValue }[] = [];
+            const id = ++visitorInfo.lastId;
+            visitorInfo.visited.set(value, id);
+            for (const name of Object.keys(value)) {
+              let item;
+              try {
+                item = value[name];
+              } catch (e) {
+                continue;  // native bindings will throw sometimes
+              }
+              if (name === 'toJSON' && typeof item === 'function')
+                o.push({ k: name, v: { o: [], id: 0 } });
+              else
+                o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });
+            }
+
+            let jsonWrapper;
+            try {
+              // If Object.keys().length === 0 we fall back to toJSON if it exists
+              if (o.length === 0 && value.toJSON && typeof value.toJSON === 'function')
+                jsonWrapper = { value: value.toJSON() };
+            } catch (e) {
+            }
+            if (jsonWrapper)
+              return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);
+
+            return { o, id };
+          }
+        }
+
+        return { parseEvaluationResultValue, serializeAsCallArgument };
+      }
+    
\ No newline at end of file
diff -ruN playwright/packages/protocol/src/protocol.yml patchright/packages/protocol/src/protocol.yml
---
+++
@@ -1,17 +1,3 @@
-# Copyright (c) Microsoft Corporation.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
 StackFrame:
   type: object
   properties:
@@ -19,9 +5,6 @@
     line: int
     column: int
     function: string?
-
-# This object can be send with any rpc call in the "metadata" field.
-
 Metadata:
   type: object
   properties:
@@ -33,9 +16,7 @@
         column: int?
     title: string?
     internal: boolean?
-    # Test runner step id.
     stepId: string?
-
 ClientSideCallMetadata:
   type: object
   properties:
@@ -43,14 +24,11 @@
     stack:
       type: array?
       items: StackFrame
-
 Point:
   type: object
   properties:
     x: float
     y: float
-
-
 Rect:
   type: object
   properties:
@@ -58,11 +36,8 @@
     y: float
     width: float
     height: float
-
-
 SerializedValue:
   type: object
-  # Exactly one of the properties must be present.
   properties:
     n: float?
     b: boolean?
@@ -70,19 +45,15 @@
     v:
       type: enum?
       literals:
-      - null
-      - undefined
-      - NaN
-      - Infinity
-      - -Infinity
-      - "-0"
-    # String representation of the Date.
+        - null
+        - undefined
+        - NaN
+        - Infinity
+        - -Infinity
+        - "-0"
     d: string?
-    # String representation of the URL.
     u: string?
-    # String representation of BigInt.
     bi: string?
-    # Typed array.
     ta:
       type: object?
       properties:
@@ -90,25 +61,23 @@
         k:
           type: enum
           literals:
-          - i8
-          - ui8
-          - ui8c
-          - i16
-          - ui16
-          - i32
-          - ui32
-          - f32
-          - f64
-          - bi64
-          - bui64
-    # Serialized Error object.
+            - i8
+            - ui8
+            - ui8c
+            - i16
+            - ui16
+            - i32
+            - ui32
+            - f32
+            - f64
+            - bi64
+            - bui64
     e:
       type: object?
       properties:
         m: string
         n: string
         s: string
-    # Regular expression pattern and flags.
     r:
       type: object?
       properties:
@@ -117,7 +86,6 @@
     a:
       type: array?
       items: SerializedValue
-    # Object with keys and values.
     o:
       type: array?
       items:
@@ -125,15 +93,9 @@
         properties:
           k: string
           v: SerializedValue
-    # An index in the handles array from SerializedArgument.
     h: int?
-    # Index of the object in value-type for circular reference resolution.
     id: int?
-    # Ref to the object in value-type for circular reference resolution.
     ref: int?
-
-
-# Represents a value with handle references.
 SerializedArgument:
   type: object
   properties:
@@ -141,8 +103,6 @@
     handles:
       type: array
       items: Channel
-
-
 ExpectedTextValue:
   type: object
   properties:
@@ -152,16 +112,12 @@
     matchSubstring: boolean?
     ignoreCase: boolean?
     normalizeWhiteSpace: boolean?
-
-
 SelectorEngine:
   type: object
   properties:
     name: string
     source: string
     contentScript: boolean?
-
-
 SetNetworkCookie:
   type: object
   properties:
@@ -176,13 +132,11 @@
     sameSite:
       type: enum?
       literals:
-      - Strict
-      - Lax
-      - None
+        - Strict
+        - Lax
+        - None
     partitionKey: string?
     _crHasCrossSiteAncestor: boolean?
-
-
 NetworkCookie:
   type: object
   properties:
@@ -196,19 +150,16 @@
     sameSite:
       type: enum
       literals:
-      - Strict
-      - Lax
-      - None
+        - Strict
+        - Lax
+        - None
     partitionKey: string?
     _crHasCrossSiteAncestor: boolean?
-
-
 NameValue:
   type: object
   properties:
     name: string
     value: string
-
 IndexedDBDatabase:
   type: object
   properties:
@@ -246,7 +197,6 @@
                   items: string
                 multiEntry: boolean
                 unique: boolean
-
 SetOriginStorage:
   type: object
   properties:
@@ -257,7 +207,6 @@
     indexedDB:
       type: array?
       items: IndexedDBDatabase
-
 OriginStorage:
   type: object
   properties:
@@ -268,7 +217,6 @@
     indexedDB:
       type: array?
       items: IndexedDBDatabase
-
 SerializedError:
   type: object
   properties:
@@ -279,8 +227,6 @@
         name: string
         stack: string?
     value: SerializedValue?
-
-
 RecordHarOptions:
   type: object
   properties:
@@ -288,19 +234,17 @@
     content:
       type: enum?
       literals:
-      - embed
-      - attach
-      - omit
+        - embed
+        - attach
+        - omit
     mode:
       type: enum?
       literals:
-      - full
-      - minimal
+        - full
+        - minimal
     urlGlob: string?
     urlRegexSource: string?
     urlRegexFlags: string?
-
-
 FormField:
   type: object
   properties:
@@ -312,23 +256,18 @@
         name: string
         mimeType: string?
         buffer: binary
-
 SDKLanguage:
   type: enum
   literals:
-  - javascript
-  - python
-  - java
-  - csharp
-
+    - javascript
+    - python
+    - java
+    - csharp
 APIRequestContext:
   type: interface
-
   initializer:
     tracing: Tracing
-
   commands:
-
     fetch:
       title: '{method} "{url}"'
       parameters:
@@ -356,7 +295,6 @@
         maxRetries: int?
       returns:
         response: APIResponse
-
     fetchResponseBody:
       title: Get response body
       group: getter
@@ -364,7 +302,6 @@
         fetchUid: string
       returns:
         binary: binary?
-
     fetchLog:
       internal: true
       parameters:
@@ -373,7 +310,6 @@
         log:
           type: array
           items: string
-
     storageState:
       title: Get storage state
       parameters:
@@ -385,18 +321,14 @@
         origins:
           type: array
           items: OriginStorage
-
     disposeAPIResponse:
       internal: true
       parameters:
         fetchUid: string
-
     dispose:
       internal: true
       parameters:
         reason: string?
-
-
 APIResponse:
   type: object
   properties:
@@ -407,16 +339,13 @@
     headers:
       type: array
       items: NameValue
-
-
 LifecycleEvent:
   type: enum
   literals:
-  - load
-  - domcontentloaded
-  - networkidle
-  - commit
-
+    - load
+    - domcontentloaded
+    - networkidle
+    - commit
 CommonScreenshotOptions:
   type: mixin
   properties:
@@ -424,18 +353,18 @@
     caret:
       type: enum?
       literals:
-      - hide
-      - initial
+        - hide
+        - initial
     animations:
       type: enum?
       literals:
-      - disabled
-      - allow
+        - disabled
+        - allow
     scale:
       type: enum?
       literals:
-      - css
-      - device
+        - css
+        - device
     mask:
       type: array?
       items:
@@ -445,7 +374,6 @@
           selector: string
     maskColor: string?
     style: string?
-
 LaunchOptions:
   type: mixin
   properties:
@@ -480,8 +408,6 @@
     chromiumSandbox: boolean?
     firefoxUserPrefs: json?
     cdpPort: int?
-
-
 ContextOptions:
   type: mixin
   properties:
@@ -534,42 +460,42 @@
         send:
           type: enum?
           literals:
-          - always
-          - unauthorized
+            - always
+            - unauthorized
     deviceScaleFactor: float?
     isMobile: boolean?
     hasTouch: boolean?
     colorScheme:
       type: enum?
       literals:
-      - dark
-      - light
-      - no-preference
-      - no-override
+        - dark
+        - light
+        - no-preference
+        - no-override
     reducedMotion:
       type: enum?
       literals:
-      - reduce
-      - no-preference
-      - no-override
+        - reduce
+        - no-preference
+        - no-override
     forcedColors:
       type: enum?
       literals:
-      - active
-      - none
-      - no-override
+        - active
+        - none
+        - no-override
     acceptDownloads:
       type: enum?
       literals:
-      - accept
-      - deny
-      - internal-browser-default
+        - accept
+        - deny
+        - internal-browser-default
     contrast:
       type: enum?
       literals:
-      - no-preference
-      - more
-      - no-override
+        - no-preference
+        - more
+        - no-override
     baseURL: string?
     recordVideo:
       type: object?
@@ -584,17 +510,15 @@
     serviceWorkers:
       type: enum?
       literals:
-      - allow
-      - block
+        - allow
+        - block
     selectorEngines:
       type: array?
       items: SelectorEngine
     testIdAttributeName: string?
-
-
+    focusControl: boolean?
 LocalUtils:
   type: interface
-
   initializer:
     deviceDescriptors:
       type: array
@@ -622,12 +546,10 @@
               defaultBrowserType:
                 type: enum
                 literals:
-                - chromium
-                - firefox
-                - webkit
-
+                  - chromium
+                  - firefox
+                  - webkit
   commands:
-
     zip:
       internal: true
       parameters:
@@ -642,7 +564,6 @@
             - write
             - append
         includeSources: boolean
-
     harOpen:
       internal: true
       parameters:
@@ -650,7 +571,6 @@
       returns:
         harId: string?
         error: string?
-
     harLookup:
       internal: true
       parameters:
@@ -666,10 +586,10 @@
         action:
           type: enum
           literals:
-          - error
-          - redirect
-          - fulfill
-          - noentry
+            - error
+            - redirect
+            - fulfill
+            - noentry
         message: string?
         redirectURL: string?
         status: int?
@@ -677,18 +597,15 @@
           type: array?
           items: NameValue
         body: binary?
-
     harClose:
       internal: true
       parameters:
         harId: string
-
     harUnzip:
       internal: true
       parameters:
         zipFile: string
         harFile: string
-
     connect:
       internal: true
       parameters:
@@ -703,7 +620,6 @@
         headers:
           type: array
           items: NameValue
-
     tracingStarted:
       internal: true
       parameters:
@@ -712,17 +628,14 @@
         live: boolean?
       returns:
         stacksId: string
-
     addStackToTracingNoReply:
       internal: true
       parameters:
         callData: ClientSideCallMetadata
-
     traceDiscarded:
       internal: true
       parameters:
         stacksId: string
-
     globToRegex:
       internal: true
       parameters:
@@ -731,22 +644,17 @@
         webSocketUrl: boolean?
       returns:
         regex: string
-
 Root:
   type: interface
-
   commands:
-
     initialize:
       internal: true
       parameters:
         sdkLanguage: SDKLanguage
       returns:
         playwright: Playwright
-
 Playwright:
   type: interface
-
   initializer:
     chromium: BrowserType
     firefox: BrowserType
@@ -754,13 +662,9 @@
     android: Android
     electron: Electron
     utils: LocalUtils?
-    # Only present when connecting remotely via BrowserType.connect() method.
     preLaunchedBrowser: Browser?
-    # Only present when connecting remotely via Android.connect() method.
     preConnectedAndroidDevice: AndroidDevice?
-    # Only present when socks proxy is supported.
     socksSupport: SocksSupport?
-
   commands:
     newRequest:
       title: Create request context
@@ -792,8 +696,8 @@
             send:
               type: enum?
               literals:
-              - always
-              - unauthorized
+                - always
+                - unauthorized
         proxy:
           type: object?
           properties:
@@ -811,10 +715,8 @@
               type: array?
               items: SetOriginStorage
         tracesDir: string?
-
       returns:
         request: APIRequestContext
-
 RecorderSource:
   type: object
   properties:
@@ -832,22 +734,18 @@
           type: string
     revealLine: int?
     group: string?
-
 DebugController:
   type: interface
-
   commands:
     initialize:
       internal: true
       parameters:
         codegenId: string
         sdkLanguage: SDKLanguage
-
     setReportStateChanged:
       internal: true
       parameters:
         enabled: boolean
-
     setRecorderMode:
       internal: true
       parameters:
@@ -859,37 +757,29 @@
             - none
         testIdAttributeName: string?
         generateAutoExpect: boolean?
-
     highlight:
       internal: true
       parameters:
         selector: string?
         ariaTemplate: string?
-
     hideHighlight:
       internal: true
-
     resume:
       internal: true
-
     kill:
       internal: true
-
   events:
     inspectRequested:
       parameters:
         selector: string
         locator: string
         ariaSnapshot: string
-
     setModeRequested:
       parameters:
         mode: string
-
     stateChanged:
       parameters:
         pageCount: int
-
     sourceChanged:
       parameters:
         text: string
@@ -898,14 +788,11 @@
         actions:
           type: array?
           items: string
-
     paused:
       parameters:
         paused: boolean
-
 SocksSupport:
   type: interface
-
   commands:
     socksConnected:
       internal: true
@@ -913,56 +800,44 @@
         uid: string
         host: string
         port: int
-
     socksFailed:
       internal: true
       parameters:
         uid: string
         errorCode: string
-
     socksData:
       internal: true
       parameters:
         uid: string
         data: binary
-
     socksError:
       internal: true
       parameters:
         uid: string
         error: string
-
     socksEnd:
       internal: true
       parameters:
         uid: string
-
   events:
     socksRequested:
       parameters:
         uid: string
         host: string
         port: int
-
     socksData:
       parameters:
         uid: string
         data: binary
-
     socksClosed:
       parameters:
         uid: string
-
-
 BrowserType:
   type: interface
-
   initializer:
     executablePath: string
     name: string
-
   commands:
-
     launch:
       title: Launch browser
       parameters:
@@ -970,7 +845,6 @@
         slowMo: float?
       returns:
         browser: Browser
-
     launchPersistentContext:
       title: Launch persistent context
       parameters:
@@ -981,7 +855,6 @@
       returns:
         browser: Browser
         context: BrowserContext
-
     connectOverCDP:
       title: Connect over CDP
       parameters:
@@ -994,31 +867,24 @@
       returns:
         browser: Browser
         defaultContext: BrowserContext?
-
 Browser:
   type: interface
-
   initializer:
     version: string
     name: string
-
   commands:
-
     close:
       title: Close browser
       parameters:
         reason: string?
       flags:
         pausesBeforeAction: true
-
     killForTests:
       internal: true
-
     defaultUserAgentForTest:
       internal: true
       returns:
         userAgent: string
-
     newContext:
       title: Create context
       parameters:
@@ -1041,7 +907,6 @@
               items: SetOriginStorage
       returns:
         context: BrowserContext
-
     newContextForReuse:
       internal: true
       parameters:
@@ -1064,18 +929,15 @@
               items: SetOriginStorage
       returns:
         context: BrowserContext
-
     disconnectFromReusedContext:
       internal: true
       parameters:
         reason: string
-
     newBrowserCDPSession:
       title: Create CDP session
       group: configuration
       returns:
         session: CDPSession
-
     startTracing:
       title: Start browser tracing
       group: configuration
@@ -1085,21 +947,16 @@
         categories:
           type: array?
           items: string
-
     stopTracing:
       title: Stop browser tracing
       group: configuration
       returns:
         artifact: Artifact
-
   events:
-
     context:
       parameters:
         context: BrowserContext
-
-    close:
-
+    close: null
 ConsoleMessage:
   type: mixin
   properties:
@@ -1114,11 +971,8 @@
         url: string
         lineNumber: int
         columnNumber: int
-
-
 EventTarget:
   type: interface
-
   commands:
     waitForEventInfo:
       title: Wait for event "{info.event}"
@@ -1130,20 +984,17 @@
             phase:
               type: enum
               literals:
-              - before
-              - after
-              - log
+                - before
+                - after
+                - log
             event: string?
             message: string?
             error: string?
       flags:
         snapshot: true
-
 BrowserContext:
   type: interface
-
   extends: EventTarget
-
   initializer:
     isChromium: boolean
     requestContext: APIRequestContext
@@ -1152,9 +1003,7 @@
       type: object
       properties:
         $mixin: ContextOptions
-
   commands:
-
     addCookies:
       title: Add cookies
       group: configuration
@@ -1162,13 +1011,11 @@
         cookies:
           type: array
           items: SetNetworkCookie
-
     addInitScript:
       title: Add init script
       group: configuration
       parameters:
         source: string
-
     clearCookies:
       title: Clear cookies
       group: configuration
@@ -1182,18 +1029,15 @@
         path: string?
         pathRegexSource: string?
         pathRegexFlags: string?
-
     clearPermissions:
       title: Clear permissions
       group: configuration
-
     close:
       title: Close context
       parameters:
         reason: string?
       flags:
         pausesBeforeAction: true
-
     cookies:
       title: Get cookies
       group: getter
@@ -1205,14 +1049,12 @@
         cookies:
           type: array
           items: NetworkCookie
-
     exposeBinding:
       title: Expose binding
       group: configuration
       parameters:
         name: string
         needsHandle: boolean?
-
     grantPermissions:
       title: Grant permissions
       group: configuration
@@ -1221,22 +1063,18 @@
           type: array
           items: string
         origin: string?
-
     newPage:
       title: Create page
       returns:
         page: Page
-
     registerSelectorEngine:
       internal: true
       parameters:
         selectorEngine: SelectorEngine
-
     setTestIdAttributeName:
       internal: true
       parameters:
         testIdAttributeName: string
-
     setExtraHTTPHeaders:
       title: Set extra HTTP headers
       group: configuration
@@ -1244,7 +1082,6 @@
         headers:
           type: array
           items: NameValue
-
     setGeolocation:
       title: Set geolocation
       group: configuration
@@ -1255,7 +1092,6 @@
             longitude: float
             latitude: float
             accuracy: float?
-
     setHTTPCredentials:
       title: Set HTTP credentials
       group: configuration
@@ -1266,7 +1102,6 @@
             username: string
             password: string
             origin: string?
-
     setNetworkInterceptionPatterns:
       title: Route requests
       group: route
@@ -1279,7 +1114,6 @@
               glob: string?
               regexSource: string?
               regexFlags: string?
-
     setWebSocketInterceptionPatterns:
       title: Route WebSockets
       group: route
@@ -1292,12 +1126,10 @@
               glob: string?
               regexSource: string?
               regexFlags: string?
-
     setOffline:
       title: Set offline mode
       parameters:
         offline: boolean
-
     storageState:
       title: Get storage state
       parameters:
@@ -1309,10 +1141,8 @@
         origins:
           type: array
           items: OriginStorage
-
     pause:
       title: Pause
-
     enableRecorder:
       internal: true
       parameters:
@@ -1320,13 +1150,13 @@
         mode:
           type: enum?
           literals:
-          - inspecting
-          - recording
+            - inspecting
+            - recording
         recorderMode:
           type: enum?
           literals:
-          - default
-          - api
+            - default
+            - api
         pauseOnNextStatement: boolean?
         testIdAttributeName: string?
         launchOptions: json?
@@ -1336,10 +1166,8 @@
         outputFile: string?
         handleSIGINT: boolean?
         omitCallTracking: boolean?
-
     disableRecorder:
       internal: true
-
     newCDPSession:
       title: Create CDP session
       group: configuration
@@ -1348,7 +1176,6 @@
         frame: Frame?
       returns:
         session: CDPSession
-
     harStart:
       internal: true
       parameters:
@@ -1356,14 +1183,12 @@
         options: RecordHarOptions
       returns:
         harId: string
-
     harExport:
       internal: true
       parameters:
         harId: string?
       returns:
         artifact: Artifact
-
     createTempFiles:
       internal: true
       parameters:
@@ -1380,144 +1205,117 @@
         writableStreams:
           type: array
           items: WritableStream
-
     updateSubscription:
       internal: true
       parameters:
         event:
           type: enum
           literals:
-          - console
-          - dialog
-          - request
-          - response
-          - requestFinished
-          - requestFailed
+            - console
+            - dialog
+            - request
+            - response
+            - requestFinished
+            - requestFailed
         enabled: boolean
-
     clockFastForward:
       title: Fast forward clock "{ticksNumber|ticksString}"
       parameters:
         ticksNumber: float?
         ticksString: string?
-
     clockInstall:
       title: Install clock "{timeNumber|timeString}"
       parameters:
         timeNumber: float?
         timeString: string?
-
     clockPauseAt:
       title: Pause clock "{timeNumber|timeString}"
       parameters:
         timeNumber: float?
         timeString: string?
-
     clockResume:
       title: Resume clock
-
     clockRunFor:
       title: Run clock "{ticksNumber|ticksString}"
       parameters:
         ticksNumber: float?
         ticksString: string?
-
     clockSetFixedTime:
       title: Set fixed time "{timeNumber|timeString}"
       parameters:
         timeNumber: float?
         timeString: string?
-
     clockSetSystemTime:
       title: Set system time "{timeNumber|timeString}"
       parameters:
         timeNumber: float?
         timeString: string?
-
   events:
-
     bindingCall:
       parameters:
         binding: BindingCall
-
     console:
       parameters:
         $mixin: ConsoleMessage
         page: Page?
         worker: Worker?
-
-    close:
-
+    close: null
     dialog:
       parameters:
         dialog: Dialog
-
     page:
       parameters:
         page: Page
-
     pageError:
       parameters:
         error: SerializedError
         page: Page
-
     route:
       parameters:
         route: Route
-
     webSocketRoute:
       parameters:
         webSocketRoute: WebSocketRoute
-
     video:
       parameters:
         artifact: Artifact
-
     serviceWorker:
       parameters:
         worker: Worker
-
     request:
       parameters:
         request: Request
         page: Page?
-
     requestFailed:
       parameters:
         request: Request
         failureText: string?
         responseEndTiming: float
         page: Page?
-
     requestFinished:
       parameters:
         request: Request
         response: Response?
         responseEndTiming: float
         page: Page?
-
     response:
       parameters:
         response: Response
         page: Page?
-
     recorderEvent:
       parameters:
         event:
           type: enum
           literals:
-          - actionAdded
-          - actionUpdated
-          - signalAdded
+            - actionAdded
+            - actionUpdated
+            - signalAdded
         data: json
         page: Page
         code: string
-
 Page:
   type: interface
-
   extends: EventTarget
-
   initializer:
     mainFrame: Frame
     viewportSize:
@@ -1527,15 +1325,12 @@
         height: int
     isClosed: boolean
     opener: Page?
-
   commands:
-
     addInitScript:
       title: Add init script
       group: configuration
       parameters:
         source: string
-
     close:
       title: Close page
       parameters:
@@ -1543,7 +1338,6 @@
         reason: string?
       flags:
         pausesBeforeAction: true
-
     consoleMessages:
       title: Get console messages
       group: getter
@@ -1554,52 +1348,49 @@
             type: object
             properties:
               $mixin: ConsoleMessage
-
     emulateMedia:
       title: Emulate media
       parameters:
         media:
           type: enum?
           literals:
-          - screen
-          - print
-          - no-override
+            - screen
+            - print
+            - no-override
         colorScheme:
           type: enum?
           literals:
-          - dark
-          - light
-          - no-preference
-          - no-override
+            - dark
+            - light
+            - no-preference
+            - no-override
         reducedMotion:
           type: enum?
           literals:
-          - reduce
-          - no-preference
-          - no-override
+            - reduce
+            - no-preference
+            - no-override
         forcedColors:
           type: enum?
           literals:
-          - active
-          - none
-          - no-override
+            - active
+            - none
+            - no-override
         contrast:
           type: enum?
           literals:
-          - no-preference
-          - more
-          - no-override
+            - no-preference
+            - more
+            - no-override
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     exposeBinding:
       title: Expose binding
       group: configuration
       parameters:
         name: string
         needsHandle: boolean?
-
     goBack:
       title: Go back
       parameters:
@@ -1611,7 +1402,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     goForward:
       title: Go forward
       parameters:
@@ -1623,11 +1413,9 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     requestGC:
       title: Request garbage collection
       group: configuration
-
     registerLocatorHandler:
       title: Register locator handler
       parameters:
@@ -1635,18 +1423,15 @@
         noWaitAfter: boolean?
       returns:
         uid: int
-
     resolveLocatorHandlerNoReply:
       internal: true
       parameters:
         uid: int
         remove: boolean?
-
     unregisterLocatorHandler:
       title: Unregister locator handler
       parameters:
         uid: int
-
     reload:
       title: Reload
       parameters:
@@ -1658,7 +1443,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     expectScreenshot:
       title: Expect screenshot
       parameters:
@@ -1689,7 +1473,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     screenshot:
       title: Screenshot
       parameters:
@@ -1697,8 +1480,8 @@
         type:
           type: enum?
           literals:
-          - png
-          - jpeg
+            - png
+            - jpeg
         quality: int?
         fullPage: boolean?
         clip: Rect?
@@ -1708,7 +1491,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     setExtraHTTPHeaders:
       title: Set extra HTTP headers
       group: configuration
@@ -1716,7 +1498,6 @@
         headers:
           type: array
           items: NameValue
-
     setNetworkInterceptionPatterns:
       title: Route requests
       group: route
@@ -1729,7 +1510,6 @@
               glob: string?
               regexSource: string?
               regexFlags: string?
-
     setWebSocketInterceptionPatterns:
       title: Route WebSockets
       group: route
@@ -1742,7 +1522,6 @@
               glob: string?
               regexSource: string?
               regexFlags: string?
-
     setViewportSize:
       title: Set viewport size
       parameters:
@@ -1754,7 +1533,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     keyboardDown:
       title: Key down "{key}"
       parameters:
@@ -1763,7 +1541,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     keyboardUp:
       title: Key up "{key}"
       parameters:
@@ -1772,7 +1549,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     keyboardInsertText:
       title: Insert "{text}"
       parameters:
@@ -1781,7 +1557,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     keyboardType:
       title: Type "{text}"
       parameters:
@@ -1791,7 +1566,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     keyboardPress:
       title: Press "{key}"
       parameters:
@@ -1801,7 +1575,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     mouseMove:
       title: Mouse move
       parameters:
@@ -1812,37 +1585,34 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     mouseDown:
       title: Mouse down
       parameters:
         button:
           type: enum?
           literals:
-          - left
-          - right
-          - middle
+            - left
+            - right
+            - middle
         clickCount: int?
       flags:
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     mouseUp:
       title: Mouse up
       parameters:
         button:
           type: enum?
           literals:
-          - left
-          - right
-          - middle
+            - left
+            - right
+            - middle
         clickCount: int?
       flags:
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     mouseClick:
       title: Click
       parameters:
@@ -1852,15 +1622,14 @@
         button:
           type: enum?
           literals:
-          - left
-          - right
-          - middle
+            - left
+            - right
+            - middle
         clickCount: int?
       flags:
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     mouseWheel:
       title: Mouse wheel
       parameters:
@@ -1870,7 +1639,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     touchscreenTap:
       title: Tap
       parameters:
@@ -1880,7 +1648,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     pageErrors:
       title: Get page errors
       group: getter
@@ -1888,7 +1655,6 @@
         errors:
           type: array
           items: SerializedError
-
     pdf:
       title: PDF
       parameters:
@@ -1914,7 +1680,6 @@
         outline: boolean?
       returns:
         pdf: binary
-
     requests:
       title: Get network requests
       group: getter
@@ -1922,24 +1687,20 @@
         requests:
           type: array
           items: Request
-
     snapshotForAI:
       internal: true
       parameters:
-        # When track is present, an incremental snapshot is returned when possible.
         track: string?
         timeout: float
       returns:
         full: string
         incremental: string?
-
     startJSCoverage:
       title: Start JS coverage
       group: configuration
       parameters:
         resetOnNavigation: boolean?
         reportAnonymousScripts: boolean?
-
     stopJSCoverage:
       title: Stop JS coverage
       group: configuration
@@ -1967,13 +1728,11 @@
                           startOffset: int
                           endOffset: int
                           count: int
-
     startCSSCoverage:
       title: Start CSS coverage
       group: configuration
       parameters:
         resetOnNavigation: boolean?
-
     stopCSSCoverage:
       title: Stop CSS coverage
       group: configuration
@@ -1992,41 +1751,33 @@
                   properties:
                     start: int
                     end: int
-
     bringToFront:
       title: Bring to front
-
     updateSubscription:
       internal: true
       parameters:
         event:
           type: enum
           literals:
-          - console
-          - dialog
-          - fileChooser
-          - request
-          - response
-          - requestFinished
-          - requestFailed
+            - console
+            - dialog
+            - fileChooser
+            - request
+            - response
+            - requestFinished
+            - requestFailed
         enabled: boolean
-
   events:
-
     bindingCall:
       parameters:
         binding: BindingCall
-
-    close:
-
-    crash:
-
+    close: null
+    crash: null
     download:
       parameters:
         url: string
         suggestedFilename: string
         artifact: Artifact
-
     viewportSizeChanged:
       parameters:
         viewportSize:
@@ -2034,49 +1785,36 @@
           properties:
             width: int
             height: int
-
     fileChooser:
       parameters:
         element: ElementHandle
         isMultiple: boolean
-
     frameAttached:
       parameters:
         frame: Frame
-
     frameDetached:
       parameters:
         frame: Frame
-
     locatorHandlerTriggered:
       parameters:
         uid: int
-
     route:
       parameters:
         route: Route
-
     webSocketRoute:
       parameters:
         webSocketRoute: WebSocketRoute
-
     video:
       parameters:
         artifact: Artifact
-
     webSocket:
       parameters:
         webSocket: WebSocket
-
     worker:
       parameters:
         worker: Worker
-
-
-
 Frame:
   type: interface
-
   initializer:
     url: string
     name: string
@@ -2084,9 +1822,7 @@
     loadStates:
       type: array
       items: LifecycleEvent
-
   commands:
-
     evalOnSelector:
       title: Evaluate
       parameters:
@@ -2100,7 +1836,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     evalOnSelectorAll:
       title: Evaluate
       parameters:
@@ -2108,12 +1843,12 @@
         expression: string
         isFunction: boolean?
         arg: SerializedArgument
+        isolatedContext: boolean?
       returns:
         value: SerializedValue
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     addScriptTag:
       title: Add script tag
       parameters:
@@ -2125,7 +1860,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     addStyleTag:
       title: Add style tag
       parameters:
@@ -2136,7 +1870,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     ariaSnapshot:
       title: Aria snapshot
       parameters:
@@ -2147,7 +1880,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     blur:
       title: Blur
       parameters:
@@ -2158,7 +1890,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     check:
       title: Check
       parameters:
@@ -2172,7 +1903,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     click:
       title: Click
       parameters:
@@ -2185,19 +1915,19 @@
           items:
             type: enum
             literals:
-            - Alt
-            - Control
-            - ControlOrMeta
-            - Meta
-            - Shift
+              - Alt
+              - Control
+              - ControlOrMeta
+              - Meta
+              - Shift
         position: Point?
         delay: float?
         button:
           type: enum?
           literals:
-          - left
-          - right
-          - middle
+            - left
+            - right
+            - middle
         clickCount: int?
         timeout: float
         trial: boolean?
@@ -2206,7 +1936,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     content:
       title: Get content
       returns:
@@ -2214,7 +1943,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     dragAndDrop:
       title: Drag and drop
       parameters:
@@ -2231,7 +1959,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     dblclick:
       title: Double click
       parameters:
@@ -2243,19 +1970,19 @@
           items:
             type: enum
             literals:
-            - Alt
-            - Control
-            - ControlOrMeta
-            - Meta
-            - Shift
+              - Alt
+              - Control
+              - ControlOrMeta
+              - Meta
+              - Shift
         position: Point?
         delay: float?
         button:
           type: enum?
           literals:
-          - left
-          - right
-          - middle
+            - left
+            - right
+            - middle
         timeout: float
         trial: boolean?
         steps: int?
@@ -2263,7 +1990,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     dispatchEvent:
       title: Dispatch "{type}"
       parameters:
@@ -2276,31 +2002,30 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     evaluateExpression:
       title: Evaluate
       parameters:
         expression: string
         isFunction: boolean?
         arg: SerializedArgument
+        isolatedContext: boolean?
       returns:
         value: SerializedValue
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     evaluateExpressionHandle:
       title: Evaluate
       parameters:
         expression: string
         isFunction: boolean?
         arg: SerializedArgument
+        isolatedContext: boolean?
       returns:
         handle: JSHandle
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     fill:
       title: Fill "{value}"
       parameters:
@@ -2313,7 +2038,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     focus:
       title: Focus
       parameters:
@@ -2324,26 +2048,22 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     frameElement:
       title: Get frame element
       group: getter
       returns:
         element: ElementHandle
-
     resolveSelector:
       internal: true
       parameters:
         selector: string
       returns:
         resolvedSelector: string
-
     highlight:
       title: Highlight element
       group: configuration
       parameters:
         selector: string
-
     getAttribute:
       title: Get attribute "{name}"
       group: getter
@@ -2357,7 +2077,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     goto:
       title: Navigate to "{url}"
       parameters:
@@ -2371,7 +2090,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     hover:
       title: Hover
       parameters:
@@ -2383,11 +2101,11 @@
           items:
             type: enum
             literals:
-            - Alt
-            - Control
-            - ControlOrMeta
-            - Meta
-            - Shift
+              - Alt
+              - Control
+              - ControlOrMeta
+              - Meta
+              - Shift
         position: Point?
         timeout: float
         trial: boolean?
@@ -2395,7 +2113,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     innerHTML:
       title: Get HTML
       group: getter
@@ -2408,7 +2125,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     innerText:
       title: Get inner text
       group: getter
@@ -2421,7 +2137,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     inputValue:
       title: Get input value
       group: getter
@@ -2434,7 +2149,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isChecked:
       title: Is checked
       group: getter
@@ -2447,7 +2161,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isDisabled:
       title: Is disabled
       group: getter
@@ -2460,7 +2173,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isEnabled:
       title: Is enabled
       group: getter
@@ -2473,12 +2185,10 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isHidden:
       title: Is hidden
       group: getter
       parameters:
-        # Note: compared to other isFoo methods, isHidden is a one-shot operation without a timeout.
         selector: string
         strict: boolean?
       returns:
@@ -2486,12 +2196,10 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isVisible:
       title: Is visible
       group: getter
       parameters:
-        # Note: compared to other isFoo methods, isVisible is a one-shot operation without a timeout.
         selector: string
         strict: boolean?
       returns:
@@ -2499,7 +2207,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isEditable:
       title: Is editable
       group: getter
@@ -2512,7 +2219,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     press:
       title: Press "{key}"
       parameters:
@@ -2526,7 +2232,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     querySelector:
       title: Query selector
       parameters:
@@ -2536,7 +2241,6 @@
         element: ElementHandle?
       flags:
         snapshot: true
-
     querySelectorAll:
       title: Query selector all
       parameters:
@@ -2547,7 +2251,6 @@
           items: ElementHandle
       flags:
         snapshot: true
-
     queryCount:
       title: Query count
       parameters:
@@ -2557,7 +2260,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     selectOption:
       title: Select option
       parameters:
@@ -2585,7 +2287,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     setContent:
       title: Set content
       parameters:
@@ -2595,13 +2296,11 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     setInputFiles:
       title: Set input files
       parameters:
         selector: string
         strict: boolean?
-        # Only one of payloads, localPaths and streams should be present.
         payloads:
           type: array?
           items:
@@ -2623,7 +2322,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     tap:
       title: Tap
       parameters:
@@ -2635,11 +2333,11 @@
           items:
             type: enum
             literals:
-            - Alt
-            - Control
-            - ControlOrMeta
-            - Meta
-            - Shift
+              - Alt
+              - Control
+              - ControlOrMeta
+              - Meta
+              - Shift
         position: Point?
         timeout: float
         trial: boolean?
@@ -2647,7 +2345,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     textContent:
       title: Get text content
       group: getter
@@ -2660,13 +2357,11 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     title:
       title: Get page title
       group: getter
       returns:
         value: string
-
     type:
       title: Type "{text}"
       parameters:
@@ -2679,7 +2374,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     uncheck:
       title: Uncheck
       parameters:
@@ -2693,14 +2387,12 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     waitForTimeout:
       title: Wait for timeout
       parameters:
         waitTimeout: float
       flags:
         snapshot: true
-
     waitForFunction:
       title: Wait for function
       parameters:
@@ -2708,14 +2400,12 @@
         isFunction: boolean?
         arg: SerializedArgument
         timeout: float
-        # When present, polls on interval. Otherwise, polls on raf.
         pollingInterval: float?
       returns:
         handle: JSHandle
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     waitForSelector:
       title: Wait for selector
       parameters:
@@ -2725,16 +2415,15 @@
         state:
           type: enum?
           literals:
-          - attached
-          - detached
-          - visible
-          - hidden
+            - attached
+            - detached
+            - visible
+            - hidden
         omitReturnValue: boolean?
       returns:
         element: ElementHandle?
       flags:
         snapshot: true
-
     expect:
       title: Expect "{expression}"
       parameters:
@@ -2760,14 +2449,11 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
   events:
-
     loadstate:
       parameters:
         add: LifecycleEvent?
         remove: LifecycleEvent?
-
     navigated:
       parameters:
         url: string
@@ -2777,86 +2463,71 @@
           properties:
             request: Request?
         error: string?
-
-
-
 Worker:
   type: interface
-
   extends: EventTarget
-
   initializer:
     url: string
-
   commands:
-
     evaluateExpression:
       title: Evaluate
       parameters:
         expression: string
         isFunction: boolean?
         arg: SerializedArgument
+        isolatedContext: boolean?
       returns:
         value: SerializedValue
-
     evaluateExpressionHandle:
       title: Evaluate
       parameters:
         expression: string
         isFunction: boolean?
         arg: SerializedArgument
+        isolatedContext: boolean?
       returns:
         handle: JSHandle
-
     updateSubscription:
       internal: true
       parameters:
         event:
           type: enum
           literals:
-          - console
+            - console
         enabled: boolean
-
   events:
-
-    close:
-
-
+    close: null
 JSHandle:
   type: interface
-
   initializer:
     preview: string
-
   commands:
-
     dispose:
       internal: true
-
     evaluateExpression:
       title: Evaluate
       parameters:
         expression: string
         isFunction: boolean?
         arg: SerializedArgument
+        isolatedContext: boolean?
       returns:
         value: SerializedValue
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     evaluateExpressionHandle:
       title: Evaluate
       parameters:
         expression: string
         isFunction: boolean?
         arg: SerializedArgument
+        isolatedContext: boolean?
       returns:
         handle: JSHandle
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     getPropertyList:
       title: Get property list
       group: getter
@@ -2868,7 +2539,6 @@
             properties:
               name: string
               value: JSHandle
-
     getProperty:
       title: Get JS property
       group: getter
@@ -2876,28 +2546,19 @@
         name: string
       returns:
         handle: JSHandle
-
     jsonValue:
       title: Get JSON value
       group: getter
       returns:
         value: SerializedValue
-
   events:
-
     previewUpdated:
       parameters:
         preview: string
-
-
-
 ElementHandle:
   type: interface
-
   extends: JSHandle
-
   commands:
-
     evalOnSelector:
       title: Evaluate
       parameters:
@@ -2911,7 +2572,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     evalOnSelectorAll:
       title: Evaluate
       parameters:
@@ -2924,7 +2584,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     boundingBox:
       title: Get bounding box
       returns:
@@ -2932,7 +2591,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     check:
       title: Check
       parameters:
@@ -2944,7 +2602,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     click:
       title: Click
       parameters:
@@ -2955,19 +2612,19 @@
           items:
             type: enum
             literals:
-            - Alt
-            - Control
-            - ControlOrMeta
-            - Meta
-            - Shift
+              - Alt
+              - Control
+              - ControlOrMeta
+              - Meta
+              - Shift
         position: Point?
         delay: float?
         button:
           type: enum?
           literals:
-          - left
-          - right
-          - middle
+            - left
+            - right
+            - middle
         clickCount: int?
         timeout: float
         trial: boolean?
@@ -2976,13 +2633,11 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     contentFrame:
       title: Get content frame
       group: getter
       returns:
         frame: Frame?
-
     dblclick:
       title: Double click
       parameters:
@@ -2992,19 +2647,19 @@
           items:
             type: enum
             literals:
-            - Alt
-            - Control
-            - ControlOrMeta
-            - Meta
-            - Shift
+              - Alt
+              - Control
+              - ControlOrMeta
+              - Meta
+              - Shift
         position: Point?
         delay: float?
         button:
           type: enum?
           literals:
-          - left
-          - right
-          - middle
+            - left
+            - right
+            - middle
         timeout: float
         trial: boolean?
         steps: int?
@@ -3012,7 +2667,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     dispatchEvent:
       title: Dispatch event
       parameters:
@@ -3022,7 +2676,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     fill:
       title: Fill "{value}"
       parameters:
@@ -3033,14 +2686,12 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     focus:
       title: Focus
       flags:
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     getAttribute:
       title: Get attribute
       group: getter
@@ -3051,7 +2702,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     hover:
       title: Hover
       parameters:
@@ -3061,11 +2711,11 @@
           items:
             type: enum
             literals:
-            - Alt
-            - Control
-            - ControlOrMeta
-            - Meta
-            - Shift
+              - Alt
+              - Control
+              - ControlOrMeta
+              - Meta
+              - Shift
         position: Point?
         timeout: float
         trial: boolean?
@@ -3073,7 +2723,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     innerHTML:
       title: Get HTML
       group: getter
@@ -3082,7 +2731,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     innerText:
       title: Get inner text
       group: getter
@@ -3091,7 +2739,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     inputValue:
       title: Get input value
       group: getter
@@ -3100,7 +2747,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isChecked:
       title: Is checked
       group: getter
@@ -3109,7 +2755,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isDisabled:
       title: Is disabled
       group: getter
@@ -3118,7 +2763,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isEditable:
       title: Is editable
       group: getter
@@ -3127,7 +2771,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isEnabled:
       title: Is enabled
       group: getter
@@ -3136,7 +2779,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isHidden:
       title: Is hidden
       group: getter
@@ -3145,7 +2787,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     isVisible:
       title: Is visible
       group: getter
@@ -3154,13 +2795,11 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     ownerFrame:
       title: Get owner frame
       group: getter
       returns:
         frame: Frame?
-
     press:
       title: Press "{key}"
       parameters:
@@ -3172,7 +2811,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     querySelector:
       title: Query selector
       parameters:
@@ -3182,7 +2820,6 @@
         element: ElementHandle?
       flags:
         snapshot: true
-
     querySelectorAll:
       title: Query selector all
       parameters:
@@ -3193,7 +2830,6 @@
           items: ElementHandle
       flags:
         snapshot: true
-
     screenshot:
       title: Screenshot
       parameters:
@@ -3201,8 +2837,8 @@
         type:
           type: enum?
           literals:
-          - png
-          - jpeg
+            - png
+            - jpeg
         quality: int?
         $mixin: CommonScreenshotOptions
       returns:
@@ -3210,7 +2846,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     scrollIntoViewIfNeeded:
       title: Scroll into view
       parameters:
@@ -3219,7 +2854,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     selectOption:
       title: Select option
       parameters:
@@ -3245,7 +2879,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     selectText:
       title: Select text
       parameters:
@@ -3255,11 +2888,9 @@
         slowMo: true
         snapshot: true
         pausesBeforeAction: true
-
     setInputFiles:
       title: Set input files
       parameters:
-        # Only one of payloads, localPaths and streams should be present.
         payloads:
           type: array?
           items:
@@ -3281,7 +2912,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     tap:
       title: Tap
       parameters:
@@ -3291,11 +2921,11 @@
           items:
             type: enum
             literals:
-            - Alt
-            - Control
-            - ControlOrMeta
-            - Meta
-            - Shift
+              - Alt
+              - Control
+              - ControlOrMeta
+              - Meta
+              - Shift
         position: Point?
         timeout: float
         trial: boolean?
@@ -3303,7 +2933,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     textContent:
       title: Get text content
       group: getter
@@ -3312,7 +2941,6 @@
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     type:
       title: Type
       parameters:
@@ -3323,7 +2951,6 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     uncheck:
       title: Uncheck
       parameters:
@@ -3335,24 +2962,22 @@
         slowMo: true
         snapshot: true
         pausesBeforeInput: true
-
     waitForElementState:
       title: Wait for state
       parameters:
         state:
           type: enum
           literals:
-          - visible
-          - hidden
-          - stable
-          - enabled
-          - disabled
-          - editable
+            - visible
+            - hidden
+            - stable
+            - enabled
+            - disabled
+            - editable
         timeout: float
       flags:
         snapshot: true
         pausesBeforeAction: true
-
     waitForSelector:
       title: Wait for selector
       parameters:
@@ -3362,19 +2987,16 @@
         state:
           type: enum?
           literals:
-          - attached
-          - detached
-          - visible
-          - hidden
+            - attached
+            - detached
+            - visible
+            - hidden
       returns:
         element: ElementHandle?
       flags:
         snapshot: true
-
-
 Request:
   type: interface
-
   initializer:
     frame: Frame?
     serviceWorker: Worker?
@@ -3388,43 +3010,33 @@
     isNavigationRequest: boolean
     redirectedFrom: Request?
     hasResponse: boolean
-
   commands:
-
     response:
       internal: true
       returns:
         response: Response?
-
     rawRequestHeaders:
       internal: true
       returns:
         headers:
           type: array
           items: NameValue
-
   events:
-    response:
-
+    response: null
 Route:
   type: interface
-
   initializer:
     request: Request
-
   commands:
-
     redirectNavigationRequest:
       internal: true
       parameters:
         url: string
-
     abort:
       title: Abort request
       group: route
       parameters:
         errorCode: string?
-
     continue:
       title: Continue request
       group: route
@@ -3436,12 +3048,10 @@
           items: NameValue
         postData: binary?
         isFallback: boolean
-
     fulfill:
       title: Fulfill request
       group: route
       parameters:
-        # default is 200
         status: int?
         headers:
           type: array?
@@ -3449,76 +3059,59 @@
         body: string?
         isBase64: boolean?
         fetchResponseUid: string?
-
-
 WebSocketRoute:
   type: interface
-
   initializer:
     url: string
-
   commands:
-
     connect:
       title: Connect WebSocket to server
       group: route
-
     ensureOpened:
       internal: true
-
     sendToPage:
       title: Send WebSocket message
       group: route
       parameters:
         message: string
         isBase64: boolean
-
     sendToServer:
       title: Send WebSocket message
       group: route
       parameters:
         message: string
         isBase64: boolean
-
     closePage:
       internal: true
       parameters:
         code: int?
         reason: string?
         wasClean: boolean
-
     closeServer:
       internal: true
       parameters:
         code: int?
         reason: string?
         wasClean: boolean
-
   events:
-
     messageFromPage:
       parameters:
         message: string
         isBase64: boolean
-
     messageFromServer:
       parameters:
         message: string
         isBase64: boolean
-
     closePage:
       parameters:
         code: int?
         reason: string?
         wasClean: boolean
-
     closeServer:
       parameters:
         code: int?
         reason: string?
         wasClean: boolean
-
-
 ResourceTiming:
   type: object
   properties:
@@ -3530,10 +3123,8 @@
     connectEnd: float
     requestStart: float
     responseStart: float
-
 Response:
   type: interface
-
   initializer:
     request: Request
     url: string
@@ -3544,39 +3135,30 @@
       items: NameValue
     timing: ResourceTiming
     fromServiceWorker: boolean
-
-
   commands:
-
     body:
       title: Get response body
       group: getter
       returns:
         binary: binary
-
     securityDetails:
       internal: true
       returns:
         value: SecurityDetails?
-
     serverAddr:
       internal: true
       returns:
         value: RemoteAddr?
-
     rawResponseHeaders:
       internal: true
       returns:
         headers:
           type: array
           items: NameValue
-
     sizes:
       internal: true
       returns:
         sizes: RequestSizes
-
-
 SecurityDetails:
   type: object
   properties:
@@ -3585,7 +3167,6 @@
     subjectName: string?
     validFrom: float?
     validTo: float?
-
 RequestSizes:
   type: object
   properties:
@@ -3593,46 +3174,32 @@
     requestHeadersSize: int
     responseBodySize: int
     responseHeadersSize: int
-
-
 RemoteAddr:
   type: object
   properties:
     ipAddress: string
     port: int
-
-
 WebSocket:
   type: interface
-
   extends: EventTarget
-
   initializer:
     url: string
-
   events:
-    open:
-
+    open: null
     frameSent:
       parameters:
         opcode: int
         data: string
-
     frameReceived:
       parameters:
         opcode: int
         data: string
-
     socketError:
       parameters:
         error: string
-
-    close:
-
-
+    close: null
 BindingCall:
   type: interface
-
   initializer:
     frame: Frame
     name: string
@@ -3640,45 +3207,32 @@
       type: array?
       items: SerializedValue
     handle: JSHandle?
-
   commands:
-
     reject:
       internal: true
       parameters:
         error: SerializedError
-
     resolve:
       internal: true
       parameters:
         result: SerializedArgument
-
-
-
 Dialog:
   type: interface
-
   initializer:
     page: Page?
     type: string
     message: string
     defaultValue: string
-
   commands:
-
     accept:
       title: Accept dialog
       parameters:
         promptText: string?
-
     dismiss:
       title: Dismiss dialog
-
 Tracing:
   type: interface
-
   commands:
-
     tracingStart:
       title: Start tracing
       group: configuration
@@ -3687,7 +3241,6 @@
         snapshots: boolean?
         screenshots: boolean?
         live: boolean?
-
     tracingStartChunk:
       title: Start tracing
       group: configuration
@@ -3696,7 +3249,6 @@
         title: string?
       returns:
         traceName: string
-
     tracingGroup:
       title: Trace "{name}"
       parameters:
@@ -3707,10 +3259,8 @@
             file: string
             line: int?
             column: int?
-
     tracingGroupEnd:
       title: Group end
-
     tracingStopChunk:
       title: Stop tracing
       group: configuration
@@ -3718,100 +3268,69 @@
         mode:
           type: enum
           literals:
-          - archive
-          - discard
-          - entries
+            - archive
+            - discard
+            - entries
       returns:
-        # The artifact may be missing if the browser closes while tracing is being stopped.
-        # Or it can be missing if client-side compression is taking place.
         artifact: Artifact?
-        # For local mode, these are all entries.
         entries:
           type: array?
           items: NameValue
-
     tracingStop:
       title: Stop tracing
       group: configuration
-
-
 Artifact:
   type: interface
-
   initializer:
     absolutePath: string
-
   commands:
-
     pathAfterFinished:
       internal: true
       returns:
         value: string
-
-    # Blocks path/failure/delete/context.close until saved to the local |path|.
     saveAs:
       internal: true
       parameters:
         path: string
-
-    # Blocks path/failure/delete/context.close until the stream is closed.
     saveAsStream:
       internal: true
       returns:
         stream: Stream
-
     failure:
       internal: true
       returns:
         error: string?
-
     stream:
       internal: true
       returns:
         stream: Stream
-
     cancel:
       internal: true
-
     delete:
       internal: true
-
-
 Stream:
   type: interface
-
   commands:
-
     read:
       internal: true
       parameters:
         size: int?
       returns:
         binary: binary
-
     close:
       internal: true
-
-
 WritableStream:
   type: interface
-
   commands:
-
     write:
       internal: true
       parameters:
         binary: binary
-
     close:
       internal: true
-
-
 CDPSession:
   type: interface
-
   commands:
-
     send:
       title: Send CDP command
       group: configuration
@@ -3820,24 +3339,17 @@
         params: json?
       returns:
         result: json
-
     detach:
       title: Detach CDP session
       group: configuration
-
   events:
-
     event:
       parameters:
         method: string
         params: json?
-
-
 Electron:
   type: interface
-
   commands:
-
     launch:
       title: Launch electron
       parameters:
@@ -3853,17 +3365,17 @@
         acceptDownloads:
           type: enum?
           literals:
-          - accept
-          - deny
-          - internal-browser-default
+            - accept
+            - deny
+            - internal-browser-default
         bypassCSP: boolean?
         colorScheme:
           type: enum?
           literals:
-          - dark
-          - light
-          - no-preference
-          - no-override
+            - dark
+            - light
+            - no-preference
+            - no-override
         extraHTTPHeaders:
           type: array?
           items: NameValue
@@ -3898,28 +3410,20 @@
           type: array?
           items: SelectorEngine
         testIdAttributeName: string?
-
       returns:
         electronApplication: ElectronApplication
-
-
 ElectronApplication:
   type: interface
-
   extends: EventTarget
-
   initializer:
     context: BrowserContext
-
   commands:
-
     browserWindow:
       internal: true
       parameters:
         page: Page
       returns:
         handle: JSHandle
-
     evaluateExpression:
       title: Evaluate
       parameters:
@@ -3928,7 +3432,6 @@
         arg: SerializedArgument
       returns:
         value: SerializedValue
-
     evaluateExpressionHandle:
       title: Evaluate
       parameters:
@@ -3937,27 +3440,22 @@
         arg: SerializedArgument
       returns:
         handle: JSHandle
-
     updateSubscription:
       internal: true
       parameters:
         event:
           type: enum
           literals:
-          - console
+            - console
         enabled: boolean
-
   events:
-    close:
+    close: null
     console:
       parameters:
         $mixin: ConsoleMessage
-
 Android:
   type: interface
-
   commands:
-
     devices:
       internal: true
       parameters:
@@ -3968,34 +3466,26 @@
         devices:
           type: array
           items: AndroidDevice
-
 AndroidSocket:
   type: interface
-
   commands:
     write:
       internal: true
       parameters:
         data: binary
-
     close:
       internal: true
-
   events:
     data:
       parameters:
         data: binary
-    close:
-
+    close: null
 AndroidDevice:
   type: interface
-
   extends: EventTarget
-
   initializer:
     model: string
     serial: string
-
   commands:
     wait:
       title: Wait
@@ -4004,23 +3494,20 @@
         state:
           type: enum?
           literals:
-          - gone
+            - gone
         timeout: float
-
     fill:
       title: Fill "{text}"
       parameters:
         androidSelector: AndroidSelector
         text: string
         timeout: float
-
     tap:
       title: Tap
       parameters:
         androidSelector: AndroidSelector
         duration: float?
         timeout: float
-
     drag:
       title: Drag
       parameters:
@@ -4028,7 +3515,6 @@
         dest: Point
         speed: float?
         timeout: float
-
     fling:
       title: Fling
       parameters:
@@ -4036,19 +3522,17 @@
         direction:
           type: enum
           literals:
-          - up
-          - down
-          - left
-          - right
+            - up
+            - down
+            - left
+            - right
         speed: float?
         timeout: float
-
     longTap:
       title: Long tap
       parameters:
         androidSelector: AndroidSelector
         timeout: float
-
     pinchClose:
       title: Pinch close
       parameters:
@@ -4056,7 +3540,6 @@
         percent: float
         speed: float?
         timeout: float
-
     pinchOpen:
       title: Pinch open
       parameters:
@@ -4064,7 +3547,6 @@
         percent: float
         speed: float?
         timeout: float
-
     scroll:
       title: Scroll
       parameters:
@@ -4072,14 +3554,13 @@
         direction:
           type: enum
           literals:
-          - up
-          - down
-          - left
-          - right
+            - up
+            - down
+            - left
+            - right
         percent: float
         speed: float?
         timeout: float
-
     swipe:
       title: Swipe
       parameters:
@@ -4087,41 +3568,35 @@
         direction:
           type: enum
           literals:
-          - up
-          - down
-          - left
-          - right
+            - up
+            - down
+            - left
+            - right
         percent: float
         speed: float?
         timeout: float
-
     info:
       internal: true
       parameters:
         androidSelector: AndroidSelector
       returns:
         info: AndroidElementInfo
-
     screenshot:
       title: Screenshot
       returns:
         binary: binary
-
     inputType:
       title: Type
       parameters:
         text: string
-
     inputPress:
       title: Press
       parameters:
         key: string
-
     inputTap:
       title: Tap
       parameters:
         point: Point
-
     inputSwipe:
       title: Swipe
       parameters:
@@ -4129,14 +3604,12 @@
           type: array
           items: Point
         steps: int
-
     inputDrag:
       title: Drag
       parameters:
         from: Point
         to: Point
         steps: int
-
     launchBrowser:
       title: Launch browser
       parameters:
@@ -4152,17 +3625,14 @@
             bypass: string?
             username: string?
             password: string?
-
       returns:
         context: BrowserContext
-
     open:
       title: Open app
       parameters:
         command: string
       returns:
         socket: AndroidSocket
-
     shell:
       title: Execute shell command
       group: configuration
@@ -4170,7 +3640,6 @@
         command: string
       returns:
         result: binary
-
     installApk:
       title: Install apk
       parameters:
@@ -4178,44 +3647,34 @@
         args:
           type: array?
           items: string
-
     push:
       title: Push
       parameters:
         file: binary
         path: string
         mode: int?
-
     connectToWebView:
       title: Connect to Web View
       parameters:
         socketName: string
       returns:
         context: BrowserContext
-
     close:
       internal: true
-
   events:
-    close:
-
+    close: null
     webViewAdded:
       parameters:
         webView: AndroidWebView
-
     webViewRemoved:
       parameters:
         socketName: string
-
-
 AndroidWebView:
   type: object
   properties:
     pid: int
     pkg: string
     socketName: string
-
-
 AndroidSelector:
   type: object
   properties:
@@ -4243,8 +3702,6 @@
     scrollable: boolean?
     selected: boolean?
     text: string?
-
-
 AndroidElementInfo:
   type: object
   properties:
@@ -4266,26 +3723,19 @@
     longClickable: boolean
     scrollable: boolean
     selected: boolean
-
-
 JsonPipe:
   type: interface
-
   commands:
     send:
       internal: true
       parameters:
         message: json
-
     close:
       internal: true
-
   events:
-
     message:
       parameters:
         message: json
-
     closed:
       parameters:
         reason: string?
diff -ruN playwright/packages/recorder/src/recorder.tsx patchright/packages/recorder/src/recorder.tsx
---
+++
@@ -56,7 +56,7 @@
   window.playwrightSelectSource = selectedSourceId => setSelectedFileId(selectedSourceId);
 
   React.useEffect(() => {
-    window.dispatch({ event: 'setAutoExpect', params: { autoExpect } });
+    try { window.dispatch({ event: 'setAutoExpect', params: { autoExpect } }); } catch {}
   }, [autoExpect]);
 
   const source = React.useMemo(() => {
